
java核心技术学习
五子棋算法


 /**
  * 五子棋算法
  * 
  * @param n
  *            - 代表棋子颜色的整数
  * @param Arow
  *            - 行编号
  * @param Acolumn
  *            - 列编号
  * @return 胜利一方的棋子颜色的整数
  */
 public int arithmetic(int n, int Arow, int Acolumn) {
  int n3 = n ^ 3;
  byte n8 = (byte) (n ^ 8);
  byte[][] note = gobangModel1.getChessmanArrayCopy();
  int BCount = 1;
  // 纵向查找
  boolean Lbol = true;
  boolean Rbol = true;
  BCount = 1;
  for (int i = 1; i <= 5; i++) {
   if ((Acolumn + i) > 14) {// 如果棋子超出最大列数
    Rbol = false;
   }
   if ((Acolumn - i) < 0) {// 如果棋子超出最小列数
    Lbol = false;
   }
   if (Rbol == true) {
    if (note[Arow][Acolumn + i] == n
      || note[Arow][Acolumn + i] == n3) {// 如果横向向右有相同的棋子
     ++BCount;
     note[Arow][Acolumn + i] = n8;
    } else {
     Rbol = false;
    }
   }
   if (Lbol == true) {
    if (note[Arow][Acolumn - i] == n
      || note[Arow][Acolumn - i] == n3) {// 如果横向向左有相同的棋子
     ++BCount;
     note[Arow][Acolumn - i] = n8;
    } else {
     Lbol = false;
    }
   }
   if (BCount >= 5) {// 如果同类型的棋子数大于等于5个
    note[Arow][Acolumn] = n8;
    gobangModel1.updateChessmanArray(note);
    repaint();
    return n; // 返回胜利一方的棋子
   }
  }
  // 横向查找
  note = gobangModel1.getChessmanArrayCopy();
  boolean Ubol = true;
  boolean Dbol = true;
  BCount = 1;
  for (int i = 1; i <= 5; i++) {
   if ((Arow + i) > 14) {// 如果超出棋盘的最大行数
    Dbol = false;
   }
   if ((Arow - i) < 0) {// 如果超出棋盘的最小行数
    Ubol = false;
   }
   if (Dbol == true) {
    if (note[Arow + i][Acolumn] == n
      || note[Arow + i][Acolumn] == n3) { // 如果向上有同类型的棋子
     ++BCount;
     note[Arow + i][Acolumn] = n8;
    } else {
     Dbol = false;
    }
   }
   if (Ubol == true) {
    if (note[Arow - i][Acolumn] == n
      || note[Arow - i][Acolumn] == n3) { // 如果向下有同类型的棋子
     ++BCount;
     note[Arow - i][Acolumn] = n8;
    } else {
     Ubol = false;
    }
   }
   if (BCount >= 5) { // 如果同类型的棋子大于等于5个
    note[Arow][Acolumn] = n8;
    gobangModel1.updateChessmanArray(note);
    repaint();
    return n; // 返回胜利一方的棋子
   }
  }
  // 正斜查找
  note = gobangModel1.getChessmanArrayCopy();
  boolean LUbol = true;
  boolean RDbol = true;
  BCount = 1;
  for (int i = 1; i <= 5; i++) {
   if ((Arow - i) < 0 || (Acolumn - i < 0)) {// 如果超出左面的斜线
    LUbol = false;
   }
   if ((Arow + i) > 14 || (Acolumn + i > 14)) {// 如果超出右面的斜线
    RDbol = false;
   }
   if (LUbol == true) {
    if (note[Arow - i][Acolumn - i] == n
      || note[Arow - i][Acolumn - i] == n3) {// 如果左上斜线上有相同类型的棋子
     ++BCount;
     note[Arow - i][Acolumn - i] = n8;
    } else {
     LUbol = false;
    }
   }
   if (RDbol == true) {
    if (note[Arow + i][Acolumn + i] == n
      || note[Arow + i][Acolumn + i] == n3) {// 如果右下斜线上有相同类型的棋子
     ++BCount;
     note[Arow + i][Acolumn + i] = n8;
    } else {
     RDbol = false;
    }
   }
   if (BCount >= 5) {// 如果同类型的棋子大于等于5个
    note[Arow][Acolumn] = n8;
    gobangModel1.updateChessmanArray(note);
    repaint();
    return n; // 返回胜利一方的棋子
   }
  }
  // 反斜查找
  note = gobangModel1.getChessmanArrayCopy();
  boolean RUbol = true;
  boolean LDbol = true;
  BCount = 1;
  for (int i = 1; i <= 5; i++) {
   if ((Arow - i) < 0 || (Acolumn + i > 14)) {
    RUbol = false;
   }
   if ((Arow + i) > 14 || (Acolumn - i < 0)) {
    LDbol = false;
   }
   if (RUbol == true) {
    if (note[Arow - i][Acolumn + i] == n
      || note[Arow - i][Acolumn + i] == n3) {// 如果左下斜线上有相同类型的棋子
     ++BCount;
     note[Arow - i][Acolumn + i] = n8;
    } else {
     RUbol = false;
    }
   }
   if (LDbol == true) {
    if (note[Arow + i][Acolumn - i] == n
      || note[Arow + i][Acolumn - i] == n3) {// 如果右上斜线上有相同类型的棋子
     ++BCount;
     note[Arow + i][Acolumn - i] = n8;
    } else {
     LDbol = false;
    }
   }
   if (BCount >= 5) {// 如果同类型的棋子大于等于5个
    note[Arow][Acolumn] = n8;
    gobangModel1.updateChessmanArray(note);
    repaint();
    return n;// 返回胜利一方的棋子
   }
  }
  return 0;
 }
 Copyright ©2011 lyt. All Rights Reserved.


java核心技术学习
五子棋表格绘制


/**
  * 绘制棋盘的方法
  * 
  * @param g
  *            - 绘图对象
  */
 private void drawPanel(Graphics2D g) {
  Composite composite = g.getComposite(); // 备份合成规则
  Color color = g.getColor(); // 备份前景颜色
  g.setComposite(AlphaComposite.SrcOver.derive(0.6f));// 设置透明合成
  g.setColor(new Color(0xAABBAA)); // 设置前景白色
  g.fill3DRect(0, 0, getWidth(), getHeight(), true); // 绘制半透明的矩形
  g.setComposite(composite); // 恢复合成规则
  g.setColor(color); // 恢复原来前景色
  int w = getWidth(); // 棋盘宽度
  int h = getHeight(); // 棋盘高度
  int chessW = w / 15, chessH = h / 15; // 棋子宽度和高度
  int left = chessW / 2 + (w % 15) / 2; // 棋盘左边界
  int right = left + chessW * 14; // 棋盘右边界
  int top = chessH / 2 + (h % 15) / 2; // 棋盘上边界
  int bottom = top + chessH * 14; // 棋盘下边界
  for (int i = 0; i < 15; i++) {
   // 画每条横线
   g.drawLine(left, top + (i * chessH), right, top + (i * chessH));
  }
  for (int i = 0; i < 15; i++) {
   // 画每条竖线
   g.drawLine(left + (i * chessW), top, left + (i * chessW), bottom);
  }
 }
 Copyright ©2011 lyt. All Rights Reserved.



java核心技术学习
素数


题目：判断101-200 之间有多少个素数，并输出所有素数。
1.程序分析：判断素数的方法：用一个数分别去除2 到sqrt(这个数)，
如果能被整除，
则表明此数不是素数，反之是素数。 */
package cn.com.flywater.FiftyAlgorthm;
public class SecondPrimeNumber {
public static int count = 0;
public static void main(String[] args) {
for(int i=101;i<200;i++){
boolean b = true;//默认此数就素数
for(int j=2;j<=Math.sqrt(i);j++){
if(i%j==0){
b = false; //此数不是素数
break;
}
}
if(b){
count++;
System.out.print(i+" ");
}
}
System.out.println("\n 素数的个数："+count);
}
}
 Copyright ©2011 lyt. All Rights Reserved.




java核心技术学习
Dao抽象类


/*
*数据库连接
*/
public class BaseDAO {
    private static final String DRIVER =
            "com.microsoft.jdbc.sqlserver.SQLServerDriver"; //驱动
    private static final String URL =
            "jdbc:microsoft:sqlserver://localhost:1433;databaseName=physics";//连接
    private static final String USERNAME = "sa";//用户名
    private static final String USERPWD = "sa";//密码
    private Connection conn;//????
   
    public Connection getConn() throws ClassNotFoundException, SQLException {
        Class.forName(DRIVER);//得到数据库驱动程序
        conn = DriverManager.getConnection(URL,USERNAME,USERPWD);//创建库连接
        return conn;
    }
 
    /**
     * 关闭数据库
     * @param conn 要关闭的连接
     * @param stmt 要关闭的语句集
     * @param rs 要关闭的结果集
     */
    public void closeConn(Connection conn, Statement stmt, ResultSet rs) {
        if (rs != null) {
            try {
                rs.close();
            } catch (SQLException ex) {
                Logger.getLogger(BaseDAO.class.getName()).log(Level.SEVERE, null, ex);
            }
        }
        if (stmt != null) {
            try {
                stmt.close();
            } catch (SQLException ex) {
                Logger.getLogger(BaseDAO.class.getName()).log(Level.SEVERE, null, ex);
            }
        }
        if (conn != null) {
            try {
                conn.close();
            } catch (SQLException ex) {
                Logger.getLogger(BaseDAO.class.getName()).log(Level.SEVERE, null, ex);
            }
        }
    }
 
    /**
     * 数据库的插入操作
     * @param b 要插入的实体Bean
     * @return true表示插入成功，false表示失败
     */
//    public boolean insert(BasePOJO b) {
//        boolean flag = false;
//        return flag;
//    }
//
//    /**
//     * 数据库的删除操作
//     * @param b 要删除的实体Bean
//     * @return true表示删除成功，false表示失败
//     */
//    public boolean delete(BasePOJO b) {
//        boolean flag = false;
//        return flag;
//    }
//
//    /**
//     * 数据库的更新操作
//     * @param b 要更新的实体Bean
//     * @return true表示更新成功，false表示失败
//     */
//    public boolean update(BasePOJO b) {
//        boolean flag = false;
//        return flag;
//    }
}

 Copyright ©2011 lyt. All Rights Reserved.




java核心技术学习
网站源码读取

//读取源码
  // get URL string from command line or use default
  String urlString = "http://www.baidu.com";
  // open reader for URL
  InputStreamReader in = new InputStreamReader(new URL(urlString)
    .openStream());
  // read contents into string buffer
  StringBuilder input = new StringBuilder();
  int ch;
  while ((ch = in.read()) != -1) {
   input.append((char) ch);
  }
  System.out.println(input);
//读取超链接
  // search for all occurrences of pattern
  String patternString = "<a\\s+href\\s*=\\s*(\"[^\"]*\"|[^\\s>])\\s*>";
  Pattern pattern = Pattern.compile(patternString,
    Pattern.CASE_INSENSITIVE);
  Matcher matcher = pattern.matcher(input);
  while (matcher.find()) {
   int start = matcher.start();
   int end = matcher.end();
   String match = input.substring(start, end);
   System.out.println(match);
  }
 Copyright ©2011 lyt. All Rights Reserved.




java核心技术学习
人民币转化大写

package test.format;
import java.text.NumberFormat;
import java.util.HashMap;
public class SimpleMoneyFormat { 
public static final String EMPTY = "";
public static final String ZERO = "零";
public static final String ONE = "壹";
public static final String TWO = "贰";
public static final String THREE = "叁";
public static final String FOUR = "肆";
public static final String FIVE = "伍";
public static final String SIX = "陆";
public static final String SEVEN = "柒";
public static final String EIGHT = "捌";
public static final String NINE = "玖";
public static final String TEN = "拾";
public static final String HUNDRED = "佰";
public static final String THOUSAND = "仟";
public static final String TEN_THOUSAND = "万";
public static final String HUNDRED_MILLION = "亿";
public static final String YUAN = "元";
public static final String JIAO = "角";
public static final String FEN = "分";
public static final String DOT = ".";
private static SimpleMoneyFormat formatter = null;
private HashMap chineseNumberMap = new HashMap();
private HashMap chineseMoneyPattern = new HashMap();
private NumberFormat numberFormat = NumberFormat.getInstance();
private SimpleMoneyFormat() { 
numberFormat.setMaximumFractionDigits(4);
numberFormat.setMinimumFractionDigits(2);
numberFormat.setGroupingUsed(false);
chineseNumberMap.put("0", ZERO);
chineseNumberMap.put("1", ONE);
chineseNumberMap.put("2", TWO);
chineseNumberMap.put("3", THREE);
chineseNumberMap.put("4", FOUR);
chineseNumberMap.put("5", FIVE);
chineseNumberMap.put("6", SIX);
chineseNumberMap.put("7", SEVEN);
chineseNumberMap.put("8", EIGHT);
chineseNumberMap.put("9", NINE);
chineseNumberMap.put(DOT, DOT);
chineseMoneyPattern.put("1", TEN);
chineseMoneyPattern.put("2", HUNDRED);
chineseMoneyPattern.put("3", THOUSAND);
chineseMoneyPattern.put("4", TEN_THOUSAND);
chineseMoneyPattern.put("5", TEN);
chineseMoneyPattern.put("6", HUNDRED);
chineseMoneyPattern.put("7", THOUSAND);
chineseMoneyPattern.put("8", HUNDRED_MILLION);
}
public static SimpleMoneyFormat getInstance() { 
if (formatter == null)
formatter = new SimpleMoneyFormat();
return formatter;
}
public String format(String moneyStr) { 
checkPrecision(moneyStr);
String result;
result = convertToChineseNumber(moneyStr);
result = addUnitsToChineseMoneyString(result);
return result;
}
public String format(double moneyDouble) { 
return format(numberFormat.format(moneyDouble));
}
public String format(int moneyInt) { 
return format(numberFormat.format(moneyInt));
}
public String format(long moneyLong) { 
return format(numberFormat.format(moneyLong));
}
public String format(Number moneyNum) { 
return format(numberFormat.format(moneyNum));
}
private String convertToChineseNumber(String moneyStr) { 
String result;
StringBuffer cMoneyStringBuffer = new StringBuffer();
for (int i = 0; i < moneyStr.length(); i++) { 
cMoneyStringBuffer.append(chineseNumberMap.get(moneyStr.substring(i, i + 1)));
}
//拾佰仟万亿等都是汉字里面才有的单位，加上它们
int indexOfDot = cMoneyStringBuffer.indexOf(DOT);
int moneyPatternCursor = 1;
for (int i = indexOfDot - 1; i > 0; i--) { 
cMoneyStringBuffer.insert(i, chineseMoneyPattern.get(EMPTY + moneyPatternCursor));
moneyPatternCursor = moneyPatternCursor == 8 ? 1 : moneyPatternCursor + 1;
}
String fractionPart = cMoneyStringBuffer.substring(cMoneyStringBuffer.indexOf("."));
cMoneyStringBuffer.delete(cMoneyStringBuffer.indexOf("."), cMoneyStringBuffer.length());
while (cMoneyStringBuffer.indexOf("零拾") != -1) { 
cMoneyStringBuffer.replace(cMoneyStringBuffer.indexOf("零拾"), cMoneyStringBuffer.indexOf("零拾") + 2, ZERO);
}
while (cMoneyStringBuffer.indexOf("零佰") != -1) { 
cMoneyStringBuffer.replace(cMoneyStringBuffer.indexOf("零佰"), cMoneyStringBuffer.indexOf("零佰") + 2, ZERO);
}
while (cMoneyStringBuffer.indexOf("零仟") != -1) { 
cMoneyStringBuffer.replace(cMoneyStringBuffer.indexOf("零仟"), cMoneyStringBuffer.indexOf("零仟") + 2, ZERO);
}
while (cMoneyStringBuffer.indexOf("零万") != -1) { 
cMoneyStringBuffer.replace(cMoneyStringBuffer.indexOf("零万"), cMoneyStringBuffer.indexOf("零万") + 2, TEN_THOUSAND);
}
while (cMoneyStringBuffer.indexOf("零亿") != -1) { 
cMoneyStringBuffer.replace(cMoneyStringBuffer.indexOf("零亿"), cMoneyStringBuffer.indexOf("零亿") + 2, HUNDRED_MILLION);
}
while (cMoneyStringBuffer.indexOf("零零") != -1) { 
cMoneyStringBuffer.replace(cMoneyStringBuffer.indexOf("零零"), cMoneyStringBuffer.indexOf("零零") + 2, ZERO);
}
if (cMoneyStringBuffer.lastIndexOf(ZERO) == cMoneyStringBuffer.length() - 1)
cMoneyStringBuffer.delete(cMoneyStringBuffer.length() - 1, cMoneyStringBuffer.length());
cMoneyStringBuffer.append(fractionPart);
result = cMoneyStringBuffer.toString();
return result;
}

private String addUnitsToChineseMoneyString(String moneyStr) { 
String result;
StringBuffer cMoneyStringBuffer = new StringBuffer(moneyStr);
int indexOfDot = cMoneyStringBuffer.indexOf(DOT);
cMoneyStringBuffer.replace(indexOfDot, indexOfDot + 1, YUAN);
 Copyright ©2011 lyt. All Rights Reserved.




java核心技术学习
验证

/**
 *格式验证操作
 */
public class CheckUtil {
 
    /**
     * 验证邮箱
     * @param str 要验证的邮箱
     * @return true表示验证成功，false表示失败
     */
    public boolean checkEmail(String str) {
        Pattern pattern = Pattern.compile("([\\w\\.\\-]+@([\\w\\-]+\\.)+[\\w\\-]+)|", Pattern.CASE_INSENSITIVE);
        Matcher matcher = pattern.matcher(str);
        return matcher.matches();
    }
 
    /**
     * 验证手机号
     * @param str 要验证的邮箱
     * @return true表示验证成功，false表示失败
     */
    public boolean checkMobile(String str) {
        Pattern pattern = Pattern.compile("(^[13|15|][\\d]{9})|", Pattern.CASE_INSENSITIVE);
        Matcher matcher = pattern.matcher(str);
        return matcher.matches();
    }
 
    /**
     * 验证固定电话
     * @param str 要验证的电话
     * @return true表示验证成功，false表示失败
     */
    public boolean checkPhone(String str) {
        Pattern pattern = Pattern.compile("([\\d]{7,12})|", Pattern.CASE_INSENSITIVE);
        Matcher matcher = pattern.matcher(str);
        return matcher.matches();
    }
 
    /**
     * 验证QQ号
     * @param str 要验证的QQ
     * @return true表示验证成功，false表示失败
     */
    public boolean checkQq(String str) {
        Pattern pattern = Pattern.compile("([\\d]{6,10})|", Pattern.CASE_INSENSITIVE);
        Matcher matcher = pattern.matcher(str);
        return matcher.matches();
    }
 
    /**
     * 验证用户名
     * @param str 要验证的用户名
     * @return true表示验证成功，false表示失败
     */
    public boolean checkName(String str) {
        Pattern pattern = Pattern.compile("", Pattern.CASE_INSENSITIVE);
        Matcher matcher = pattern.matcher(str);
        return matcher.matches();
    }
        public boolean checkPwd(String str) {
        Pattern pattern = Pattern.compile("[\\w]{6,}", Pattern.CASE_INSENSITIVE);
        Matcher matcher = pattern.matcher(str);
        return matcher.matches();
    }
}
 Copyright ©2011 lyt. All Rights Reserved.




java核心技术学习
java正则

众所周知，在程序开发中，难免会遇到需要匹配、查找、替换、判断字符串的情况发生，而这些情况有时又比较复杂，如果用纯编码方式解决，往往会浪费程序员的时间及精力。因此，学习及使用正则表达式，便成了解决这一矛盾的主要手段。
 大 家都知道，正则表达式是一种可以用于模式匹配和替换的规范，一个正则表达式就是由普通的字符（例如字符a到z）以及特殊字符（元字符）组成的文字模式，它 用以描述在查找文字主体时待匹配的一个或多个字符串。正则表达式作为一个模板，将某个字符模式与所搜索的字符串进行匹配。
  自从jdk1.4推出java.util.regex包，就为我们提供了很好的JAVA正则表达式应用平台。
 
 因为正则表达式是一个很庞杂的体系，所以我仅例举些入门的概念，更多的请参阅相关书籍及自行摸索。
\\ 反斜杠
\t 间隔 ('\u0009')
\n 换行 ('\u000A')
\r 回车 ('\u000D')
\d 数字 等价于[0-9]
\D 非数字 等价于[^0-9]
\s 空白符号 [\t\n\x0B\f\r]
\S 非空白符号 [^\t\n\x0B\f\r]
\w 单独字符 [a-zA-Z_0-9]
\W 非单独字符 [^a-zA-Z_0-9]
\f 换页符
\e Escape
\b 一个单词的边界
\B 一个非单词的边界
\G 前一个匹配的结束
^为限制开头
^java     条件限制为以Java为开头字符
$为限制结尾
java$     条件限制为以java为结尾字符
.  条件限制除\n以外任意一个单独字符
java..     条件限制为java后除换行外任意两个字符

加入特定限制条件「[]」
[a-z]     条件限制在小写a to z范围中一个字符
[A-Z]     条件限制在大写A to Z范围中一个字符
[a-zA-Z] 条件限制在小写a to z或大写A to Z范围中一个字符
[0-9]     条件限制在小写0 to 9范围中一个字符
[0-9a-z] 条件限制在小写0 to 9或a to z范围中一个字符
[0-9[a-z]] 条件限制在小写0 to 9或a to z范围中一个字符(交集)
[]中加入^后加再次限制条件「[^]」
[^a-z]     条件限制在非小写a to z范围中一个字符
[^A-Z]     条件限制在非大写A to Z范围中一个字符
[^a-zA-Z] 条件限制在非小写a to z或大写A to Z范围中一个字符
[^0-9]     条件限制在非小写0 to 9范围中一个字符
[^0-9a-z] 条件限制在非小写0 to 9或a to z范围中一个字符
[^0-9[a-z]] 条件限制在非小写0 to 9或a to z范围中一个字符(交集)
在限制条件为特定字符出现0次以上时，可以使用「*」
J*     0个以上J
.*     0个以上任意字符
J.*D     J与D之间0个以上任意字符
在限制条件为特定字符出现1次以上时，可以使用「+」
J+     1个以上J
.+     1个以上任意字符
J.+D     J与D之间1个以上任意字符
在限制条件为特定字符出现有0或1次以上时，可以使用「?」
JA?     J或者JA出现
限制为连续出现指定次数字符「{a}」
J{2}     JJ
J{3}     JJJ
文字a个以上，并且「{a,}」
J{3,}     JJJ,JJJJ,JJJJJ,???(3次以上J并存)
文字个以上，b个以下「{a,b}」
J{3,5}     JJJ或JJJJ或JJJJJ
两者取一「|」
J|A     J或A
Java|Hello     Java或Hello
 
「()」中规定一个组合类型
比如，我查询<a href=\"index.html\">index</a>中<a href></a>间的数据，可写作<a.*href=\".*\">(.+?)</a>
在使用Pattern.compile函数时，可以加入控制正则表达式的匹配行为的参数：
Pattern Pattern.compile(String regex, int flag)
flag的取值范围如下：
Pattern.CANON_EQ     当且仅当两个字符的"正规分解(canonical decomposition)"都完全相同的情况下，才认定匹配。比如用了这个标志之后，表达式"a\u030A"会匹配"?"。默认情况下，不考虑"规 范相等性(canonical equivalence)"。
Pattern.CASE_INSENSITIVE(?i)     默认情况下，大小写不明感的匹配只适用于US-ASCII字符集。这个标志能让表达式忽略大小写进行匹配。要想对Unicode字符进行大小不明感的匹 配，只要将UNICODE_CASE与这个标志合起来就行了。
Pattern.COMMENTS(?x)     在这种模式下，匹配时会忽略(正则表达式里的)空格字符(译者注：不是指表达式里的"\\s"，而是指表达式里的空格，tab，回车之类)。注释从#开始，一直到这行结束。可以通过嵌入式的标志来启用Unix行模式。
Pattern.DOTALL(?s)     在这种模式下，表达式'.'可以匹配任意字符，包括表示一行的结束符。默认情况下，表达式'.'不匹配行的结束符。
Pattern.MULTILINE
(?m)     在这种模式下，'^'和'$'分别匹配一行的开始和结束。此外，'^'仍然匹配字符串的开始，'$'也匹配字符串的结束。默认情况下，这两个表达式仅仅匹配字符串的开始和结束。
Pattern.UNICODE_CASE
(?u)     在这个模式下，如果你还启用了CASE_INSENSITIVE标志，那么它会对Unicode字符进行大小写不明感的匹配。默认情况下，大小写不敏感的匹配只适用于US-ASCII字符集。
Pattern.UNIX_LINES(?d)     在这个模式下，只有'\n'才被认作一行的中止，并且与'.'，'^'，以及'$'进行匹配。

抛开空泛的概念，下面写出几个简单的Java正则用例：
◆比如，在字符串包含验证时
//查找以Java开头,任意结尾的字符串
  Pattern pattern = Pattern.compile("^Java.*");
  Matcher matcher = pattern.matcher("Java不是人");
  boolean b= matcher.matches();
  //当条件满足时，将返回true，否则返回false
  System.out.println(b);

◆以多条件分割字符串时
Pattern pattern = Pattern.compile("[, |]+");
String[] strs = pattern.split("Java Hello World  Java,Hello,,World|Sun");
for (int i=0;i<strs.length;i++) {
    System.out.println(strs[i]);
}
◆文字替换（首次出现字符）
Pattern pattern = Pattern.compile("正则表达式");
Matcher matcher = pattern.matcher("正则表达式 Hello World,正则表达式 Hello World");
//替换第一个符合正则的数据
System.out.println(matcher.replaceFirst("Java"));
◆文字替换（全部）
Pattern pattern = Pattern.compile("正则表达式");
Matcher matcher = pattern.matcher("正则表达式 Hello World,正则表达式 Hello World");
//替换第一个符合正则的数据
System.out.println(matcher.replaceAll("Java"));

◆文字替换（置换字符）
Pattern pattern = Pattern.compile("正则表达式");
Matcher matcher = pattern.matcher("正则表达式 Hello World,正则表达式 Hello World ");
StringBuffer sbr = new StringBuffer();
while (matcher.find()) {
    matcher.appendReplacement(sbr, "Java");
}
matcher.appendTail(sbr);
System.out.println(sbr.toString());
◆验证是否为邮箱地址
String str="ceponline@yahoo.com.cn";
Pattern pattern = Pattern.compile("[\\w\\.\\-]+@([\\w\\-]+\\.)+[\\w\\-]+",Pattern.CASE_INSENSITIVE);
Matcher matcher = pattern.matcher(str);
System.out.println(matcher.matches());
◆去除html标记
Pattern pattern = Pattern.compile("<.+?>", Pattern.DOTALL);
Matcher matcher = pattern.matcher("<a href=\"index.html\">主页</a>");
String string = matcher.replaceAll("");
System.out.println(string);
◆查找html中对应条件字符串
Pattern pattern = Pattern.compile("href=\"(.+?)\"");
Matcher matcher = pattern.matcher("<a href=\"index.html\">主页</a>");
if(matcher.find())
  System.out.println(matcher.group(1));
}
◆截取http://地址
//截取url
Pattern pattern = Pattern.compile("(http://|https://){1}[\\w\\.\\-/:]+");
Matcher matcher = pattern.matcher("dsdsds<http://dsds//gfgffdfd>fdf");
StringBuffer buffer = new StringBuffer();
while(matcher.find()){              
    buffer.append(matcher.group());        
    buffer.append("\r\n");              
System.out.println(buffer.toString());
}
        
◆替换指定{}中文字
String str = "Java目前的发展史是由{0}年-{1}年";
String[][] object={new String[]{"\\{0\\}","1995"},new String[]{"\\{1\\}","2007"}};
System.out.println(replace(str,object));
public static String replace(final String sourceString,Object[] object) {
            String temp=sourceString;    
            for(int i=0;i<object.length;i++){
                      String[] result=(String[])object[i];
               Pattern    pattern = Pattern.compile(result[0]);
               Matcher matcher = pattern.matcher(temp);
               temp=matcher.replaceAll(result[1]);
            }
            return temp;
}

◆以正则条件查询指定目录下文件
 //用于缓存文件列表
        private ArrayList files = new ArrayList();
        //用于承载文件路径
        private String _path;
        //用于承载未合并的正则公式
        private String _regexp;
        
        class MyFileFilter implements FileFilter {
              /**
               * 匹配文件名称
               */
              public boolean accept(File file) {
                try {
                  Pattern pattern = Pattern.compile(_regexp);
                  Matcher match = pattern.matcher(file.getName());                
                  return match.matches();
                } catch (Exception e) {
                  return true;
                }
              }
            }
        
        /**
         * 解析输入流
         * @param inputs
         */
        FilesAnalyze (String path,String regexp){
            getFileName(path,regexp);
        }
        
        /**
         * 分析文件名并加入files
         * @param input
         */
        private void getFileName(String path,String regexp) {
            //目录
              _path=path;
              _regexp=regexp;
              File directory = new File(_path);
              File[] filesFile = directory.listFiles(new MyFileFilter());
              if (filesFile == null) return;
              for (int j = 0; j < filesFile.length; j++) {
                files.add(filesFile[j]);
              }
              return;
            }
    
        /**
         * 显示输出信息
         * @param out
         */
        public void print (PrintStream out) {
            Iterator elements = files.iterator();
            while (elements.hasNext()) {
                File file=(File) elements.next();
                    out.println(file.getPath());    
            }
        }
        public static void output(String path,String regexp) {
            FilesAnalyze fileGroup1 = new FilesAnalyze(path,regexp);
            fileGroup1.print(System.out);
        }
    
        public static void main (String[] args) {
            output("C:\\","[A-z|.]*");
        }
 Copyright ©2011 lyt. All Rights Reserved.




java核心技术学习
映射

package com.handson.member.util;
import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
public class CommonReflection {
 
 private static String setProperty(String property) {
  return "set" + property.substring(0, 1).toUpperCase()
    + property.substring(1);
 }
 private static String getProperty(String property) {
  return "get" + property.substring(0, 1).toUpperCase()
    + property.substring(1);
 }
 /**
  * @author rfy
  * @param obj1
  * @param obj2
  * 此方法将obj1里的值复制到obj2里，条件是属性名称相同才复制
  */
 public static void copyValue(Object obj1, Object obj2) {
  Field[] fields1 = obj1.getClass().getDeclaredFields();
  Field[] fields2 = obj2.getClass().getDeclaredFields();
  for(int i=0;i<fields1.length;i++){
   for(int j=0;j<fields2.length;j++){
    if(fields2[j].getName().equals(fields1[i].getName())){
     try {
      Method method = obj2.getClass().getMethod(CommonReflection.setProperty(fields2[j].getName()), new Class[]{fields1[i].getType()});
      Object object = obj1.getClass().getMethod(CommonReflection.getProperty(fields1[i].getName()), new Class[]{}).invoke(obj1, new Object[]{});
      method.invoke(obj2, new Object[]{object});
     } catch (SecurityException e) {
      // TODO Auto-generated catch block
      e.printStackTrace();
     } catch (NoSuchMethodException e) {
      // TODO Auto-generated catch block
      e.printStackTrace();
     } catch (IllegalArgumentException e) {
      // TODO Auto-generated catch block
      e.printStackTrace();
     } catch (IllegalAccessException e) {
      // TODO Auto-generated catch block
      e.printStackTrace();
     } catch (InvocationTargetException e) {
      // TODO Auto-generated catch block
      e.printStackTrace();
     }
    }
   }
  }
 }
}
 Copyright ©2011 lyt. All Rights Reserved.




java核心技术学习
水印

/*要求上传的照片都要加上logo,统一打在又下角。但由于照片有暗有亮，因此logo分成了2种，
 * 1种是在比较亮的情况下打的，1种是在比较暗的情况下打的。这可把我害惨了，如何判断明暗度嘛。
 * 奋力Google终于理解，于是写出了实现代码。 由于注释写的比较全，不再进行解释，里面有测试方法，可进行测试。
 * 目标图请做好备份,因为其会直接覆盖目标图 
 */
import java.awt.AlphaComposite;
import java.awt.Graphics2D;
import java.awt.Image;
import java.awt.image.BufferedImage;
import java.awt.image.ColorModel;
import java.awt.image.PixelGrabber;
import java.io.File;
import java.io.FileOutputStream;
import javax.imageio.ImageIO;
import com.sun.image.codec.jpeg.JPEGCodec;
import com.sun.image.codec.jpeg.JPEGImageEncoder;
public class WaterMark {
 // 获取指定矩形中的像素的矩阵
 private int[] getPixArray(Image imageSrc, int startX, int startY, int w,
   int h) {
  int[] pix = new int[(w - startX) * (h - startY)];
  /* 下面是别人程序中的一段,我实在不明白为何要加这一段,因为我去掉也没有问题,加上还会报错 */
  PixelGrabber pg = null;
  try {
   pg = new PixelGrabber(imageSrc, startX, startY, w - startX, h
     - startY, pix, 0, w);
   if (pg.grabPixels() != true) {
    try {
     throw new java.awt.AWTException("pg error" + pg.status());
    } catch (Exception eq) {
     eq.printStackTrace();
    }
   }
  } catch (Exception ex) {
   ex.printStackTrace();
  }
  return pix;
 }
 /**
  * 将1张图片和另1张图片的指定区域重合。可用于制作水印。图片左上角坐标为0，0
  * 
  * @param lightnessWaterImg
  *            颜色比较亮的水印图片，适合底色比较暗的情况
  * @param darknessWaterImg
  *            颜色比较暗的水印图片，适合底色比较亮的情况,如果不想区分，则输入null，平均灰度边界同时失效。
  * @param targetImg
  *            源图片
  * @param alpha
  *            透明度,0f为全透明,1f为完全不透明,0.5f为半透明
  * @param averageGray
  *            平均灰度边界（0-255），大于此值，则打暗的水印图片，小于此值则打亮的水印图片。 默认值128。超过范围，按默认值进行。
  */
 private final void pressImage(String lightnessWaterImg,
   String darknessWaterImg, String targetImg, int startX, int startY,
   int x, int y, float alpha, float averageGray) {
  try {
   // 先判断亮水印和源文件的值是否为null，否则抛出异常
   if (lightnessWaterImg == null || lightnessWaterImg == ""
     || targetImg == null || targetImg == "") {
    throw new Exception("亮水印或者源图片的地址不能为空");
   }
   // 再判断平均灰度边界是否越界
   if (averageGray > 255 || averageGray < 0) {
    averageGray = 128;
   }
   // 装载源图片
   File _file = new File(targetImg);
   // 图片装入内存
   BufferedImage src = ImageIO.read(_file);
   // 获取图片的尺寸
   int width = src.getWidth(null);
   int height = src.getHeight(null);
   // 根据源图片尺寸，设置预装载的一个图片，默认是RGB格式的
   BufferedImage image = new BufferedImage(width, height,
     BufferedImage.TYPE_INT_RGB);
   Graphics2D graphics = image.createGraphics();
   // 绘制内存中的源图片至指定的矩形内
   graphics.drawImage(src, 0, 0, width, height, null);
   // 在已经绘制的图片中加入透明度通道
   graphics.setComposite(AlphaComposite.getInstance(
     AlphaComposite.SRC_ATOP, alpha));
   // 获取源图片中和设定的同样大小的区域内的像素集合
   int[] pixels = getPixArray(src, startX, startY, x, y);
   // 查询此集合的平均灰度
   float average = getAverageGrap(x - startX, y - startY, pixels);
   // 如果平均灰度大于130,则说明此区域比较亮，否则则比较暗
   System.out.println(average);
   // 装载水印图片所需参数
   File water;
   BufferedImage bufferwater;
   // 根据设定的平均灰度边界来装载不同的水印
   if (darknessWaterImg == null || average >= averageGray) {
    // 装载亮水印文件
    water = new File(darknessWaterImg);
   } else {
    // 装载暗水印文件
    water = new File(lightnessWaterImg);
   }
   // 装入内存
   bufferwater = ImageIO.read(water);
   graphics.drawImage(bufferwater, startX, startY, x, y, null);
   // 水印文件结束
   graphics.dispose();
   FileOutputStream out = new FileOutputStream(targetImg);
   JPEGImageEncoder encoder = JPEGCodec.createJPEGEncoder(out);
   // 绘制新的文件
   encoder.encode(image);
   out.close();
  } catch (Exception e) {
   e.printStackTrace();
  }
 }
 // 查询某个区域的平均灰度
 private float getAverageGrap(int width, int height, int[] pixels) {
  /* 下面是开始算这个区域的亮度了，灰度等同于亮度 */
  ColorModel colorModel = ColorModel.getRGBdefault();
  int i = 0, j = 0, k = 0, r = 0, g = 0, b = 0, gray = 0;
  float average = 0;// 平均灰度
  for (i = 0; i < height; i++) {
   for (j = 0; j < width; j++) {
    // 定位像素点
    k = i * width + j;
    r = colorModel.getRed(pixels[k]);
    g = colorModel.getGreen(pixels[k]);
    b = colorModel.getBlue(pixels[k]);
    // 计算灰度值
    gray = (r * 38 + g * 75 + b * 15) >> 7;
    average = average + gray;
   }
  }
  // 计算平均灰度
  average = average / ((i - 1) * (j - 1));
  return average;
 }
 public static void main(String[] args) {
  WaterMark waterMark = new WaterMark();
  int targetImg_width = 900;
  int targetImg_height = 900;
  int start_x = 500;// 打印位置
  int start_y = 400;// 打印位置
  float toumingdu = 0.5f;
  int differGray = 50;// 大则亮
  waterMark.pressImage("E:\\lightnessWaterImg.jpg",
    "E:\\darknessWaterImg.jpg", "E:\\targetImg.jpg", start_x,
    start_y, targetImg_width, targetImg_height, toumingdu,
    differGray);
  System.out.print("添加成功");
 }
}
 Copyright ©2011 lyt. All Rights Reserved.
 
 
 
 
 
java核心技术学习
Java服务器端Socket线程池

import　java.util.Vector; 
import　java.net.*; 
import　java.io.*; 
public　class　ThreadPool　{ 
public　static　final　int　MAX_THREADS　=　100; 
public　static　final　int　MAX_SPARE_THREADS　=　50; 
public　static　final　int　MIN_SPARE_THREADS　=　10; 
public　static　final　int　WORK_WAIT_TIMEOUT　=　60　*　1000; 
protected　Vector　pool;　//存放空闲线程 
protected　MonitorRunnable　monitor;　//A　monitor　thread　that　monitors　the　pool　for　idel　threads. 
protected　int　maxThreads;　//Max　number　of　threads　that　you　can　open　in　the　pool. 
protected　int　minSpareThreads;　//Min　number　of　idel　threads　that　you　can　leave　in　the　pool. 
protected　int　maxSpareThreads;　//Max　number　of　idel　threads　that　you　can　leave　in　the　pool. 
protected　int　currentThreadCount;　//Number　of　threads　in　the　pool. 
protected　int　currentThreadsBusy;　//Number　of　busy　threads　in　the　pool. 
protected　boolean　stopThePool;　//Flag　that　the　pool　should　terminate　all　the　threads　and　stop. 
/** 
*　Construct 
*/ 
public　ThreadPool()　{ 
　　　　maxThreads　=　MAX_THREADS; 
　　　　maxSpareThreads　=　MAX_SPARE_THREADS; 
　　　　minSpareThreads　=　MIN_SPARE_THREADS; 
　　　　currentThreadCount　=　0; 
　　　　currentThreadsBusy　=　0; 
　　　　stopThePool　=　false; 
　　　　} 
/** 
*　启动线程池 
*/ 
public　synchronized　void　start()　{ 
　　　　adjustLimits();　//调整最大和最小线程数及最大和最小多余线程数. 
　　　openThreads(minSpareThreads);　//打开初始线程 
　　　　monitor　=　new　MonitorRunnable(this);　//Runnable对象实例　//A　monitor　thread　that　monitors　the　pool　for　idel　threads. 
　　　　} 
　　　　public　void　setMaxThreads(int　maxThreads)　{ 
　　　　this.maxThreads　=　maxThreads; 
　　　　} 
　　　　public　int　getMaxThreads()　{ 
　　　　return　maxThreads; 
　　　　} 
　　　　public　void　setMinSpareThreads(int　minSpareThreads)　{ 
　　　　this.minSpareThreads　=　minSpareThreads; 
　　　　} 
　　　　public　int　getMinSpareThreads()　{ 
　　　　return　minSpareThreads; 
　　　　} 
　　　　public　void　setMaxSpareThreads(int　maxSpareThreads)　{ 
　　　　this.maxSpareThreads　=　maxSpareThreads; 
　　　　} 
　　　　public　int　getMaxSpareThreads()　{ 
　　　　return　maxSpareThreads; 
　　　　} 
　　　　/** 
　　　　*　线程池管理方法. 
　　　　*　当空闲队列线程中没有空闲线程时,则增加处理(空闲)线程数量. 
　　　　*　如果线程数量已达到最大线程数,则新的连接进行等待. 
　　　　*　当请求到来,且有空闲线程时调用处理线程进行具体业务处理. 
　　　　*　@param　r　ThreadPoolRunnable 
　　　　*/ 
　　　　public　void　runIt(Socket　cs)　{　
       //r　为task　//有任务进入时调用 
　　　　if　(null　==　cs)　{ 
　　　　throw　new　NullPointerException(); 
　　　　} 
　　　　if　(0　==　currentThreadCount　||　stopThePool)　{ 
　　　　throw　new　IllegalStateException(); 
　　　　} 
　　　　ControlRunnable　c　=　null;　//任务处理实例. 
　　　　synchronized　(this)　{ 
　　　　if　(currentThreadsBusy　==　currentThreadCount)　{　
//如果工作线程和当前线程数相等,说明没有空闲线程. 
　　　　if　(currentThreadCount　<　maxThreads)　{　
//如果当前线程数还没有达到最大线程数. 
　　　　int　toOpen　=　currentThreadCount　+　minSpareThreads;　//再增加minSpareThreads个线程量. 
　　　　openThreads(toOpen);　//打开线程新增空闲线程.　//currentThreadCount数量增加 
　　　　} 
　　　　else　{　//如果当前数量达到了最大线程数. 
　　　　while　(currentThreadsBusy　==　curr
　　entThreadCount)　{　//当工作线程和当前线程数相等,说明没有空闲线程. 
　　　　try　{ 
　　　　this.wait();　//连接线程进行等待. 
　　　　} 
　　　　catch　(InterruptedException　e)　{ 
　　　　} 
　　　　if　(0　==　currentThreadCount　||　stopThePool)　{ 
　　　　throw　new　IllegalStateException(); 
　　　　} 
　　　　} 
　　　　} 
　　　　} 
　　　　c　=　(ControlRunnable)　pool.lastElement();　//在有空闲线程的情况下,从空闲线程队列中取出最后一个线程. 
　　　　pool.removeElement(c);　//从空闲队列中删除最后一个线程,用于处理其他事件.
currentThreadsBusy++;　//对处理事件的线程数加1 
　　　　} 
　　　　System.out.println("系统调用一个Sokcet线程"); 
　　　　c.runIt(cs);　//调用具体业务方法,告诉其有数据请求要处理,唤醒等待中的线程. 
　　　　} 
　　　　/** 
　　　　*　关闭线程池 
　　　　*/ 
　　　　public　synchronized　void　shutdown()　{ 
　　　　if　(!stopThePool)　{　//如果线程池没有关闭,(线程池关闭标识为假) 
　　　　stopThePool　=　true;
　　　　monitor.terminate();　//关闭监视线程 
　　　　monitor　=　null; 
　　　　for　(int　i　=　0;　i　<　(currentThreadCount　-　currentThreadsBusy);　i++)　{　//关闭空闲线程队列 
　　　　try　{ 
　　　　(　(ControlRunnable)　(pool.elementAt(i))).terminate(); 
　　　　} 
　　　　catch　(Throwable　t)　{ 
　　　　} 
　　　} 
　　　　currentThreadsBusy　=　currentThreadCount　=　0; 
　　　　pool　=　null; 
　　　　notifyAll();　//唤醒所有在等待的线程. 
　　　　} 
　　　　} 
　　　　/** 
　　　　*　当线程大于最大多余线程时关闭多余的线程. 
　　　　*/ 
　　　　protected　synchronized　void　checkSpareControllers()　{ 
　　　　if　(stopThePool)　{　//如果连接池没有关闭. 
　　　　return; 
　　　　} 
　　　　if　(　(currentThreadCount　-　currentThreadsBusy)　>　maxSpareThreads)　{　//如果空闲的线程数大于多余的最大线程数量. 
　　　　int　toFree　=　currentThreadCount　-　currentThreadsBusy　-　maxSpareThreads;　//得出多余的线程数量
　　　　for　(int　i　=　0;　i　<　toFree;　i++)　{　//关闭删除空闲线程,从Vector中删除 
　　　　ControlRunnable　c　=　(ControlRunnable)　pool.firstElement(); 
　　　　pool.removeElement(c); 
　　　　c.terminate();　//让删除的线程结束 
　　　　currentThreadCount--;　//处理线程队列减少一个 
　　　　} 
　　　　} 
　　　　} 
　　　　/** 
　　　　*　当线程处理完成后重新放到空闲线程队列中. 
　　　　*　@param　c　ControlRunnable 
　　　　*/ 
　　　　protected　synchronized　void　returnController(ControlRunnable　c)　{ 
　　　　if　(0　==　currentThreadCount　||　stopThePool)　{　//如果线程池关闭或当前连接线程数量为0 
　　　　c.terminate();　//关闭当前线程. 
　　　　return; 
　　　　} 
　　　　currentThreadsBusy--;　//处理线程队列的数量减少一个 
　　　　pool.addElement(c);　//空闲线程队列中增加一个 
　　　　notifyAll();　//唤醒可能在等待连接的线程. 
　　　　} 
　　　　/** 
　　　　*　当一个处理线程出现异常时,要重新开启一个空闭线程.,并唤醒在等待空闲线程的线程.ThreadPool的runIt中等待的线程. 
　　　　*/ 
　　　　protected　synchronized　void　notifyThreadEnd()　{ 
　　　　currentThreadsBusy--;　//因从线程是在处理数据时出现异常,所处理线程队列的数量要减一个. 
　　　　currentThreadCount--;　//因出现异常的线程关闭了.所开户线程的数量要减少一个. 
　　　　notifyAll();　//唤醒等待连接的阻塞线程. 
　　　　openThreads(minSpareThreads);　//重新打开minSpareThreads个线程.如currentThreadCount的数量大于minSpareThreads,则还是不开启新线程. 
　　　　} 
　　　　/** 
　　　　*　调整各种线程队列数量 
　　　　*/ 
　　　　protected　void　adjustLimits()　{ 
　　　　if　(maxThreads　<=　0)　{　//如果最大线程数小于0 
　　　　maxThreads　=　MAX_THREADS;　//设置最大线程数为100 
　　　} 
　　　　if　(maxSpareThreads　>=　maxThreads)　{　//如果最大多余线程数大于最大线程数. 
　　　　maxSpareThreads　=　maxThreads;　//设置最大多余线程数为最大线程数. 
　　　　} 
　　　　if　(maxSpareThreads　<=　0)　{　
　　//如果最大多余线程数小于0 
　　　　if　(1　==　maxThreads)　{ 
　　　　maxSpareThreads　=　1;　//如最大线程数为1的情况下,设置最大多余线程数为1. 
　　　　} 
　　　　else　{ 
　　　　maxSpareThreads　=　maxThreads　/　2;　//设置最大多余线程数为最大线程数的一半. 
　　　　} 
　　　　} 
　　　　if　(minSpareThreads　>　maxSpareThreads)　{　//如果最小多余线程大于最大多余线程数 
　　　　minSpareThreads　=　maxSpareThreads;　//设置最小多余线程数为最大多余线程数. 
　　　　} 
　　　　if　(minSpareThreads　<=　0)　{　//如果最小多余线程数小于0 
　　　　if　(1　==　maxSpareThreads)　{ 
　　　　minSpareThreads　=　1;　//如最大线程数为1的情况下,则设置最小多余线程数为1. 
　　　　} 
　　　　else　{ 
　　　　minSpareThreads　=　maxSpareThreads　/　2;　//否则设置最小多余线程数为最大多余线程数的一半. 
　　　　}
} 
　　　　} 
　　　　/** 
　　　　*　打开指定数量的空闲线程队列 
　　　　*　@param　toOpen　int 
　　　　*/ 
　　　　protected　void　openThreads(int　toOpen)　{　//toOpen=minSpareThreads 
　　　　if　(toOpen　>　maxThreads)　{ 
　　　　toOpen　=　maxThreads; 
　　　　} 
　　　　if　(0　==　currentThreadCount)　{　//如果当前线程池中的线程数量为0 
　　　　pool　=　new　Vector(toOpen);　//创建一个有minSpareThreads数量的Vector 
　　　　} 
　　　　//因第二次增加时对第一次增加的线程不能重复增加.所要从currentThreadCount开始. 
　　　　for　(int　i　=　currentThreadCount;　i　<　toOpen;　i++)　{　//先增加minSparethreads数量的线程. 
　　　　pool.addElement(new　ControlRunnable(this));　//Runnable实例对象,可用于创建线程 
　　　　} 
　　　　currentThreadCount　=　toOpen; 
　　　　} 
　　　　/** 
　　　　*　监视线程,用于监听当前空闲线程是否大于最大多余线程数量,如存在则关闭多余的空闲线程. 
　　　　*/ 
　　　　class　MonitorRunnable 
　　　　implements　Runnable　{ 
　　　　ThreadPool　p; 
　　　　Thread　t; 
　　　　boolean　shouldTerminate; 
　　　　/** 
　　　　*　construct 
　　　　*　@param　p　ThreadPool 
　　　　*/ 
　　　　MonitorRunnable(ThreadPool　p)　{ 
　　　　shouldTerminate　=　false; 
　　　　this.p　=　p; 
　　　　t　=　new　Thread(this); 
　　　　t.start(); 
　　　　} 
　　　　public　void　run()　{ 
　　　　while　(true)　{ 
　　　　try　{ 
　　　　synchronized　(this)　{ 
　　　　this.wait(WORK_WAIT_TIMEOUT); 
　　　　} 
　　　　if　(shouldTerminate)　{　//如果结束 
　　　　break; 
　　　　} 
　　　　p.checkSpareControllers();　//检查是否有多余线程. 
　　　　} 
　　　　catch　(Throwable　t)　{ 
　　　　t.printStackTrace(); 
　　　　} 
　　　　} 
　　　　} 
　　　　public　void　stop()　{ 
　　　　this.terminate(); 
　　　　} 
　　　public　synchronized　void　terminate()　{ 
　　　shouldTerminate　=　true; 
　　　　this.notifyAll(); 
　　　　} 
　　　　} 
　　　　}
　　例子2：
　　import java.io.*;
import java.net.*;
public class PooledRemoteFileServer {
//服务器能同时处理的活动客户机连接的最大数目
protected int maxConnections; //进入的连接的侦听端口
protected int listenPort; //将接受客户机连接请求的
ServerSocket protected ServerSocket serverSocket;
public PooledRemoteFileServer(int aListenPort, int maxConnections) {
listenPort= aListenPort;
this.maxConnections = maxConnections;
}
public void acceptConnections() {
try {
 ServerSocket server = new ServerSocket(listenPort, 5);
Socket incomingConnection = null; while(true) {
 incomingConnection = server.accept();
handleConnection(incomingConnection);
}
} catch(BindException e) {
System.out.println("");
} catch(IOException e) {
 System.out.println(""+listenPort);
}
}
/** * 委派PooledConnectionHandler处理连接 */
 protected void handleConnection(Socket connectionToHandle) {
PooledConnectionHandler.processRequest(connectionToHandle);
 }
/** * 创建maxConnections个PooledConnectionHandler并在新Thread中激活它们。
* PooledConnectionHandler将等着处理进入的连接，每个都在它自己的Thread中进行。
*/
public void setUpHandlers() { for(int i=0; i<maxConnections; i++) {
PooledConnectionHandler currentHandler = new PooledConnectionHandler();
new Thread(currentHandler, "Handler " + i).start();
}
} public static void main(String args[]) {
PooledRemoteFileServer server = new PooledRemoteFileServer(1001, 3);
server.setUpHandlers(); server.acceptConnections();
}
} import java.io.*;
import java.net.*;
public class PooledRemoteFileServer {
//服务器能同时处理的活动客户机连接的最大数目
protected int maxConnections;
//进入的连接的侦听端口
protected int listenPort;
 //将接受客户机连接请求的
ServerSocket protected ServerSocket serverSocket;
public PooledRemoteFileServer(int aListenPort, int maxConnections) {
listenPort= aListenPort;
this.maxConnections = maxConnections;
}
 public void acceptConnections() {
 try {
 ServerSocket server = new ServerSocket(listenPort, 5);
Socket incomingConnection = null;
 while(true) {
incomingConnection = server.accept();
handleConnection(incomingConnection);
 }
} catch(BindException e) {
System.out.println("");
} catch(IOException e) {
System.out.println(""+listenPort);
}
}
/** * 委派PooledConnectionHandler处理连接 */
protected void handleConnection(Socket connectionToHandle) {
 PooledConnectionHandler.processRequest(connectionToHandle);
 }
** * 创建maxConnections个PooledConnectionHandler并在新Thread中激活它们。
* PooledConnectionHandler将等着处理进入的连接，每个都在它自己的Thread中进行。
*/
public void setUpHandlers() {
for(int i=0; i<maxConnections; i++) {
PooledConnectionHandler currentHandler = new PooledConnectionHandler();
new Thread(currentHandler, "Handler " + i).start();
}
}
public static void main(String args[]) {
PooledRemoteFileServer server = new PooledRemoteFileServer(1001, 3);
server.setUpHandlers();
server.acceptConnections();
}
}
 
(2)实现线程池的类 
　　Java代码 
　　import java.io.*;
 import java.net.*;
import java.util.*;
public class PooledConnectionHandler implements Runnable {
//connection是当前正在处理的
Socket protected Socket connection;
 //静态 LinkedList 保存需被处理的连接,工作队列
protected static List pool = new LinkedList();
public PooledConnectionHandler() {}
 /** * 将攫取连接的流，使用它们，并在任务完成之后清除它们 */
public void handleConnection() { try {
PrintWriter streamWriter = new PrintWriter(connection.getOutputStream());
BufferedReader streamReader = new BufferedReader(new InputStreamReader(connection.getInputStream()));
String fileToRead = streamReader.readLine();
BufferedReader fileReader = new BufferedReader(new FileReader(fileToRead));
String line = null; while((line=fileReader.readLine())!=null) streamWriter.println(line);
fileReader.close();
streamWriter.close();
streamReader.close();
 } catch(FileNotFoundException e) {
 System.out.println("");
 } catch(IOException e) {
System.out.println(""+e);
}
}
 /**
* 将把传入请求添加到池中，并告诉其它正在等待的对象该池已经有一些内容
* @param requestToHandle
*/
 @SuppressWarnings("unchecked")
public static void processRequest(Socket requestToHandle) {
 //确保没有别人能跟我们同时修改连接池
synchronized(pool) {
//把传入的Socket添加到LinkedList的尾端
pool.add(pool.size(), requestToHandle);
//通知其它正在等待该池的Thread，池现在已经可用
pool.notifyAll();
}
}
 public void run() {
while(true) {
synchronized(pool) {
while(pool.isEmpty()) { try {
//对池上的wait()的调用释放锁，而wait()接着就在自己返回之前再次攫取该锁
pool.wait();//在连接池上等待，并且池中一有连接就处理它
} catch(InterruptedException e) {
e.printStackTrace();
}
}
//恰巧碰上非空池的处理程序将跳出while(pool.isEmpty())循环并攫取池中的第一个连接
connection= (Socket)pool.remove(0);
 }
handleConnection();
}
}
}
import java.io.*;
import java.net.*;
import java.util.*;
public class PooledConnectionHandler implements Runnable {
//connection是当前正在处理的
Socket protected Socket connection;
 //静态 LinkedList 保存需被处理的连接,工作队列
protected static List pool = new LinkedList();
 public PooledConnectionHandler() {}
/** * 将攫取连接的流，使用它们，并在任务完成之后清除它们 */
 public void handleConnection() {
try {
 PrintWriter streamWriter = new PrintWriter(connection.getOutputStream());
BufferedReader streamReader = new BufferedReader(new InputStreamReader(connection.getInputStream()));
String fileToRead = streamReader.readLine();
BufferedReader fileReader = new BufferedReader(new FileReader(fileToRead));
String line = null;
while((line=fileReader.readLine())!=null) streamWriter.println(line);
fileReader.close();
streamWriter.close();
streamReader.close();
 } catch(FileNotFoundException e) {
System.out.println("");
} catch(IOException e) {
System.out.println(""+e);
}
}
/** * 将把传入请求添加到池中，并告诉其它正在等待的对象该池已经有一些内容
* @param requestToHandle
*/
@SuppressWarnings("unchecked")
public static void processRequest(Socket requestToHandle) {
 //确保没有别人能跟我们同时修改连接池
synchronized(pool) {
 //把传入的Socket添加到LinkedList的尾端
pool.add(pool.size(), requestToHandle);
//通知其它正在等待该池的Thread，池现在已经可用 pool.notifyAll();
 }
}
public void run() { while(true) {
synchronized(pool) {
 while(pool.isEmpty()) { try {
//对池上的wait()的调用释放锁，而wait()接着就在自己返回之前再次攫取该锁
pool.wait();//在连接池上等待，并且池中一有连接就处理它
} catch(InterruptedException e) {
e.printStackTrace();
 }
 }
//恰巧碰上非空池的处理程序将跳出while(pool.isEmpty())循环并攫取池中的第一个连接
connection= (Socket)pool.remove(0);
}
handleConnection();
 }
 }
}

　　(3)Client端
Java代码 
　　import java.io.*;
import java.net.*;
/** * 用您想连接的机器的 IP 地址和端口实例化 Socket。
* 获取 Socket 上的流以进行读写。
* 把流包装进 BufferedReader/PrintWriter 的实例，如果这样做能使事情更简单的话。
* 对 Socket 进行读写。
* 关闭打开的流。
* @author Administrator
*/ public class RemoteFileClient {
protected BufferedReader socketReader;
 protected PrintWriter socketWriter;
protected String hostIp;
protected int hostPort;
/** * 构造方法 */
public RemoteFileClient(String hostIp, int hostPort) {
 this.hostIp = hostIp;
this.hostPort=hostPort;
 }
/**
 * 向服务器请求文件的内容,告诉服务器我们想要什么文件并在服务器传回其内容时接收该内容
 */
public String getFile(String fileNameToGet) {
StringBuffer fileLines = new StringBuffer();
try {
socketWriter.println(fileNameToGet);
socketWriter.flush();
 String line = null;
while((line=socketReader.readLine())!=null) fileLines.append(line+"\n");
} catch(IOException e) {
System.out.println("Error reading from file: "+fileNameToGet);
 } return fileLines.toString();
 }
/**
 * 连接到远程服务器,创建我们的 Socket 并让我们访问该套接字的流
 */
public void setUpConnection() {
try { Socket client = new Socket(hostIp,hostPort);
socketReader = new BufferedReader(new InputStreamReader(client.getInputStream()));
socketWriter = new PrintWriter(client.getOutputStream());
} catch(UnknownHostException e) {
System.out.println("Error1 setting up socket connection: unknown host at "+hostIp+":"+hostPort);
} catch(IOException e) {
System.out.println("Error2 setting up socket connection: "+e);
}
}
 /**
* 使用完毕连接后负责“清除”。
 */ public void tearDownConnection() {
try { socketWriter.close();
socketReader.close();
}catch(IOException e) {
System.out.println("Error tearing down socket connection: "+e);
 }
 }
public static void main(String args[]) {
RemoteFileClient remoteFileClient = new RemoteFileClient("127.0.0.1",1001);
remoteFileClient.setUpConnection();
 StringBuffer fileContents = new StringBuffer();
 fileContents.append(remoteFileClient.getFile("D:/test.txt"));
 //remoteFileClient.tearDownConnection();
System.out.println(fileContents);
}
}
 Copyright ©2011 lyt. All Rights Reserved.
 



java核心技术学习
解压文件

//浏览
  public void scanZipFile()
   {  
     // fileCombo.removeAllItems();
      try
      {  
         ZipInputStream zin = new ZipInputStream(new FileInputStream(zipname));
         ZipEntry entry;
         while ((entry = zin.getNextEntry()) != null)
         {  
           // fileCombo.addItem(entry.getName());
            zin.closeEntry();
         }
         zin.close();
      }
      catch (IOException e)
      {  
         e.printStackTrace(); 
      }
   }
 //读取
  public void loadZipFile(String name)
   {  
      try
      {  
         ZipInputStream zin = new ZipInputStream(new FileInputStream(zipname));
         ZipEntry entry;
       //  fileText.setText("");
         // find entry with matching name in archive
         while ((entry = zin.getNextEntry()) != null)
         {  
            if (entry.getName().equals(name))
            {  
               // read entry into text area
               BufferedReader in = new BufferedReader(new InputStreamReader(zin));
               String line;
               while ((line = in.readLine()) != null)
               {
                //  fileText.append(line);
             //     fileText.append("\n");
               }
            }
            zin.closeEntry();
         }
         zin.close();
      }
      catch (IOException e)
      {  
         e.printStackTrace(); 
      }
   }
 Copyright ©2011 lyt. All Rights Reserved.
