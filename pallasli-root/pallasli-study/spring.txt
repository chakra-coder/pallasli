
java核心技术学习
jar包

org.springframework.security:spring-security-taglibs:jar:2.0.4:compile
org.springframework.security:spring-security-core:jar:2.0.4:compile
org.springframework:spring-core:jar:2.0.8:compile
org.springframework:spring-context:jar:2.0.8:compile
aopalliance:aopalliance:jar:1.0:compile
org.springframework:spring-aop:jar:2.0.8:compile
org.springframework:spring-support:jar:2.0.8:runtime
commons-logging:commons-logging:jar:1.1.1:compile
commons-codec:commons-codec:jar:1.3:compile
commons-collections:commons-collections:jar:3.2:compile
org.springframework.security:spring-security-acl:jar:2.0.4:compile
org.springframework:spring-jdbc:jar:2.0.8:compile
org.springframework:spring-dao:jar:2.0.8:compile
org.springframework:spring-web:jar:2.0.8:compile
org.springframework:spring-beans:jar:2.0.8:compile
 Copyright ©2011 lyt. All Rights Reserved.
 
 
 
java核心技术学习
异常

org.springframework.security
AccessDeniedException，当用户无权访问被保护资源时抛出。
AccountExpiredException，当用户过期时抛出。
AccountStatusException，当用户状态不正常时抛出。
AuthenticationCredentialsNotFoundException，当找不到验证凭证时抛出。
AuthenticationException，验证异常。
AuthenticationServiceException，验证服务异常。
AuthorizationServiceException，认证服务异常。
BadCredentialsException，凭证（密码）错误。
CredentialsExpiredException，凭证过期异常。
DisabledException，无效异常。
InsufficientAuthenticationException，不满足验证异常。
LockedException，锁定异常。
SpringSecurityException，安全异常。
org.springframework.security.concurrent
ConcurrentLoginException，同步登陆异常。
SessionAlreadyUsedException，会话已存在异常。
org.springframework.security.config
SecurityConfigurationException，安全配置异常。
org.springframework.security.ldap
LdapDataAccessException，ldap数据访问异常。
org.springframework.security.provider
ProviderNotFoundException，找不到provider异常。
org.springframework.security.provider.rcp
RemoteAuthenticationException，远程认证异常。
org.springframework.security.userdetails
UsernameNotFoundException，找不到用户名异常。
org.springframework.security.userdetails.hierarchicalroles
CycleInRoleHierarchyException，角色循环继承异常。
org.springframework.security.ui.digestauth
NonceExpiredException，nonce过期异常。
org.springframework.security.ui.preauth
PreAuthenticatedCredentialsNotFoundException，未找到预验证凭证异常。
org.springframework.security.ui.rememberme
CookieTheftException，cookie被盗异常
InvalidCookieException，非法cookie异常。
RememberMeAuthenticationException，rememberme验证异常。
 Copyright ©2011 lyt. All Rights Reserved.
 
 
 
 
java核心技术学习
常见问题
Q: 如何获得源代码
A: 在SpringSecurity的发布包中的dist目录下，包含很多“.jar”文件，名称中包含“sources”的文件中就是
源文件了，比如：可以在spring-security-core-2.0.4-sources.jar中找到core模块的所有文件。
Q: 为何登录时出现There is no Action mapped for namespace / and action name j_spring_security_check.
A: 这是因为登陆所发送的请求先被struts2的过滤器拦截了，为了试登陆请求可以被Spring Security正常处
理，需要在web.xml中将Spring Security的过滤器放在struts2之前。
Q: 用户登陆之后没有进入设置的default-target-url页面。
A: Spring Security登陆成功后的策略是，先判断用户登录前是否尝试访问过受保护的页面，如果有，则跳
转到用户登录前访问的受保护页面，否则跳转到default-target-url。如果希望登陆后一直跳转到defaulttarget-
url，可以使用always-use-default-target="true"。
Q: 如何实现国际化。
A: 在xml中添加如下配置：
<beans:bean id="messageSource" class="org.springframework.context.support.ResourceBundleMessageSource">
<beans:property name="basename" value="org/springframework/security/messages" />
</beans:bean>
Q: 如何监听Spring Security的事件日志。
A: 在xml中添加如下配置：
<beans:bean class="org.springframework.security.event.authentication.LoggerListener"/>
<beans:bean class="org.springframework.security.event.authorization.LoggerListener"/>
Q: 如何启用group。
A: 设置enableGroups="true"才能在JdbcDaoImpl中启用group，默认是禁用的，而namespace中没有支持这个
参数，所以想用group时，只好自己配置了。
 Copyright ©2011 lyt. All Rights Reserved.
 
 
 
 
java核心技术学习
md5盐值加密

大多数系统都是用admin作为默认的管理员登陆密码，所以，当我们在数据库中看
到“21232f297a57a5a743894a0e4a801fc3”时，就可以意识到admin用户使用的密码了。因此，md5在处理这
种常用字符串时，并不怎么奏效。
为了解决这个问题，我们可以使用盐值加密“salt-source”。
修改配置文件：
<authentication-provider>
<password-encoder hash="md5">
<salt-source user-property="username"/>
</password-encoder>
<jdbc-user-service data-source-ref="dataSource"/>
</authentication-provider>
在password-encoder下添加了salt-source，并且指定使用username作为盐值。
盐值的原理非常简单，就是先把密码和盐值指定的内容合并在一起，再使用md5对合并后的内容进行演
算，这样一来，就算密码是一个很常见的字符串，再加上用户名，最后算出来的md5值就没那么容易猜出
来了。因为攻击者不知道盐值的值，也很难反算出密码原文。
 Copyright ©2011 lyt. All Rights Reserved.
 
 
 
 
java核心技术学习
过滤器

org.springframework.security.context.HttpSessionContextIntegrationFilter
 位于过滤器顶端，第一个起作用的过滤器。
用途一，在执行其他过滤器之前，率先判断用户的session中是否已经存在一个SecurityContext了。
如果存在，就把SecurityContext拿出来，放到SecurityContextHolder中，供Spring Security的其他部分
使用。如果不存在，就创建一个SecurityContext出来，还是放到SecurityContextHolder中，供Spring
Security的其他部分使用。
用途二，在所有过滤器执行完毕后，清空SecurityContextHolder，因为SecurityContextHolder是基于
ThreadLocal的，如果在操作完成后清空ThreadLocal，会受到服务器的线程池机制的影响。
 org.springframework.security.ui.logout.LogoutFilter
 只处理注销请求，默认为/j_spring_security_logout。
用途是在用户发送注销请求时，销毁用户session，清空SecurityContextHolder，然后重定向到注销成
功页面。可以与rememberMe之类的机制结合，在注销的同时清空用户cookie。
 org.springframework.security.ui.webapp.AuthenticationProcessingFilter
 处理form登陆的过滤器，与form登陆有关的所有操作都是在此进行的。
默认情况下只处理/j_spring_security_check请求，这个请求应该是用户使用form登陆后的提交地址此过滤器执行的基本操作时，通过用户名和密码判断用户是否有效，如果登录成功就跳转到成功
页面（可能是登陆之前访问的受保护页面，也可能是默认的成功页面），如果登录失败，就跳转
到失败页面。
 org.springframework.security.ui.webapp.DefaultLoginPageGeneratingFilter
 此过滤器用来生成一个默认的登录页面，默认的访问地址为/spring_security_login，这个默认的登录
页面虽然支持用户输入用户名，密码，也支持rememberMe功能，但是因为太难看了，只能是在演
示时做个样子，不可能直接用在实际项目中。
 org.springframework.security.ui.basicauth.BasicProcessingFilter
 此过滤器用于进行basic验证，功能与AuthenticationProcessingFilter类似，只是验证的方式不同。有
关basic验证的详细情况，我们会在后面的章节中详细介绍。
 org.springframework.security.wrapper.SecurityContextHolderAwareRequestFilter
此过滤器用来包装客户的请求。目的是在原始请求的基础上，为后续程序提供一些额外的数据。
比如getRemoteUser()时直接返回当前登陆的用户名之类的。
 org.springframework.security.ui.rememberme.RememberMeProcessingFilter
此过滤器实现RememberMe功能，当用户cookie中存在rememberMe的标记，此过滤器会根据标记自
动实现用户登陆，并创建SecurityContext，授予对应的权限。
 org.springframework.security.providers.anonymous.AnonymousProcessingFilter
为了保证操作统一性，当用户没有登陆时，默认为用户分配匿名用户的权限。
 org.springframework.security.ui.ExceptionTranslationFilter
此过滤器的作用是处理中FilterSecurityInterceptor抛出的异常，然后将请求重定向到对应页面，或返
回对应的响应错误代码。
 org.springframework.security.ui.SessionFixationProtectionFilter
防御会话伪造攻击。
 org.springframework.security.intercept.web.FilterSecurityInterceptor
用户的权限控制都包含在这个过滤器中。
功能一：如果用户尚未登陆，则抛出AuthenticationCredentialsNotFoundException“尚未认证异
常”。
功能二：如果用户已登录，但是没有访问当前资源的权限，则抛出AccessDeniedException“拒绝访
问异常”。
功能三：如果用户已登录，也具有访问当前资源的权限，则放行。
 Copyright ©2011 lyt. All Rights Reserved.
 
 
 
 
 
 
 
java核心技术学习
认证事件

AuthenticationFailureConcurrentLoginEvent验证失败，同时登陆。
AuthenticationFailureCredentialsExpiredEvent验证失败，凭证失效。
AuthenticationFailureDisabledEvent验证失败，禁用。
AuthenticationFailureExpiredEvent验证失败，失效。
AuthenticationFailureLockedEvent验证失败，锁定。
AuthenticationFailureProviderNotFoundEvent验证失败，找不到provider。
AuthenticationFailureProxyUntrustedEvent验证失败，不可信任的代理。
AuthenticationFailureServiceExceptionEvent验证失败，服务异常
AuthenticationSuccessEvent认证成功。
AuthenticationSwitchUserEvent切换用户。
InteractiveAuthenticationSuccessEvent内部验证成功。
AuthenticationCredentialsNotFoundEvent找不到凭证。
AuthorizationFailureEvent认证失败。
PublicInvocationEvent公用调用。
 Copyright ©2011 lyt. All Rights Reserved.
 
 
 
 
 
 
 
java核心技术学习
数据库

E.1. User
create table users(
username varchar_ignorecase(50) not null primary key,
password varchar_ignorecase(50) not null,
enabled boolean not null
);
create table authorities (
username varchar_ignorecase(50) not null,
authority varchar_ignorecase(50) not null,
constraint fk_authorities_users foreign key(username) references users(username)
);
create unique index ix_auth_username on authorities (username,authority);

E.2. Group
create table groups (
id bigint generated by default as identity(start with 0) primary key,
group_name varchar_ignorecase(50) not null
);
create table group_authorities (
group_id bigint not null,
authority varchar(50) not null,
constraint fk_group_authorities_group foreign key(group_id) references groups(id)
);
create table group_members (
id bigint generated by default as identity(start with 0) primary key,
username varchar(50) not null,
group_id bigint not null,
constraint fk_group_members_group foreign key(group_id) references groups(id)
);

E.3. RememberMe
create table persistent_logins (
username varchar(64) not null,
series varchar(64) primary key,
token varchar(64) not null,
last_used timestamp not null
);

E.4. ACL
create table acl_sid (
id bigint generated by default as identity(start with 100) not null primary key,
principal boolean not null,
sid varchar_ignorecase(100) not null,
constraint unique_uk_1 unique(sid,principal)
);
create table acl_class (
id bigint generated by default as identity(start with 100) not null primary key,
class varchar_ignorecase(100) not null,
constraint unique_uk_2 unique(class)
);
create table acl_object_identity (
id bigint generated by default as identity(start with 100) not null primary key,
object_id_class bigint not null,
object_id_identity bigint not null,
parent_object bigint,
owner_sid bigint not null,
entries_inheriting boolean not null,
constraint unique_uk_3 unique(object_id_class,object_id_identity),
constraint foreign_fk_1 foreign key(parent_object) references acl_object_identity(id),
constraint foreign_fk_2 foreign key(object_id_class) references acl_class(id),
constraint foreign_fk_3 foreign key(owner_sid) references acl_sid(id)
);
create table acl_entry (
id bigint generated by default as identity(start with 100) not null primary key,
acl_object_identity bigint not null,ace_order int not null,sid bigint not null,
mask integer not null,granting boolean not null,audit_success boolean not null,
audit_failure boolean not null,
constraint unique_uk_4 unique(acl_object_identity,ace_order),
constraint foreign_fk_4 foreign key(acl_object_identity) references acl_object_identity(id),
constraint foreign_fk_5 foreign key(sid) references acl_sid(id)
);
 Copyright ©2011 lyt. All Rights Reserved.
 
 
 
java核心技术学习
spring基础

Spring是为了解决企业应用开发的复杂性而创建的。Spring使用基本的JavaBean来完成以前只可能由EJB完成的事情。然而，Spring的用途不仅限于服务器端的开发。从简单性、可测试性和松耦合的角度而言，任何Java应用都可以从Spring中受益。
　　◆目的：解决企业应用开发的复杂性
　　◆功能：使用基本的JavaBean代替EJB，并提供了更多的企业应用功能
　　◆范围：任何Java应用
　　简单来说，Spring是一个轻量级的控制反转(IoC)和面向切面(AOP)的容器框架。
　　◆轻量——从大小与开销两方面而言Spring都是轻量的。完整的Spring框架可以在一个大小只有1MB多的JAR文件里发布。并且Spring所需的处理开销也是微不足道的。此外，Spring是非侵入式的：典型地，Spring应用中的对象不依赖于Spring的特定类。
　　◆控制反转——Spring通过一种称作控制反转（IoC）的技术促进了松耦合。当应用了IoC，一个对象依赖的其它对象会通过被动的方式传递进来，而不是这个对象自己创建或者查找依赖对象。你可以认为IoC与JNDI相反——不是对象从容器中查找依赖，而是容器在对象初始化时不等对象请求就主动将依赖传递给它。
　　◆面向切面——Spring提供了面向切面编程的丰富支持，允许通过分离应用的业务逻辑与系统级服务（例如审计（auditing）和事务（transaction）管理）进行内聚性的开发。应用对象只实现它们应该做的——完成业务逻辑——仅此而已。它们并不负责（甚至是意识）其它的系统级关注点，例如日志或事务支持。
　　◆容器——Spring包含并管理应用对象的配置和生命周期，在这个意义上它是一种容器，你可以配置你的每个bean如何被创建——基于一个可配置原型（prototype），你的bean可以创建一个单独的实例或者每次需要时都生成一个新的实例——以及它们是如何相互关联的。然而，Spring不应该被混同于传统的重量级的EJB容器，它们经常是庞大与笨重的，难以使用。
　　◆框架——Spring可以将简单的组件配置、组合成为复杂的应用。在Spring中，应用对象被声明式地组合，典型地是在一个XML文件里。Spring也提供了很多基础功能（事务管理、持久化框架集成等等），将应用逻辑的开发留给了你。
　　所有Spring的这些特征使你能够编写更干净、更可管理、并且更易于测试的代码。它们也为Spring中的各种模块提供了基础支持。
起源
　　你可能正在想“Spring不过是另外一个的framework”。当已经有许多开放源代码(和专有) J2EE framework时，我们为什么还需要Spring Framework？
　　Spring是独特的,因为若干个原因:
　　◆它定位的领域是许多其他流行的framework没有的。Spring关注提供一种方法管理你的业务对象。
　　◆ Spring是全面的和模块化的。Spring有分层的体系结构,这意味着你能选择使用它孤立的任何部分,它的架构仍然是内在稳定的。因此从你的学习中，你可得到最大的价值。例如,你可能选择仅仅使用Spring来简单化JDBC的使用,或用来管理所有的业务对象。
　　◆它的设计从底部帮助你编写易于测试的代码。Spring是用于测试驱动工程的理想的framework。
　　Spring对你的工程来说，它不需要一个以上的framework。Spring是潜在地一站式解决方案，定位于与典型应用相关的大部分基础结构。它也涉及到其他framework没有考虑到的内容。
特点
　　◆方便解耦，简化开发
　　通过Spring提供的IoC容器，我们可以将对象之间的依赖关系交由Spring进行控制，避免硬编码所造成的过度程序耦合。有了Spring，用户不必再为单实例模式类、属性文件解析等这些很底层的需求编写代码，可以更专注于上层的应用。
　　◆AOP编程的支持
　　通过Spring提供的AOP功能，方便进行面向切面的编程，许多不容易用传统OOP实现的功能可以通过AOP轻松应付。
　　◆声明式事务的支持
　　在Spring中，我们可以从单调烦闷的事务管理代码中解脱出来，通过声明式方式灵活地进行事务的管理，提高开发效率和质量。
　　◆方便程序的测试
　　可以用非容器依赖的编程方式进行几乎所有的测试工作，在Spring里，测试不再是昂贵的操作，而是随手可做的事情。
　　◆方便集成各种优秀框架
　　Spring不排斥各种优秀的开源框架，相反，Spring可以降低各种框架的使用难度，Spring提供了对各种优秀框架（如Struts,Hibernate、Hession、Quartz）等的直接支持。
　　◆降低Java EE API的使用难度
　　Spring对很多难用的Java EE API（如JDBC，JavaMail，远程调用等）提供了一个薄薄的封装层，通过Spring的简易封装，这些Java EE API的使用难度大为降低。
　　◆Java 源码是经典学习范例
　　Spring的源码设计精妙、结构清晰、匠心独用，处处体现着大师对Java设计模式灵活运用以及对Java技术的高深造诣。Spring框架源码无疑是Java技术的最佳实践范例。如果想在短时间内迅速提高自己的Java技术水平和应用开发水平，学习和研究Spring源码将会使你收到意想不到的效果。
好处
　　在我们进入细节以前，让我们看一下Spring可以给一个工程带来的一些好处:
　　◆Spring能有效地组织你的中间层对象,无论你是否选择使用了EJB。如果你仅仅使用了Struts或其他的包含了J2EE特有APIs的framework，你会发现Spring关注了遗留下的问题。
　　◆Spring能消除在许多工程上对Singleton的过多使用。根据我的经验，这是一个主要的问题，它减少了系统的可测试性和面向对象特性。
　　◆Spring能消除使用各种各样格式的属性定制文件的需要,在整个应用和工程中，可通过一种一致的方法来进行配置。曾经感到迷惑，一个特定类要查找迷幻般的属性关键字或系统属性,为此不得不读Javadoc乃至源编码吗？有了Spring，你可很简单地看到类的JavaBean属性。倒置控制的使用(在下面讨论)帮助完成这种简化。
　　◆Spring能通过接口而不是类促进好的编程习惯，减少编程代价到几乎为零。
　　◆Spring被设计为让使用它创建的应用尽可能少的依赖于他的APIs。在Spring应用中的大多数业务对象没有依赖于Spring。
　　◆使用Spring构建的应用程序易于单元测试。
　　◆Spring能使EJB的使用成为一个实现选择,而不是应用架构的必然选择。你能选择用POJOs或local EJBs来实现业务接口，却不会影响调用代码。
　　◆Spring帮助你解决许多问题而无需使用EJB。Spring能提供一种EJB的替换物，它们适于许多web应用。例如,Spring能使用AOP提供声明性事务而不通过使用EJB容器，如果你仅仅需要与单个的数据库打交道，甚至不需要JTA实现。
　　■Spring为数据存取提供了一致的框架,不论是使用JDBC或O/R mapping产品（如Hibernate）。
　　Spring确实使你能通过最简单可行的解决办法解决你的问题。这些特性是有很大价值的。
　　总结起来，Spring有如下优点：
　　◆低侵入式设计，代码污染极低
　　◆ 独立于各种应用服务器，可以真正实现Write Once,Run Anywhere的承诺
　　◆Spring的DI机制降低了业务对象替换的复杂性
　　◆Spring并不完全依赖于Spring，开发者可自由选用Spring框架的部分或全部
作用
　　Spring提供许多功能,在此我将快速地依次展示其各个主要方面。
　　首先,让我们明确Spring范围。尽管Spring覆盖了许多方面，但我们已经有清楚的概念，它什么应该涉及和什么不应该涉及。
　　Spring的主要目的是使J2EE易用和促进好编程习惯。
　　Spring不重新开发已有的东西。因此，在Spring中你将发现没有日志记录的包,没有连接池,没有分布事务调度。这些均有开源项目提供(例如Commons Logging 用来做所有的日志输出，或Commons DBCP用来作数据连接池),或由你的应用程序服务器提供。因为同样的的原因，我们没有提供O/R mapping层，对此，已有有好的解决办法如Hibernate和JDO。
Spring的目标是使已存在的技术更加易用。
　　例如,尽管我们没有底层事务协调处理，但我们提供了一个抽象层覆盖了JTA或任何其他的事务策略。
　　Spring没有直接和其他的开源项目竞争，除非我们感到我们能提供新的一些东西。例如，象许多开发人员，我们从来没有为Struts高兴过，并且感到在MVC web framework中还有改进的余地。在某些领域，例如轻量级的IoC容器和AOP框架，Spring有直接的竞争，但是在这些领域还没有已经较为流行的解决方案。(Spring在这些区域是开路先锋。)
　　Spring也得益于内在的一致性。
　　所有的开发者都在唱同样的的赞歌,基础想法依然是Expert One-on-One J2EE设计与开发的那些。
　　并且我们已经能够使用一些主要的概念,例如倒置控制，来处理多个领域。
　　Spring在应用服务器之间是可移植的。
　　当然保证可移植性总是一次挑战，但是我们避免任何特定平台或非标准化,并且支持在WebLogic，Tomcat，Resin，JBoss，WebSphere和其他的应用服务器上的用户。
下载和安装
　　下载和安装Spring请按如下步骤进行。
　　（1）登录站点，下载Spring的最新稳定版本。最新版本为Spring Framework 2.5.5.建议下载spring-framework-2.5.5-with-dependencies.zip这个压缩包不仅包含Spring的开发包，而且包含Spring编译和运行所依赖的第三方类库。
　　解压缩下载到的压缩包，解压缩后的文件夹应用如下几个文件夹。
　　◆dist:该文件夹下放Spring的jar包，通常只需要Spring.jar文件即可。该文件夹下还有一些类似spring－Xxx.jar的压缩包， 这些压缩包是spring.jar压缩包的子模块压缩包。除非确定整个J2EE应用只需要使用Spring的某一方面时，才考虑使用这中分模块压缩包。通常建议使用Spring.jar
　　◆docs:该文件夹下包含spring的相关文档、开发指南及API参考文档。
　　◆lib:该文件夹下包含spring编译和运行所依赖的第三方类库，该路径下的类库并不是spring必需的，但如果需要使用第三方类库的支持，这里的类库就是必需要的。
　　◆samples:该文件夹下包含Spring的几个简单例子，可作为Spring入门学习的案例。
　　◆src:该文件夹下包含Spring的全部源文件，如果开发过程中有地方无法把握，可以参考该源文件，了解底层实现。
◆test:该文件夹下包含Spring的测试示例。
　　◆tiger:该路径下存放关于JDK的相关内容
　　◆解压缩后的文件夹下，还包含一些关于Spring的License和项目相关文件
　　（2）将spring.jar复制到项目的CLASSPATH路径下，对于Web应用，将spring.jar文件复制到WEB-INF/lib路径下，该应用即可以利用Spring框架了。
　　（3）通常Spring的框架还依赖于其他一些jar文件，因此还须将lib下对应的包复制到WEB-INF/lib路径下，具体要复制哪些jar文件，取决于应用所需要使用的项目。通常需要复制cglib，dom4j，jakarta-commons，log4j等文件夹下的jar文件。
　　（4）为了编译java文件，可以找到Spring的基础类，将Spring.jar文件的路径添加到环境变量CLASSPATH中。当然，也可以使用ANT工具，但无须添加环境变量。如果使用Eclipse或者NetBeans等IDE时，也不需要设置环境变量。
主要产品
　　* Spring Framework
　　* Spring Web Flow
　　* Spring Web Services
　　* Spring Security (Acegi Security)
　　* Spring Dynamic Modules For OSGi(tm) Service Platforms
　　* Spring Batch
　　* Spring Integration
　　* Spring LDAP
* Spring IDE
　　* Spring Modules
　　* Spring JavaConfig
　　* Spring Rich Client
　　* Spring .NET
　　* Spring BeanDoc
Spring .NET
　　Spring 并不是Java所特有的，它也应用于.NET平台。而且得到了很好的发展！
研究源代码的步骤
1 Spring中的事务处理[1]
　　2 ioc容器在Web容器中的启动[2]
　　3 Spring JDBC[3]
　　4 Spring MVC[4]
　　5 Spring AOP获取Proxy[5]
　　6 Spring声明式事务处理[6]
　　7 Spring AOP中对拦截器调用的实现[7]
　　8 Spring驱动Hibernate的实现[8]
　　9 Spring Acegi框架鉴权的实现[9]
　　10 Spring Acegi框架授权的实现[10]
 Copyright ©2011 lyt. All Rights Reserved.
 
 
 
java核心技术学习
spring2.0新特性

一. 控制反转(IoC)容器
Spring 2.0 相当大的改进之一就是Spring的IoC容器。
1. 更简单的XML配置
多亏了新的基于XML Schema的XML配置语法的产生，Spring的XML配置变的更加简单了。如果你想充分利用Spring提供的新标签（Spring团队当然建议你这么做，因为他们使配置变的不再繁琐，更加易于阅读），请阅读标题为 附录 A, XML Schema-based configuration 的部分。
相关提示，请引用新的Spring 2.0 DTD以使用基于XML Schema的配置。下面给出了DOCTYPE声明，如果有兴趣的读者可以详细阅读Spring 2.0发布包的 'dist/resources'目录中的'spring-beans-2.0.dtd' DTD。
<!DOCTYPE beans PUBLIC "-//SPRING//DTD BEAN 2.0//EN" "http://www.springframework.org/dtd/spring-beans-2.0.dtd">
2. 新的bean作用域
Spring上个版本的IoC容器支持两个不同的bean作用域（单例与原型）。Spring 2.0改进了这一点，不仅提供了一些依赖于Spring部署环境（比如说，在web环境中的request和session作用域bean）的额外的作用域,而且提供了所谓的'钩子'（'hooks'）（因为找不到更好的表达）使Spring用户可以创造自己的作用域。
应该注意的是，即使单例与原型作用域beans的基本（内在）实现发生了变化，上述变化对最终用户来说是透明的...现有的配置不需要改变或放弃。
在标题为 第 3.4 节 “bean的作用域” 的部分有对新增的作用域与原有作用域的详细描述。
3. 可扩展的XML编写
XML配置不仅更加易于书写，而且也具有可扩展性。
这里'可扩展性'的含义是，作为一个应用程序开发人员，或着（更可能）作为第三方框架或产品的供应商，可以开发自定义标签，供其他开发人员把这些标签嵌入到自己的Spring配置文件里。你可以在组件的特定配置中定义你自己的DSL（domain specific language，这个词在这里用得比较宽泛）。
对于个别应用的开发人员或者在项目中运用Spring的企业架构师来说，实现自定义Spring标签可能不是他们的兴趣所在。我们期待着第三方供应商能够对开发在Spring配置文件里使用的自定义配置标签予于足够的关注。
可扩展的配置机制在 附录 B, Extensible XML authoring 里有更充分的描述。
二. 面向切面编程(AOP)
Spring 2.0在AOP上有很大的改进。Spring AOP框架本身就十分易于用XML配置，不再那么繁琐；Spring 2.0集成了AspectJ 切入点（pointcut）语言和 @AspectJ 切面（aspect）声明类型。 标题为 第 6 章 使用Spring进行面向切面编程（AOP） 的部分专门描述这个新支持。
1. 更加简单的AOP XML配置
Spring 2.0引入了新的模式，支持定义从常规Java对象中发展中来的切面。 此支持充分利用了AspectJ切入点语言，提供了完整类型的通知（advice）（也就是没有多余转换和 Object[] 参数操作）。 标题为 第 6.3 节 “Schema-based AOP support” 的部分详细描述了该支持的细节。
2. 对@AspectJ 切面的支持
Spring 2.0也支持使用@AspectJ注解定义的切面。这些切面可以在AspectJ与Spring AOP中共享，仅仅需要（老实说!）一些简单的配置。 在标题为 第 6.2 节 “@AspectJ支持” 的部分讨论了对@AspectJ切面的支持。
三. 中间层
1. 在XML里更为简单的声明性事务配置
Spring 2.0关于事务的配置方式发生了重大的变化。早先的1.2.x版本的配置方式仍然有效（并且受支持），但是新的方式明显更加简洁，并成为最推荐的方式。 Spring 2.0 同时提供了AspectJ切面库，你可以使用它来生成更漂亮的事务性对象 - 甚至可以不是由Spring IoC容器产生的。
标题为 第 9 章 事务管理 的部分包含所有的细节。
2. JPA
Spring 2.0提供了JPA抽象层，在所起的作用与常规使用模式上，类似于Spring的JDBC抽象层。
如果你对使用实现JPA作为自己持久层的基础感兴趣，标题为 第 12.6 节 “JPA” 的部分专门描述了在这个领域Spring的支持与附加值。
3. 异步的JMS
在Spring 2.0之前，Spring的JMS的作用局限于发送消息和同步接收消息。 这个功能（封装在 JmsTemplate 类中）当然是很好的， 但是，它没有满足异步消息接收的需要。
Spring 2.0现在提供对异步消息接收的完整支持。在标题为 第 19.4.2 节 “异步接收 - 消息驱动的POJOs” 的部分有详细的描述。
4. JDBC
在Spring的JDBC支持库中，有几个小的(但同样值得注意的)新类。首先，NamedParameterJdbcTemplate， 提供了在编写JDBC语句时，对使用命名参数（与之相对的是编写JDBC语句时只使用常规的占位符（'?'））的支持。
另一个新类，SimpleJdbcTemplate， 致力于在使用Java 5+ (Tiger)开发时更加简单地使用JdbcTemplate。
四. Web层
在Spring 2.0里，web层支持得到了 充分地 改进和扩展。
1. Spring MVC的表单标签库
Spring MVC丰富的JSP标签库 来自 JIRA，其中的绝大部分是Spring用户（范围很广的用户）通过投票方式产生的。
Spring 2.0拥有一个丰富的JSP标签库，在使用Spring MVC时，编写JSP页面变得更加简单；Spring团队自信地认为它将满足所有在JIRA上投票的开发人员的需要。在标题为 第 13.9 节 “使用Spring的表单标签库” 的部分描述了新的标签库，标题为 附录 E, spring-form.tld 的附录部分是对所有新标签的快速指南。
2. Spring MVC合理的默认值
对于很多项目而言，遵守建立好的规范，使用合理的默认值，是项目所必须的... 现在在SpringMVC里，惯例优先（convention-over-configuration）的观点有了明确的支持。 这就意味着当你为控制器和视图建立一系列的命名规范时，你可以 充分 减少XML配置的数量，包括设置处理映射、视图解析、ModelAndView的实例等等。 对于开发快速原型来说，这有非常大的优势，并且越过代码库可以产生一定的连续性（通常是良好的）。
在标题为 第 13.11 节 “惯例优先原则(convention over configuration)” 的部分，可以发现对Spring MVC的惯例优先支持的详细内容。
3. Portlet 框架
Spring 2.0 设计了一种概念上类似于Spring MVC框架的Porlet框架。标题为 第 16 章 Portlet MVC框架 的部分可以找到详细的介绍。
五. 其他特性
最后部分罗列了所有其他关于Spring 2.0的新特性与改进特性。
1. 动态语言支持
Spring 2.0现在支持用非Java语言编写的bean，当前支持的动态语言包括JRuby，Groovy和BeanShell。标题为 第 24 章 动态语言支持 部分描述了动态语言支持的细节。
2. JMX
Spring Framework开始支持通知(Notification)； 还可以声明式地控制MBean在一个MBeanServer上的注册行为。
第 20.7 节 “通知”
第 20.2.5 节 “控制注册行为”
3. 任务规划
关于任务规划，Spring 2.0 提供了一种抽象。对于感兴趣的开发人员，标题为 第 23.4 节 “SpringTaskExecutor抽象” 的部分提供了所有的细节。
4. 对Java 5（Tiger）的支持
如果你有幸使用Java 5（Tiger）进行项目开发，你将很高兴地发现，Spring 2.0对于Tiger有一些非常引人注目的支持。下面是一系列Spring Java 5 独有特性的指南
六. 移植到Spring 2.0
最后一节中详细说明了从Spring 1.2.x移植到Spring 2.0的过程中可能出现的问题。
先让我们来有所保留地看看下面这句话, 从Spring 1.2移植到Spring 2.0应该就是简单地把Spring 2.0的jar文件放进应用程序目录中的合适位置。
上一句话的关键字理所当然是“应该”。 到底是不是无缝升级依赖于你的代码中究竟用了多少Spring API。 Spring 2.0移除了很多在Spring 1.2.x代码库中标为deprecated的代码，所以如果你用了这些类或方法， 你应该使用它们的替代类或方法(下面总结了些)。
关于配置，Spring 1.2.x风格的XML配置与Spring 2.0完全兼容。你仍然可以继续使用Spring 1.2.x DTD， 不过这样你就不能充分利用一些Spring 2.0的新功能(例如作用域、 更易用的AOP 和 事务配置)， 但绝对不会有问题。
建议的移植策略是放入Spring 2.0的jar文件以便能使用改进过的代码(修正bug、优化等等)。 然后增量地开始尝试Spring 2.0的新特性和配置。例如，你可以选择先在切面配置上运用Spring 2.0风格作为开始； 90%的旧式Spring 1.2.x配置(引用1.2.x DTD)加上10%的Spring 2.0配置(引用2.0 DTD和XSD)是完全有效的。要记住， 在使用Spring 2.0库的同时并非一定要升级XML配置。
 一些变化如需了解全部变化，请参考Spring Framework 2.0发布包顶层目录里的'changelog.txt'文件。
1. Jar包
1.2.x和2.0的Spring Framework jar文件有很多不同之处。 特别是现在JDO、Hibernate 2/3、TopLink的ORM集成类有专门的jar文件：它们不再被打包在核心文件 'spring.jar'中了。
2. XML配置
Spring 2.0的XSD在描述Spring XML元数据格式方面比先前的DTD更丰富。 旧的DTD仍然得到支持，但如果可能我们鼓励在bean定义文件头部引用XSD文件。
有一点被改变了，那就是定义bean作用域的方式。如果你使用的是Spring 1.2 DTD，那么你能继续用'singleton'属性。 如果你选择引用新的Spring 2.0 DTD，它不允许使用'singleton'属性， 那么可以用'scope'属性来定义bean的生命周期作用域。
3. Deprecated的类和方法
一些以前被标记为@deprecated的类和方法Spring 2.0代码库中被完全删除了。 Spring团队决定把2.0版本作为一个新的开始，那些被deprecated的代码应该被除去而不是在可预见的未来继续在代码中出现。
就如前面所说的，如需了解全部变化，请参考Spring Framework 2.0发布包顶层目录里的'changelog.txt'文件。
下面的类/接口已经从Spring 2.0的代码中删除了。
ResultReader : 使用RowMapper接口代替。
BeanReferenceFactoryBean : 使用别名机制代替
BeanDefinitionRegistryBuilder : 使用BeanDefinitionReaderUtils类上的方法代替
BeanFactoryBootstrap : 考虑使用一个BeanFactoryLocator 或是自定义引导类代替
RequestUtils : 使用ServletRequestUtils代替
4. Apache OJB
请注意Spring主代码中的Apache OJB支持被完全删除了； 但仍然可以在Spring Modules项目中找到Apache OJB的集成库。
5. iBatis
请注意iBATIS SQL Maps 1.3支持被完全去除了。如果你还在使用iBATIS SQL Maps 1.3， 请升级到iBATIS SQL Maps 2.0/2.1。
七. 更新的样例应用
我们同样更新了一些样例应用以反映Spring 2.0的新特性与改进特性，请抽出时间仔细研究。 上述样例放在Spring完整发行版里的'samples'路径下 （'spring-with-dependecies.[zip|tar.gz]'）。
上述发行版同时提供了一些所谓的体现特性优势的应用。每个应用都提供了完整的例子，一次演示一个Spring 2.0的新特性。 这意味着你可以在这些应用中运行代码，而不需再自己创建小工程测试Spring 2.0的新特性。我们故意将这些应用的作用域设定的很小； 作用域模型（如果有的话）可能只有一两个类，而典型的企业关注点，如安全和事务完整性，显然没有包含在内。
 Copyright ©2011 lyt. All Rights Reserved.
 
 
 
java核心技术学习
IOC/DI概念

  热门词汇：  控制反转(Inversion of Control,IoC)与依赖注入(Dependency Injection)。
  由容器来管理对象之间的依赖关系(而不是对象本身来管理)，就叫“控制反转”或“依赖注入”。
Spring框架的基本思想就是IOC/DI。
  Spring就是一个IOC容器。
IOC与DI说的是一回事，但DI这个名词更能表达这种设计模式的思想
 public class ReflectUtil {
 public static Object getInstance(String className) {
  Object object = null;
  try {
   Class objClass = Class.forName(className);
   object = objClass.newInstance();
  } catch (Exception ex) {
   ex.printStackTrace();
  }
  return object;
 }
 public static Object getInstancOther(String className) {
  Object object = null;
  try {
   ClassLoader loader = Thread.currentThread().getContextClassLoader();
   Class objClass = loader.loadClass(className);
   object = objClass.newInstance();
  } catch (Exception ex) {
   ex.printStackTrace();
  }
  return object;
 }
 public static Object getField(Object obj, String fieldName) {
  Object object = null;
  try {
   Class objClass = obj.getClass();
   java.lang.reflect.Field field = objClass
     .getDeclaredField(fieldName);
   field.setAccessible(true);
   object = field.get(obj);
  } catch (Exception ex) {
   ex.printStackTrace();
  }
  return object;
 }
 public static void setField(Object obj, String fieldName, Object value) {
  try {
   Class objClass = obj.getClass();
   java.lang.reflect.Field field = objClass
     .getDeclaredField(fieldName);
   field.setAccessible(true);
   field.set(obj, value);
  } catch (Exception ex) {
   ex.printStackTrace();
  }
 }
 public static Object invoke(Object obj, String methodName, Object[] objs) {
  Object object = null;
  try {
   Class[] params = new Class[objs.length];
   for (int i = 0; i < params.length; i++) {
    params[i] = objs[i].getClass();
   }
   java.lang.reflect.Method method = obj.getClass().getDeclaredMethod(
     methodName, params);
   method.setAccessible(true);
   object = method.invoke(obj, objs);
  } catch (Exception ex) {
   ex.printStackTrace();
  }
  return object;
 }
 public static void main(String[] args) {
  com.pojo.Person person = (com.pojo.Person) ReflectUtil
    .getInstancOther("com.pojo.Person");
  ReflectUtil.setField(person, "name", "scott");
  System.out.println(ReflectUtil.getField(person, "name"));
  System.out.println(ReflectUtil.invoke(person, "showAge",
    new Object[] { "scott" }));
  String[] strs = new String[5];
  strs = (String[]) java.lang.reflect.Array.newInstance(strs.getClass()
    .getComponentType(), 10);
  System.out.println(strs.length);
 }
}
 Copyright ©2011 lyt. All Rights Reserved.
 
 
 
java核心技术学习
spring属性注入

什么是属性编辑器，作用？
   * 自定义属性编辑器，spring配置文件中的字符串转换成相应的对象进行注入
   spring已经有内置的属性编辑器，我们可以根据需求自己定义属性编辑器
  
   * 如何定义属性编辑器？
      * 继承PropertyEditorSupport类，覆写setAsText（）方法，参见UtilDatePropertyEditor.java
      * 将属性编辑器注册到spring中，参见：applicationContext-editor.xml
     
依赖对象的注入方式，可以采用：
   * ref 属性
   * <ref>标签
   * 内部<bean>来定义
  
如何将公共的注入定义描述出来？
   * 通过<bean>标签来定义公共的属性，指定abstract="true"
   * 具有相同属性的类在<bean>标签中指定其parent属性
 Copyright ©2011 lyt. All Rights Reserved.
 
 
 
java核心技术学习
IOC实现步骤

1、spring 依赖库
    * SPRING_HOME/dist/spring.jar  spring的框架包
    * SPRING_HOME/lib/jakarta-commons/commons-logging.jar   自动选择不同的实现，配置log4j就选log4j
    * SPRING_HOME/lib/log4j/log4j-1.2.14.jar   日志输出
   
A.     创建User Libraries
1.        创建包名
1-1.    进入WindowàPreferencesàJavaàBuild PathàUser LibrariesàNewà在User library name:中输入包名，如：spring,点击OK.
 
2.        添加jar包
1-1.    选中springà点击Add JARs…à找到spring的源代码包，把相应的jar包加入
 
 
B.     在工程中，引入User Libraries
1.        选中工程，引入user libraries
1-1.    选中工程à(右键)à点击Propertiesà点击Java Build Pathà选中LibrariesàAdd Library…à选择User LibraryàNextà在Selected User Library中，选择要加入的library名称àFinishàOK.
2、拷贝spring配置文件到src下， applicationContext.xml
 
3、拷贝log4j配置文件到src下， log4j.properties
   
4、在UserManager中提供构造函数或setter方法，spring将实例化好的userDao实现注入给我们
 
5、让spring管理我们的对象创建和依赖，必须在spring配置文件中进行定义   
 
6、编写客户端
 
spring Ioc容器的关键点：
    * 必须将被管理的对象定义到spring配置文件中
    * 必须定义构造函数或setter方法，让spring将对象注入过来
 Copyright ©2011 lyt. All Rights Reserved.
 
 
java核心技术学习
加载多个配置文件


ApplicationContext context = new ClassPathXmlApplicationContext(
        new String[] {"applicationContext.xml", "applicationContext-part2.xml"});
// of course, an ApplicationContext is just a BeanFactory
BeanFactory factory = (BeanFactory) context;
3.2.2.1. 组成基于XML配置元数据
将XML配置文件分拆成多个部分是非常有用的。为了加载多个XML文件生成一个ApplicationContext实例，可以将文件路径作为字符串数组传给ApplicationContext构造器。而bean factory将通过调用bean defintion reader从多个文件中读取bean定义。
通常情况下，Spring团队倾向于上述做法，因为这样各个配置并不会查觉到它们与其他配置文件的组合。另外一种方法是使用一个或多个的<import/>元素来从另外一个或多个文件加载bean定义。所有的<import/>元素必须放在<bean/>元素之前以完成bean定义的导入。 让我们看个例子：
<beans><import resource="services.xml"/>
    <import resource="resources/messageSource.xml"/>
    <import resource="/resources/themeSource.xml"/>
      <bean id="bean1" class="..."/>
    <bean id="bean2" class="..."/>
  </beans>
在上面的例子中，我们从3个外部文件：services.xml、messageSource.xml及themeSource.xml来加载bean定义。这里采用的都是相对路径，因此，此例中的services.xml一定要与导入文件放在同一目录或类路径，而messageSource.xml和themeSource.xml的文件位置必须放在导入文件所在目录下的resources目录中。正如你所看到的那样，开头的斜杠‘/’实际上可忽略。因此不用斜杠‘/’可能会更好一点。
根据Spring XML配置文件的Schema(或DTD)，被导入文件必须是完全有效的XML bean定义文件，且根节点必须为<beans/> 元素。
 Copyright ©2011 lyt. All Rights Reserved.
 
 
 
java核心技术学习
注解

Spring注解入门
1. 使用Spring注解来注入属性 
1.1. 使用注解以前我们是怎样注入属性的 
类的实现：
Java代码
public class UserManagerImpl implements UserManager {  
    private UserDao userDao;  
   public void setUserDao(UserDao userDao) {  
        this.userDao = userDao;  
   }  
    ...  
}  

配置文件：
Java代码
<bean id="userManagerImpl" class="com.kedacom.spring.annotation.service.UserManagerImpl">  
    <property name="userDao" ref="userDao" />  
</bean>  
<bean id="userDao" class="com.kedacom.spring.annotation.persistence.UserDaoImpl">  
    <property name="sessionFactory" ref="mySessionFactory" />  
</bean>  


1.2. 引入@Autowired注解（不推荐使用，建议使用@Resource） 
类的实现（对成员变量进行标注）
Java代码
public class UserManagerImpl implements UserManager {  
    @Autowired  
    private UserDao userDao;  
    ...  
}  

或者（对方法进行标注）
Java代码
public class UserManagerImpl implements UserManager {  
    private UserDao userDao;  
    @Autowired  
    public void setUserDao(UserDao userDao) {  
        this.userDao = userDao;  
   }  
    ...  
}  

配置文件
Java代码
<bean id="userManagerImpl" class="com.kedacom.spring.annotation.service.UserManagerImpl" />  
<bean id="userDao" class="com.kedacom.spring.annotation.persistence.UserDaoImpl">  
    <property name="sessionFactory" ref="mySessionFactory" />  
</bean>  

@Autowired可以对成员变量、方法和构造函数进行标注，来完成自动装配的工作。以上两种不同实现方式中，@Autowired的标注位置 不同，它们都会在Spring在初始化userManagerImpl这个bean时，自动装配userDao这个属性，区别是：第一种实现 中，Spring会直接将UserDao类型的唯一一个bean赋值给userDao这个成员变量；第二种实现中，Spring会调用 setUserDao方法来将UserDao类型的唯一一个bean装配到userDao这个属性。 

1.3. 让@Autowired工作起来 
要使@Autowired能够工作，还需要在配置文件中加入以下代码
Java代码
<bean class="org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor" />  


1.4. @Qualifier 
@Autowired是根据类型进行自动装配的。在上面的例子中，如果当Spring上下文中存在不止一个UserDao类型的bean时，就会 抛出BeanCreationException异常；如果Spring上下文中不存在UserDao类型的bean，也会抛出 BeanCreationException异常。我们可以使用@Qualifier配合@Autowired来解决这些问题。 
1. 可能存在多个UserDao实例
Java代码
@Autowired  
public void setUserDao(@Qualifier("userDao") UserDao userDao) {  
    this.userDao = userDao;  
}  

这样，Spring会找到id为userDao的bean进行装配。 
2. 可能不存在UserDao实例

Java代码
@Autowired(required = false)  
public void setUserDao(UserDao userDao) {  
    this.userDao = userDao;  
}  


1.5. @Resource（JSR-250标准注解，推荐使用它来代替Spring专有的@Autowired注解） 
Spring 不但支持自己定义的@Autowired注解，还支持几个由JSR-250规范定义的注解，它们分别是@Resource、@PostConstruct以及@PreDestroy。 
@Resource的作用相当于@Autowired，只不过@Autowired按byType自动注入，而@Resource默认按 byName自动注入罢了。@Resource有两个属性是比较重要的，分别是name和type，Spring将@Resource注解的name属性 解析为bean的名字，而type属性则解析为bean的类型。所以如果使用name属性，则使用byName的自动注入策略，而使用type属性时则使 用byType自动注入策略。如果既不指定name也不指定type属性，这时将通过反射机制使用byName自动注入策略。 
@Resource装配顺序
如果同时指定了name和type，则从Spring上下文中找到唯一匹配的bean进行装配，找不到则抛出异常
如果指定了name，则从上下文中查找名称（id）匹配的bean进行装配，找不到则抛出异常
如果指定了type，则从上下文中找到类型匹配的唯一bean进行装配，找不到或者找到多个，都会抛出异常
如果既没有指定name，又没有指定type，则自动按照byName方式进行装配（见2）；如果没有匹配，则回退为一个原始类型（UserDao）进行匹配，如果匹配则自动装配；


1.6. @PostConstruct（JSR-250） 
在方法上加上注解@PostConstruct，这个方法就会在Bean初始化之后被Spring容器执行（注：Bean初始化包括，实例化Bean，并装配Bean的属性（依赖注入））。 
它的一个典型的应用场景是，当你需要往Bean里注入一个其父类中定义的属性，而你又无法复写父类的属性或属性的setter方法时，如：
Java代码
public class UserDaoImpl extends HibernateDaoSupport implements UserDao {  
    private SessionFactory mySessionFacotry;  
    @Resource  
    public void setMySessionFacotry(SessionFactory sessionFacotry) {  
        this.mySessionFacotry = sessionFacotry;  
    }  
    @PostConstruct  
    public void injectSessionFactory() {  
        super.setSessionFactory(mySessionFacotry);  
    }  
    ...  
}  

这里通过@PostConstruct，为UserDaoImpl的父类里定义的一个sessionFactory私有属性，注入了我们自己定义的sessionFactory（父类的setSessionFactory方法为final，不可复写），之后我们就可以通过调用 super.getSessionFactory()来访问该属性了。 

1.7. @PreDestroy（JSR-250） 
在方法上加上注解@PreDestroy，这个方法就会在Bean初始化之后被Spring容器执行。由于我们当前还没有需要用到它的场景，这里不不去演示。其用法同@PostConstruct。 

1.8. 使用<context:annotation-config />简化配置 
Spring2.1添加了一个新的context的Schema命名空间，该命名空间对注释驱动、属性文件引入、加载期织入等功能提供了便捷的配置。我们知道注释本身是不会做任何事情的，它仅提供元数据信息。要使元数据信息真正起作用，必须让负责处理这些元数据的处理器工作起来。 
AutowiredAnnotationBeanPostProcessor和 CommonAnnotationBeanPostProcessor就是处理这些注释元数据的处理器。但是直接在Spring配置文件中定义这些 Bean显得比较笨拙。Spring为我们提供了一种方便的注册这些BeanPostProcessor的方式，这就 是<context:annotation-config />：
Java代码
<beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context"  
    xsi:schemaLocation="http://www.springframework.org/schema/beans  
    http://www.springframework.org/schema/beans/spring-beans-2.5.xsd  
    http://www.springframework.org/schema/context  
    http://www.springframework.org/schema/context/spring-context-2.5.xsd">  
    <context:annotation-config />  
</beans>  

<context:annotationconfig />将隐式地向Spring容器注册AutowiredAnnotationBeanPostProcessor、 CommonAnnotationBeanPostProcessor、 PersistenceAnnotationBeanPostProcessor以及 RequiredAnnotationBeanPostProcessor这4个BeanPostProcessor。 

2. 使用Spring注解完成Bean的定义 
以上我们介绍了通过@Autowired或@Resource来实现在Bean中自动注入的功能，下面我们将介绍如何注解Bean，从而从XML配置文件中完全移除Bean定义的配置。 

2.1. @Component（不推荐使用）、@Repository、@Service、@Controller 
只需要在对应的类上加上一个@Component注解，就将该类定义为一个Bean了：
Java代码
@Component  
public class UserDaoImpl extends HibernateDaoSupport implements UserDao {  
    ...  
}  

使用@Component注解定义的Bean，默认的名称（id）是小写开头的非限定类名。如这里定义的Bean名称就是userDaoImpl。你也可以指定Bean的名称： 
@Component("userDao") 
@Component是所有受Spring管理组件的通用形式，Spring还提供了更加细化的注解形式：@Repository、 @Service、@Controller，它们分别对应存储层Bean，业务层Bean，和展示层Bean。目前版本（2.5）中，这些注解与 @Component的语义是一样的，完全通用，在Spring以后的版本中可能会给它们追加更多的语义。所以，我们推荐使用@Repository、 @Service、@Controller来替代@Component。 

2.2. 使用<context:component-scan />让Bean定义注解工作起来
Java代码
<beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context"  
    xsi:schemaLocation="http://www.springframework.org/schema/beans  
    http://www.springframework.org/schema/beans/spring-beans-2.5.xsd  
    http://www.springframework.org/schema/context  
    http://www.springframework.org/schema/context/spring-context-2.5.xsd">  
    <context:component-scan base-package="com.kedacom.ksoa" />  
</beans>  

这里，所有通过<bean>元素定义Bean的配置内容已经被移除，仅需要添加一行<context:component- scan />配置就解决所有问题了——Spring XML配置文件得到了极致的简化（当然配置元数据还是需要的，只不过以注释形式存在罢了）。<context:component-scan />的base-package属性指定了需要扫描的类包，类包及其递归子包中所有的类都会被处理。 
<context:component-scan />还允许定义过滤器将基包下的某些类纳入或排除。Spring支持以下4种类型的过滤方式：
过滤器类型 表达式范例 说明
注解 org.example.SomeAnnotation 将所有使用SomeAnnotation注解的类过滤出来
类名指定 org.example.SomeClass 过滤指定的类
正则表达式 com\.kedacom\.spring\.annotation\.web\..* 通过正则表达式过滤一些类
AspectJ表达式 org.example..*Service+ 通过AspectJ表达式过滤一些类

以正则表达式为例，我列举一个应用实例：
Java代码
<context:component-scan base-package="com.casheen.spring.annotation">  
    <context:exclude-filter type="regex" expression="com\.casheen\.spring\.annotation\.web\..*" />  
</context:component-scan>  

值得注意的是<context:component-scan />配置项不但启用了对类包进行扫描以实施注释驱动Bean定义的功能，同时还启用了注释驱动自动注入的功能（即还隐式地在内部注册了 AutowiredAnnotationBeanPostProcessor和CommonAnnotationBeanPostProcessor），因此当使用<context:component-scan />后，就可以将<context:annotation-config />移除了。 

2.3. 使用@Scope来定义Bean的作用范围 
在使用XML定义Bean时，我们可能还需要通过bean的scope属性来定义一个Bean的作用范围，我们同样可以通过@Scope注解来完成这项工作：
Java代码
@Scope("session")  
@Component()  
public class UserSessionBean implements Serializable {  
    ...  
}  


3. 参考 
http://kingtai168.javaeye.com/blog/244002 
http://www.javaeye.com/topic/244153 
http://static.springframework.org/spring/docs/2.5.x/reference/beans.html#beans-annotation-config 
http://static.springframework.org/spring/docs/2.5.x/reference/beans.html#beans-classpath-scanning
 
 
 
spring注解详解
文章分类:Java编程
1.准备工作 
(1)导入common-annotations.jar 
(2)导入schema文件 文件名为spring-context-2.5.xsd 
(3)在xml的beans节点中配置
Java代码
<?xml version="1.0" encoding="UTF-8"?>  
<beans    
.......  
xmlns:context="http://www.springframework.org/schema/context "  
  
       xsi:schemaLocation="   
.......  
http://www.springframework.org/schema/context   
http://www.springframework.org/schema/context/spring-context-2.5.xsd "  >  
  
.....  
<!--将针对注解的处理器配置好  -->  
<context:annotation-config />   
.....  
<beans>  

2.在java代码中使用@Autowired或@Resource注解方式进行装配 ，这两个注解的区别是： 
@Autowired默认按类型装配，@Resource默认按名称装配，当找不到名称匹配的bean才会按类型装配。 

默认注解
Java代码
@Resource  private PersonDao persondao;  
<bean id="personDao" class="com.hf.dao.impl.PersonDaoBean"></bean>  
首先是判断persondao是否与xml里的personDao名字相同，相同则注入， 
不同则判断persondao是否是com.hf.dao.impl.PersonDaoBean类型，是则注入不是则返回null.

Java代码
@Resource(name="personDao")  private PersonDao dao;  
<bean id="personDao" class="com.hf.dao.impl.PersonDaoBean"></bean>  

判断name名称是否与bean中id相同不同则返回null 

Spring自带注解方式
Java代码
@Autowired @Qualifier("personDao") private PersonDao persondao;  
默认是按类型注入  加上@Qualifier("personDao")则按名称注入 

3.通过在classpath 自动扫描方式把组件纳入spring容器中管理 
spring2.5为我们引入了组件自动扫描机制，它可以在类路径底下寻找标注了@Component @Service @Controller @Repository 
注解的类，并将这些类纳入进spring容器中管理。它们的作用和xml文件中使用bean 节点配饰组件是一样的。 
(1)使用到了注解的功能(需要注解准备工作的内容) 
(2)在xml中加入 
<context:component-scan base-package="com.hf" /> 
其中base-package 为需要扫描的包(包含子包) 
(3) 
@Service用于标注业务层组件 
@Controller用于标注控制层组件(如struts中的action) 
@Repository用于标注数据访问组件 ，即DAO 组件 
@Component泛指组件，当组件不好归类的时候，我们可以使用这个注解进行标注。 

(4)
Java代码
业务类  
@Service  
public class PersonServiceBean implements PersonService {.....}  
输出类  
AbstractApplicationContext cxt = new ClassPathXmlApplicationContext("beans.xml");  
PersonService personService= (PersonService)cxt.getBean("personServiceBean");  
System.out.println(personService);  
cxt.close(););  

使用注解中bean的id默认名称为类名称的首字母小写名称 
-------------------------------------------------- 
自己指定名称
Java代码
@Service("aa") //默认作用域范围 是单例范围  
public class PersonServiceBean implements PersonService {.....}  
输出类  
AbstractApplicationContext cxt = new ClassPathXmlApplicationContext("beans.xml");  
PersonService personService= (PersonService)cxt.getBean("aa");  
System.out.println(personService);  
cxt.close();  
--------------------------------------------------  
@Service("aa") @Scope("prototype")//修改bean的作用域  
public class PersonServiceBean implements PersonService {....}  
-----------------------------------------------------------
Java代码
@PostConstruct   
public void init(){    
System.out.println("初始化");  
}   
@PreDestroy   
public void destory(){     
System.out.println("释放资源");  
}  


4.AOP注解方式 
(1)准备工作： 
.导入common-annotations.jar  aspectjrt.jar aspectweaver.jar cglib-nodep-2.13.jar 
.导入schema文件 文件名为spring-aop-2.0.xsd 
.在xml的beans节点中配置
Java代码
<?xml version="1.0" encoding="UTF-8"?>  
<beans    
.......  
xmlns:aop="http://www.springframework.org/schema/aop "  
  
       xsi:schemaLocation="   
.......  
http://www.springframework.org/schema/aop   
http://www.springframework.org/schema/aop/spring-aop-2.5.xsd "  >  
  
.....  
<!-- 配置解释处理器 为@AspectJ注解提供支持  -->  
<aop:aspectj-autoproxy />  
.....  
<beans>  

(2) 
<bean id="myInterceptor" class="com.hf.service.impl.MyInterceptor"></bean> 
<bean id="personService" class="com.hf.service.impl.PersonServiceBean" ></bean> 
将切面和被拦截的类交给spring管理 
(3)切面类

Java代码
@Aspect //定义切面类  
public class MyInterceptor {  
/** 
*  @Pointcut("execution(* com.hf.service..*.*(..))")表达式含义 
* 第一个* 表示返回值类型为任意类型 
* com.hf.service..  两个点表示包路径下的子包的类也要拦截 
* com.hf.service..*.* 子包的所有类中的所有方法 第一个*是方法第二个*是类 
* (..)代表方法参数随意 可有可无可多可少 
* **/  
  
   @Pointcut("execution (* com.hf.service.impl.PersonServiceBean.*(..))")// 定义切入点  
private void andMethod()//声明一个切入点   
{}  
  
/*   @Before("andMethod()") 
public void doAccessCheck(){ 
System.out.println("前置通知");     
} 
*/  
  
@Before("andMethod() && args(name)") //带参数 只拦截符合参数类型的方法  
public void doAccessCheck(String name){  
System.out.println("前置通知"+name);      
}  
  
/*   @AfterReturning("andMethod()") 
public void doFaterReturning(){     
System.out.println("后置通知"); 
}*/  
  
@AfterReturning(pointcut="andMethod()",returning="result")//带返回值的 无返回值的方法 result为null  
public void doFaterReturning(String result){//拦截方法执行后 获取返回值对象  
System.out.println("后置通知:"+result);  
}  
  
@After("andMethod()")  
public void doAfter(){  
System.out.println("最终通知");    
}  
  
/*   @AfterThrowing("andMethod()") 
public void doAfterThrowing(){     
System.out.println("例外通知"); 
}*/  
  
@AfterThrowing(pointcut="andMethod()" , throwing="e") //获取例外并打印  
public void doAfterThrowing(Exception e){     
System.out.println("例外通知:"+e);  
}  
  
@Around("andMethod()")//环绕通知  
public Object doBasecProfiling(ProceedingJoinPoint pjp )throws Throwable{  
//if(){//判断是否与权限  
System.out.println("进入通知");  
Object result = pjp.proceed();  
System.out.println("离开 通知");  
//}  
return result;  
  
}  
}  

(4)业务类 PersonServiceBean
Java代码
public class PersonServiceBean implements PersonService {  
  
 public void save(String name){  
throw new RuntimeException("纯属例外");  
// System.out.println("我是Save方法"+name);  
}  
public String update() {    
return "我是update方法";  
}  
}
 Copyright ©2011 lyt. All Rights Reserved.
 
 
 
java核心技术学习
使用Spring注解方式管理事务与传播行为详解

事务传播属性

REQUIRED:业务方法需要在一个事务中运行。如果方法运行时，已经处在一个事务中，那么加入到该事务，否则为自己创建一个新事物。

NOT_SUPPORTED:声明方法不需要事务。如果方法没有关联导一个事务，容器不会为他开启事务。如果方法在一个事务中被调用，该事务会被挂起，在方法调用结束后，新事物才算结束，原先事务才会恢复执行

REQUIRESNEW:属性声明不管是否存在事务，业务方法总会为自己发起一个新的事务。如果方法已经运行在一个事务中，则原有事务会被挂起，新的事务会被创建，直到方法执行结束，新事物才算结束，原先的事务才会恢复执行。

MANDATORY:该属性指定业务方法只能在一个已经存在的事务中执行，业务方法不能发起自己的事务。如果业务方法在没有事务的环境下调用，则容器就会跑出例外。

SUPPORTS:这一事物属性表明，如果业务方法在某个事务范围内被调用，则方法成为该事物的一部分。如果业务方法在事物范围外被调用，则方法在没有事务的环境下执行。

NEVER:指定业务方法绝对不能再事务范围内执行。如果业务方法在某个事务中执行，容器会跑出例外，只有业务方法没有关联到任何事务，才能正常执行。

NESTED:如果一个活动的事务存在，则运行在一个嵌套的事务中，如果没有活动事务，则按REQUIRED属性执行，它使用了一个单独的事务，这个事务拥有多个可以回滚的保存点。内部事务的回滚不会对外部事务造成影响。他只对DataSourceTransactionManager事务管理起效。
 
 
uncheck  运行期例外     默认情况下回滚
check   默认情况下不回滚
 
 
@Transactional (rollbackFor=Exception.class)  //不论是否是unchecked,checked ,都回滚
public void delete(Integer personid) throws Exception{
 jdbcTemplate.update("delete from person where id=?", new Object[]{personid},
  new int[]{java.sql.Types.INTEGER});
 throw new Exception("运行期例外");
}
@Transactional (noRollbackFor=RuntimeException.class) //unchecked不回滚
public void delete(Integer personid) throws Exception{
 jdbcTemplate.update("delete from person where id=?", new Object[]{personid},
  new int[]{java.sql.Types.INTEGER});
 throw new RuntimeException("运行期例外");
}

默认情况，都有事务处理，有时候获取等方法，不需要事务，应该如下处理：
@Transactional (propagation=Propagation.NOT_SUPPORTED) 
public Person getPerson(Integer personid){
 return (Person) jdbcTemplate.queryForObject("select * from person where id=?",new Object[]{personid},
  new int[]{java.sql.Types.INTEGER},new PersonRowMapper());
}

默认情况，都有事务处理，默认的代码如下：
@Transactional (propagation=Propagation.REQUIRED) 
public Person getPerson(Integer personid){
 return (Person) jdbcTemplate.queryForObject("select * from person where id=?",new Object[]{personid},
  new int[]{java.sql.Types.INTEGER},new PersonRowMapper());
}
 
 
数据库系统提供4中事务隔离级别。

1、Read Uncommited:读未提交数据   （基本上用不着。事务并发能引起脏读，不可重复读和幻读）
2、Read Commited:读已提交数据  （会出现不可重复读和幻读）
3、Repeatable Read:可重复读 （会出现幻读）
4、Serializable:串行化
 
SQL2000 默认第二种，读已提交数据。
mysql 默认第三种，可重复读。
 
脏读：一个事务读取到另一事务未提交的更新数据。
不可复读：在同一事物中，多次读取同一数据返回的结果有所不同。还句话说就是，后续读取可以读到另一事务已提交的更新数据。相反，“可重复读”在同一事物中多次读取数据时，能够保证所读取得数据一样，也就是后续读取不能读取到另一事务已提交的更新数据。
幻读：一个事务读取到另一事务已提交的insert数据。
 
 
使用配置文件实现事务管理，去掉 <tx:annotation-driven transaction-manager="txManager"/>
 
 

view plaincopy to clipboardprint?
<aop:config>   
    <aop:pointcut id="transactionPointcut" expression="execution(* cn.itcast.service..*.*(..))"/>   
    <aop:advisor dvice-ref="txAdvice" pointcut-ref="transactionPointcut"/>   
</aop:config>   
  
<tx:advice id="txAdvice" transaction-manager="txManager">   
    <tx:attributes>   
        <tx:method name="get*" read-only="true" propagation="NOT_SUPPORTED"/>   
        <tx:method name="*"/> <!--启用默认类型-->   
    </tx:attributes>   
</tx:advice>  
<aop:config>
 <aop:pointcut id="transactionPointcut" expression="execution(* cn.itcast.service..*.*(..))"/>
 <aop:advisor dvice-ref="txAdvice" pointcut-ref="transactionPointcut"/>
</aop:config>
<tx:advice id="txAdvice" transaction-manager="txManager">
 <tx:attributes>
  <tx:method name="get*" read-only="true" propagation="NOT_SUPPORTED"/>
  <tx:method name="*"/> <!--启用默认类型-->
 </tx:attributes>
</tx:advice>
推荐使用注解方式配置事务管理。
注意：
 <tx:method name="test*" read-only="true" />
read-only = true 是某些应用环境下可以提升，系统性能，如不需要脏校验刷新的地方。非 no commit 的意思。
当你的testAdd方法中存在数据库insert,update,del操作，依然会被commit的。
如果是，select 之类的，可以用 
<tx:method name="get*" read-only="true" propagation="NOT_SUPPORTED"/>  
 Copyright ©2011 lyt. All Rights Reserved.
 
 
 
 
java核心技术学习
spring框架

一、 Spring_Bean的作用域及自动装配
A.        根据名称自动装配
1.            举例同公共注入的四个类
1-1.          保留Bean2,Bean3,Bean4,Bean5之间的依赖管理，修改配置文件如下
<?xml version="1.0" encoding="UTF-8"?>
 
<beans xmlns="http://www.springframework.org/schema/beans"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xmlns:aop="http://www.springframework.org/schema/aop"
         xmlns:tx="http://www.springframework.org/schema/tx"
         xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.0.xsd
           http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-2.0.xsd
           http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-2.0.xsd"
//在bean的描述文件中增加：default-autowire="byName"
           default-autowire="byName">
 
    <!--  把下面的bean2注释掉，只对bean2进行声明，不用配置依赖关系
    <bean id="bean2" class="com.bjsxt.spring.Bean2">
        <property name="bean3" ref="bean3"/>
        <property name="bean4">
            <ref bean="bean4"/>
        </property>
        <property name="bean5" ref="bean5"/>
    </bean>
-->
//只是简单的把bean2配置如下
    <bean id="bean2" class="com.bjsxt.spring.Bean2"/>
    <bean id="bean5" class="com.bjsxt.spring.Bean5">
        <property name="age" value="25"/>
    </bean>
</beans>
   根据名称自动装配bean,如上面的代码中可以看见，每个bean的名称即id属性必须和类中的名称一致，这里说的名称是get或set方法后面的变量的名称,如下面的代码。
   ** 配置第一点，声明bean2: <bean id="bean2" class="com.bjsxt.spring.Bean2"/>
   ** 配置第二点，修改bean描述文件：加入default-autowire="byName"，配置这个代码之后，只对当前的文件起作用，也就是说只有当前文件时支持根据名称自动装配。
好处：可以节省配置，项目的开发初期能够增加开发的速度。
缺点：不能够显示的看出bean之间的引用关系，如果是项目初期可以这样配置，如果是项目完成之后，修改阶段应该把依赖关系也写上，然后注释掉，这样方便维护。
B.        根据类型自动装配
1.            修改配置文件
<?xml version="1.0" encoding="UTF-8"?>
 
<beans xmlns="http://www.springframework.org/schema/beans"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xmlns:aop="http://www.springframework.org/schema/aop"
         xmlns:tx="http://www.springframework.org/schema/tx"
         xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.0.xsd
           http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-2.0.xsd
           http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-2.0.xsd"
//在bean的描述文件中增加：default-autowire="byType"
           default-autowire="byType">
 
    <!-- 
    <bean id="bean2" class="com.bjsxt.spring.Bean2">
        <property name="bean3" ref="bean3"/>
        <property name="bean4">
            <ref bean="bean4"/>
        </property>
        <property name="bean5" ref="bean5"/>
    </bean>
-->
//只是简单的把bean2配置如下
    <bean id="bean2" class="com.bjsxt.spring.Bean2"/>
    <bean id="bean588i7" class="com.bjsxt.spring.Bean5">
        <property name="age" value="25"/>
    </bean>
</beans>
2.            结果分析
根据类型自动装配bean,如上面的代码中可以看见，每个bean的类即class属性必须和相应的类名称一致，如下面的代码。
   ** 配置第一点，声明bean2: <bean id="bean2" class="com.bjsxt.spring.Bean2"/>
   ** 配置第二点，修改bean描述文件：加入default-autowire="byType"，配置这个代码之后，只对当前的文件起作用，也就是说只有当前文件时支持根据类型自动装配。
    ** 因为bean2是主bean，其他bean是他的属性，所以根据类型自动装配会忽略id,bean的id可以随便写，不用跟bean2.java中的属性名称一致。
好处：可以节省配置，项目的开发初期能够增加开发的速度。
缺点：不能够显示的看出bean之间的引用关系，如果是项目初期可以这样配置，如果是项目完成之后，修改阶段应该把依赖关系也写上，然后注释掉，这样方便维护。
 
二、 Spring_代理模式及AOP术语
A.        JDK动态代理简介
1.            代理模式简介-静态代理
1-1.          创建了Java Web Project, 创建com.bjsxt.spring，创建UserManager.java
1-2.          创建UserManagerImpl.java
接口的实现类
package com.bjsxt.spring;
 
public class UserManagerImpl implements UserManager {
    public void addUser(String username, String password) {
          //checkSecurity();
        System.out
                .println("------------UserManagerImpl.addUser()--------------");
    }
    public void deleteUser(int id) {
          //checkSecurity();
        System.out
        .println("------------UserManagerImpl.deleteUser()--------------");
    }
    public String findUserById(int id) {
          //checkSecurity();
        System.out      .println("------------UserManagerImpl.findUserById()--------------");
        return null;
    }
    public void modifyUser(int id, String username, String password) {
          //checkSecurity();
        System.out
            .println("------------UserManagerImpl.modifyUser()--------------");
    }
     //正常做法，把检查机制抽取出来一个方法，放到这个实现类中
     //检查安全性的方法
     //但是这么做就打破了我们的封装性，从OCP原则上来看，这种做法是不符合的。
     //我要扩展这样的一个功能，就必须修改源代码
     //OCP是我们的理想状态
     //因此可以启用一个代理类，这是一个解决方案
    // private void checkSecurity(){
    // System.out
    // .println("------------UserManagerImpl.checkSecurity()--------------");
    // }
}
1-3.          创建UserManagerImplProxy.java
假设想在执行一些方法之前，调用一个安全检查机制，只有验证通过了，才能调用方法，为了不改变原对象的接口，可以创建一个静态的（可以看见）代理类，把安全检查方法写到里面，如：checkSecurity()，每个方法执行的时候，都要首先调用此方法。
//代理模式也必须跟目标对象的接口是一致的，只是一个场景的问题，要分析它的问题域，当接口改变时，这个是比较灵活的。
//缺点：如果方法很多，每个方法就必须都调用一句checkSecurity();
这样使安全性检查散布在所有的类中
可以看到，安全性检查和正常的业务是没有任何关系的，比如我们的删除，添加功能，安全性检查可以看做是一种服务，他们有一种正交性，互不影响，不影响业务，可以看做是一种横切性问题。比如日志，事务。拿出了就是不检查了，不影响方法。那么这个散步的方法，我们可以把它叫做横切性的关注点，因此静态代理无法解决这个问题，出现了动态(运行期生成的)代理。
package com.bjsxt.spring;
 
public class UserManagerImplProxy implements UserManager {
     //我们想控制目标对象，这样就必须具有目标对象的一个引用
    private UserManager userManager;
     //采用构造方法的方式来拿到这个目标对象比较灵活
    public UserManagerImplProxy(UserManager userManager) {
        this.userManager = userManager;
    }
    public void addUser(String username, String password) {
        checkSecurity();
        this.userManager.addUser(username, password);
    }
    public void deleteUser(int id) {
        checkSecurity();
        this.userManager.deleteUser(id);
    }
    public String findUserById(int id) {
        checkSecurity();
        this.userManager.findUserById(id);
        return null;
    }
 
    public void modifyUser(int id, String username, String password) {
        checkSecurity();
        this.userManager.modifyUser(id, username, password);
    }
     //检查安全性代码
    private void checkSecurity() {
    System.out.println("------------UserManagerImplProxy.checkSecurity()--------------");
    }
}
1-4.          创建Client.java  客户端调用
package com.bjsxt.spring;
public class Client {
    public static void main(String[] args) {
          //不使用代理类的调用方法
        //UserManager userManager = new UserManagerImpl();
         //使用代理类的调用方法,通过传入参数来加载接口实现，相对来说比较灵活
UserManager userManager = new UserManagerImplProxy(new UserManagerImpl());
        //userManager.addUser("张三", "123");
        //userManager.deleteUser(1);
        userManager.findUserById(1);
    }
}
2.            JDK动态代理（spring-aop机制）
1-1.          SecurityHandler.java 动态代理类，在运行期生成
AOP可以看做是在技术上对OO的一个补充
package com.bjsxt.spring;
import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;
//实现InvocationHandler接口
public class SecurityHandler implements InvocationHandler {
     //目标对象
    private Object targetObject;
     //对目标对象生成代理,代理对象也是一个Object
     //目标对象(UserManagerImpl.java)要实现接口，我们的JDK才能够代理
     //参数：目标对象
    public Object newProxy(Object targetObject) {
        this.targetObject = targetObject;
          //创建代理的一个实例
          //参数：lodaer:ClassLoader用于装载这个类文件的,interfaces:接口,h:实现了InvocationHandler的类
        //方法原型 return Proxy.newProxyInstance(loader, interfaces, h);
        return Proxy.newProxyInstance(targetObject.getClass().getClassLoader(),
                targetObject.getClass().getInterfaces(), this);
    }
     //默认会先调用invoke方法，因此可以把安全性检查方法在这里面执行
     //有的方法需要返回值，所以这里返回一个对象
     //调用方法可能出现异常，所以这里要用try{}catch{}块
    public Object invoke(Object proxy, Method method, Object[] args)
            throws Throwable {
        //checkSecurity();
        Object ret = null;
        try {
              //当调用addUser时，method=addUser
            //System.out.println("method="+method.getName());
          //如果想对某些方法执行安全性检查，还可以通过以下代码来执行
        if (method.getName().equals("addUser") || method.getName().equals("deleteUser")) {
                checkSecurity();
            }
               //invoke调用，参数：目标对象，参数
            ret = method.invoke(this.targetObject, args);
        } catch (Exception e) {
            e.printStackTrace();
            throw new java.lang.RuntimeException(e);
        }
          //返回值
        return ret;
    }
     //安全检查代码
    private void checkSecurity() {
        System.out      .println("------------UserManagerImplProxy.checkSecurity()--------------");
    }
}
1-2.          客户端调用 Client.java
通过这种方式，把一些关注点，具有横切性的东西，单独拿出来，放到一个单独的类里，这种过程称为模块化，自动把这种横切性的机制加进去。
package com.bjsxt.spring;
public class Client {
    public static void main(String[] args) {
          //原来的调用方式
        //UserManager userManager = new UserManagerImpl();
        //userManager.addUser("张三", "123");
Weave
        //userManager.deleteUser(1);
          //首先,new一个安全性的处理类对象
        SecurityHandler hander = new SecurityHandler();
          //newProxy返回一个目标对象的代理对象,代理对象和目标对象的接口一致，因此可以直接转换
UserManager userManager = (UserManager)hander.newProxy(new UserManagerImpl());
        userManager.findUserById(1);//调用方法
        //userManager.addUser("张三", "123");
    }
}
 
 
 
 
检查安全性
Cross cutting
concern
横切性的关注点
Joinpoint(addUser(…))
Aspect
SecurityHandler
Advice----checkSerurity
Before Advice
After Advice
Thorw Advice
………
Pointcut(add*)
 下箭头: 方法调用的过程
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

1、               「箭头」：表示从上到下的一个方法调用。
2、               「检查安全性」：非常独立的一个问题，横切性的关注点，cross cutting concern。
3、               「Aspect」：切面，我们把横切性的关注点进行模块化，模块化的类叫切面。
4、               「SecurityHandler」:切面类，切面类里面的checkSecurity()是横切性问题关注点的具体的实现。
5、               「Adcice」：checkSecurity()是横切性问题关注点的具体的实现，这个实现在AOP中叫advice.本例中对应的是：checkSecurity()。Advice还有一些分类，加在方法之前，方法之后，抛出异常时调用……
6、               「Pointcut()」：最终目的把我们的Advice应用到我们的目标方法之前，那么就需要有一个范围指定，叫做Pointcut()，他本身支持一些表达式。
7、               「Weave」:把切面应用到我们的目标对象(target object)的过程，进一步说把advice应用到目标对象的方法上的过程叫：织入。
8、               「JoinPoint()」:连接点，执行的点，切面应用的地方，在spring中连接点只支持方法，在一些更强大的AOP中，连接点可以支持成员变量和构造函数，即spring只支持方法的连接点。
9、               「Target Object」:目标对象，真实的实现类，AOP的术语。
10、           「Proxy」：代理，spring的aop使用的是动态代理实现的。
11、           「Introduction」：当我们的类中有方法一，方法二时，它可以动态的给我们加上一个方法三。
6.1.1. AOP概念
首先让我们从定义一些重要的AOP概念开始。这些术语不是Spring特有的。 不幸的是，Spring术语并不是特别的直观；如果Spring使用自己的术语，将会变得更加令人困惑。
·         切面（Aspect）： 一个关注点的模块化，这个关注点可能会横切多个对象。事务管理是J2EE应用中一个关于横切关注点的很好的例子。在Spring AOP中，切面可以使用通用类（基于模式的风格） 或者在普通类中以 @Aspect 注解（@AspectJ风格）来实现。
·         连接点（Joinpoint）： 在程序执行过程中某个特定的点，比如某方法调用的时候或者处理异常的时候。 在Spring AOP中，一个连接点 总是 代表一个方法的执行。 通过声明一个org.aspectj.lang.JoinPoint类型的参数可以使通知（Advice）的主体部分获得连接点信息。
·         通知（Advice）： 在切面的某个特定的连接点（Joinpoint）上执行的动作。通知有各种类型，其中包括“around”、“before”和“after”等通知。通知的类型将在后面部分进行讨论。许多AOP框架，包括Spring，都是以拦截器做通知模型， 并维护一个以连接点为中心的拦截器链。
·         切入点（Pointcut）： 匹配连接点（Joinpoint）的断言。通知和一个切入点表达式关联，并在满足这个切入点的连接点上运行（例如，当执行某个特定名称的方法时）。切入点表达式如何和连接点匹配是AOP的核心：Spring缺省使用AspectJ切入点语法。
·         引入（Introduction）： （也被称为内部类型声明（inter-type declaration））。声明额外的方法或者某个类型的字段。 Spring允许引入新的接口（以及一个对应的实现）到任何被代理的对象。 例如，你可以使用一个引入来使bean实现 IsModified 接口，以便简化缓存机制。
·         目标对象（Target Object）： 被一个或者多个切面（aspect）所通知（advise）的对象。也有人把它叫做 被通知（advised） 对象。 既然Spring AOP是通过运行时代理实现的，这个对象永远是一个 被代理（proxied） 对象。
·         AOP代理（AOP Proxy）： AOP框架创建的对象，用来实现切面契约（aspect contract）（包括通知方法执行等功能）。在Spring中，AOP代理可以是JDK动态代理或者CGLIB代理。 注意：Spring 2.0最新引入的基于模式（schema-based）风格和@AspectJ注解风格的切面声明，对于使用这些风格的用户来说，代理的创建是透明的。
·         织入（Weaving）： 把切面（aspect）连接到其它的应用程序类型或者对象上，并创建一个被通知（advised）的对象。 这些可以在编译时（例如使用AspectJ编译器），类加载时和运行时完成。 Spring和其它纯Java AOP框架一样，在运行时完成织入。
通知的类型：
·         前置通知（Before advice）： 在某连接点（join point）之前执行的通知，但这个通知不能阻止连接点前的执行（除非它抛出一个异常）。
·         返回后通知（After returning advice）： 在某连接点（join point）正常完成后执行的通知：例如，一个方法没有抛出任何异常，正常返回。
·         抛出异常后通知（After throwing advice）： 在方法抛出异常退出时执行的通知。
·         后通知（After (finally) advice）： 当某连接点退出的时候执行的通知（不论是正常返回还是异常退出）。
·         环绕通知（Around Advice）： 包围一个连接点（join point）的通知，如方法调用。这是最强大的一种通知类型。环绕通知可以在方法调用前后完成自定义的行为。它也会选择是否继续执行连接点或直接返回它们自己的返回值或抛出异常来结束执行。
环绕通知是最常用的一种通知类型。大部分基于拦截的AOP框架，例如Nanning和JBoss4，都只提供环绕通知。
跟AspectJ一样，Spring提供所有类型的通知，我们推荐你使用尽量简单的通知类型来实现需要的功能。 例如，如果你只是需要用一个方法的返回值来更新缓存，虽然使用环绕通知也能完成同样的事情，但是你最好使用After returning通知而不是环绕通知。 用最合适的通知类型可以使得编程模型变得简单，并且能够避免很多潜在的错误。比如，你不需要调用 JoinPoint（用于Around Advice）的 proceed() 方法，就不会有调用的问题。
在Spring 2.0中，所有的通知参数都是静态类型，因此你可以使用合适的类型（例如一个方法执行后的返回值类型）作为通知的参数而不是使用一个对象数组。
切入点（pointcut）和连接点（join point）匹配的概念是AOP的关键，这使得AOP不同于其它仅仅提供拦截功能的旧技术。 切入点使得定位通知（advice）可独立于OO层次。 例如，一个提供声明式事务管理的around通知可以被应用到一组横跨多个对象中的方法上（例如服务层的所有业务操作）。
三、 Spring_AOP示例
A.        采用Annotation方式实现AOP
1.            引入相关包，创建web project,引入user library
spring对AOP支持（采用Annotation的方式）
 
1、spring依赖库
    * SPRING_HOME/dist/spring.jar  spring的框架包
    * SPRING_HOME/lib/jakarta-commons/commons-logging.jar   自动选择不同的实现，配置log4j就选log4j
    * SPRING_HOME/lib/log4j/log4j-1.2.14.jar   日志输出
    * annotation 方式---注解的方式,以下是相关包，aspectj是一个强大的aop实现
    * SPRING_HOME/lib/aspectj/aspectjrt.jar
* SPRING_HOME/lib/aspectj/aspectjweaver.jar
2、采用Aspect定义切面
3、在Aspect定义Pointcut和Advice
4、启用Aspectj对Annotation的支持并且将Aspect类和目标对象配置到IoC容器中
注意：在这种方法定义中，切入点的方法是不被执行的，它存在的目的仅仅是为了重用切入点
     即Advice中通过方法名引用这个切入点
     AOP:
   * Cross cutting concern
   * Aspect
   * Advice
   * Pointcut
   * Joinpoint
   * Weave
   * Target Object
   * Proxy
   * Introduction    
引入applicationContext.xml和log4j.pro
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xmlns:aop="http://www.springframework.org/schema/aop"
         xmlns:tx="http://www.springframework.org/schema/tx"
         xsi:schemaLocation="http://www.springframework.org/schema/beans
<!—说明对aop标签的支持 -->
http://www.springframework.org/schema/beans/spring-beans-2.0.xsd
           http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-2.0.xsd
           http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-2.0.xsd">
     <!-- 启用ascpecj对annotation的支持 -->
     <aop:aspectj-autoproxy/>
     <!-- 配置需要spring管理的对象 -->
<!-- 切面对象 -->
     <bean id="securityHandler" class="com.bjsxt.spring.SecurityHandler"/>
     <!-- 接口实现类 -->
     <bean id="userManagerImpl" class="com.bjsxt.spring.UserManagerImpl"/>
</beans>
如果不支持AOP标签，还是采用加入的方式
WindowsàPreferences…àMyEclipseàFiles and EditorsàXMLàXML Catalog
点击Add…,在弹出页面中，设定Key Type:URI,然后到Location中后面的File System…,找到
SPRING_HOME/dist/resources/ spring-aop-2.0.xsd,把它添加进来
设定Key Type:Schema Location
在Key后面添加：/ spring-aop-2.0.xsd
点击OK即可。
会在applicationContext.xml中看到如下代码
<beans xmlns="http://www.springframework.org/schema/beans"
         xmlns:xsi=http://www.w3.org/2001/XMLSchema-instance
          <!—说明对aop标签的支持 -->
         xmlns:aop="http://www.springframework.org/schema/aop"
         xmlns:tx="http://www.springframework.org/schema/tx"
         xsi:schemaLocation="http://www.springframework.org/schema/beans
<!—说明对aop标签的支持 -->
http://www.springframework.org/schema/beans/spring-beans-2.0.xsd
           http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-2.0.xsd
           http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-2.0.xsd">
2.            拷贝UserManager.java和UserManagerImpl.java
3.            创建SecurityHandler.java
package com.bjsxt.spring;
 
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Before;
import org.aspectj.lang.annotation.Pointcut;
 
/**
 * 定义切面Aspect
*/
@Aspect
public class SecurityHandler {
    /**
     * 定义Pointcut,Pointcut的名称就是allAddMethod,此方法不能有返回值和参数，
     * 该方法只是一个标识，用来设定范围
     *
     * Pointcut的内容是一个表达式，描述哪些对象的哪些方法（订阅Joinpoint）
     */
    @Pointcut("execution(* add*(..))")
    private void allAddMethod() {
    };
 
    /**
     * 定义Advice，标识在哪个切入点何处织入次方法
     */
    @Before("allAddMethod()")
    private void checkSecurity() {
        System.out.println("----SecurityHandler.checkSecurity()-----");
    }
}
4.            AOP声明表达式
Spring AOP 用户可能会经常使用 execution pointcut designator。执行表达式的格式如下：
execution(modifiers-pattern? ret-type-pattern declaring-type-pattern? name-pattern(param-pattern) throws-pattern?)
除了返回类型模式（上面代码片断中的ret-type-pattern），名字模式和参数模式以外，所有的部分都是可选的。 返回类型模式决定了方法的返回类型必须依次匹配一个连接点。你会使用的最频繁的返回类型模式是 *，它代表了匹配任意的返回类型。 一个全称限定的类型名将只会匹配返回给定类型的方法。名字模式匹配的是方法名。你可以使用 * 通配符作为所有或者部分命名模式。 参数模式稍微有点复杂：() 匹配了一个不接受任何参数的方法， 而 (..) 匹配了一个接受任意数量参数的方法（零或者更多）。模式 (*) 匹配了一个接受一个任何类型的参数的方法。 模式 (*,String) 匹配了一个接受两个参数的方法，第一个可以是任意类型，第二个则必须是String类型。请参见AspectJ编程指南的 Language Semantics 部分。
下面给出一些常见切入点表达式的例子。
·         任意公共方法的执行：
execution(public * *(..))
·         任何一个以“set”开始的方法的执行：
execution(* set*(..))
·         AccountService 接口的任意方法的执行：
execution(* com.xyz.service.AccountService.*(..))
·         定义在service包里的任意方法的执行：
execution(* com.xyz.service.*.*(..))
·         定义在service包或者子包里的任意方法的执行：
execution(* com.xyz.service..*.*(..))
·         在service包里的任意连接点（在Spring AOP中只是方法执行） ：
within(com.xyz.service.*)
·         在service包或者子包里的任意连接点（在Spring AOP中只是方法执行） ：
within(com.xyz.service..*)
·         实现了 AccountService 接口的代理对象的任意连接点（在Spring AOP中只是方法执行） ：
this(com.xyz.service.AccountService)
'this'在binding form中用的更多：- 请常见以下讨论通知的章节中关于如何使得代理对象可以在通知体内访问到的部分。
·         实现了 AccountService 接口的目标对象的任意连接点（在Spring AOP中只是方法执行） ：
target(com.xyz.service.AccountService)
'target'在binding form中用的更多：- 请常见以下讨论通知的章节中关于如何使得目标对象可以在通知体内访问到的部分。
·         任何一个只接受一个参数，且在运行时传入的参数实现了 Serializable 接口的连接点 （在Spring AOP中只是方法执行）
args(java.io.Serializable)
'args'在binding form中用的更多：- 请常见以下讨论通知的章节中关于如何使得方法参数可以在通知体内访问到的部分。
请注意在例子中给出的切入点不同于 execution(* *(java.io.Serializable))： args只有在动态运行时候传入参数是可序列化的（Serializable）才匹配，而execution 在传入参数的签名声明的类型实现了 Serializable 接口时候匹配。
·         有一个 @Transactional 注解的目标对象中的任意连接点（在Spring AOP中只是方法执行）
@target(org.springframework.transaction.annotation.Transactional)
'@target' 也可以在binding form中使用：请常见以下讨论通知的章节中关于如何使得annotation对象可以在通知体内访问到的部分。
·         任何一个目标对象声明的类型有一个 @Transactional 注解的连接点（在Spring AOP中只是方法执行）
@within(org.springframework.transaction.annotation.Transactional)
'@within'也可以在binding form中使用：- 请常见以下讨论通知的章节中关于如何使得annotation对象可以在通知体内访问到的部分。
·         任何一个执行的方法有一个 @Transactional annotation的连接点（在Spring AOP中只是方法执行）
@annotation(org.springframework.transaction.annotation.Transactional)
'@annotation' 也可以在binding form中使用：- 请常见以下讨论通知的章节中关于如何使得annotation对象可以在通知体内访问到的部分。
·         任何一个接受一个参数，并且传入的参数在运行时的类型实现了 @Classified annotation的连接点（在Spring AOP中只是方法执行）
@args(com.xyz.security.Classified)
'@args'也可以在binding form中使用：- 请常见以下讨论通知的章节中关于如何使得annotation对象可以在通知体内访问到的部分。
B.        采用静态配置文件方式实现AOP
spring对AOP支持（采用配置文件的方式）
 
1、spring依赖库
    * SPRING_HOME/dist/spring.jar  spring的框架包
    * SPRING_HOME/lib/jakarta-commons/commons-logging.jar   自动选择不同的实现，配置log4j就选log4j
    * SPRING_HOME/lib/log4j/log4j-1.2.14.jar   日志输出
    * annotation 方式---注解的方式,以下是相关包，aspectj是一个强大的aop实现
    * SPRING_HOME/lib/aspectj/aspectjrt.jar
    * SPRING_HOME/lib/aspectj/aspectjweaver.jar
   
2、配置如下：
     <!-- 配置切面 -->
     <aop:config>
         <aop:aspect id="security" ref="securityHandler">
             <aop:pointcut id="allAddMethod" expression="execution(* com.bjsxt.spring.UserManagerImpl.add*(..))"/>
             <aop:before method="checkSecurity" pointcut-ref="allAddMethod"/>
         </aop:aspect>
     </aop:config>
3、其他类不变，客户端调用也不变
1.            修改SecurityHandler.java
package com.bjsxt.spring;
public class SecurityHandler {
    private void checkSecurity() {
        System.out.println("----SecurityHandler.checkSecurity()-----");
    }
}
2.            修改配置文件applicationContext.xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xmlns:aop="http://www.springframework.org/schema/aop"
         xmlns:tx="http://www.springframework.org/schema/tx"
         xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.0.xsd
           http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-2.0.xsd
           http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-2.0.xsd">
    
     <!-- 配置需要spring管理的对象 -->
     <!-- 切面对象 -->
     <bean id="securityHandler" class="com.bjsxt.spring.SecurityHandler"/>
     <!-- 接口实现类 -->
     <bean id="userManagerImpl" class="com.bjsxt.spring.UserManagerImpl"/>
    
     <!-- 配置切面 -->
     <aop:config>
         //配置切面类
         <aop:aspect id="security" ref="securityHandler">
             //配置pointcut，指定标志和表达式
             <aop:pointcut id="allAddMethod" expression="execution(* com.bjsxt.spring.UserManagerImpl.add*(..))"/>
             //配置advice，要引用pointcut，指定范围
             <aop:before method="checkSecurity" pointcut-ref="allAddMethod"/>
         </aop:aspect>
     </aop:config>
</beans>
//可见切面的组成如下
/**aspect
/****pointcut
/****advice  ref-pointcut
C.        JoinPoint参数介绍
spring对AOP的支持
 
Aspect默认情况下不用实现接口，但对于目标对象（UserManagerImpl.java），在默认情况下必须实现接口
如果没有实现接口必须引入CGLIB库
 
我们可以通过Advice中添加一个JoinPoint参数，这个值会由spring自动传入，从JoinPoint中可以取得
参数值、方法名等等
1.            修改SecurityHandler.java
package com.bjsxt.spring;
 
import org.aspectj.lang.JoinPoint;
 
public class SecurityHandler {
 
    private void checkSecurity(JoinPoint joinPoint) {
        //拿到调用的方法传入的参数
        //123,张三
        Object[] object = joinPoint.getArgs();
        for (int i = object.length; i-- > 0;) {
            System.out.println(object[i]);
        }
        //拿到调用的方法名：addUser
        System.out.println(joinPoint.getSignature().getName());
        //拿到目标对象的实现类的名称：UserManagerImpl
        System.out.println(joinPoint.getTarget().getClass().getSimpleName());
        System.out.println("----SecurityHandler.checkSecurity()-----");
    }
}
D.        JDK动态代理和CGLIB字节码生成
spring对AOP的支持
 
1、如果目标对象实现了接口，默认情况下会采用JDK的动态代理实现AOP
2、如果目标对象实现了接口，可以强制使用CGLIB实现AOP
3、如果目标对象没有实现了接口，必须采用CGLIB库，spring会自动在JDK动态代理和CGLIB之间转换,只要引入CGLIB库即可，如果实现了接口，没有强制指定使用CGLIB的话，则默认使用JDK动态代理，推荐使用JDK动态代理。
 
如何强制使用CGLIB实现AOP？
    * 添加CGLIB库，SPRING_HOME/cglib/ cglib-nodep-2.1_3.jar
    * 在spring配置文件中加入<aop:aspectj-autoproxy proxy-target-class="true"/>
   
JDK动态代理和CGLIB字节码生成的区别？
    * JDK动态代理只能对实现了接口的类生成代理，而不能针对类
    * CGLIB是针对类实现代理，主要是对指定的类生成一个子类，覆盖其中的方法
      因为是继承，所以该类或方法最好不要声明成final  
1.            修改配置文件applicationContext.xml
<?xml version="1.0" encoding="UTF-8"?>
 
<beans xmlns="http://www.springframework.org/schema/beans"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xmlns:aop="http://www.springframework.org/schema/aop"
         xmlns:tx="http://www.springframework.org/schema/tx"
         xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.0.xsd
           http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-2.0.xsd
           http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-2.0.xsd">
     <!--  强制使用CGLIB代理
     <aop:aspectj-autoproxy proxy-target-class="true"/>
     -->
     <!-- 配置需要spring管理的对象 -->
     <!-- 切面对象 -->
     <bean id="securityHandler" class="com.bjsxt.spring.SecurityHandler"/>
     <!-- 接口实现类 -->
     <bean id="userManagerImpl" class="com.bjsxt.spring.UserManagerImpl"/>
    
     <!-- 配置切面 -->
     <aop:config>
         <aop:aspect id="security" ref="securityHandler">
             <aop:pointcut id="allAddMethod" expression="execution(* com.bjsxt.spring.UserManagerImpl.add*(..))"/>
             <aop:before method="checkSecurity" pointcut-ref="allAddMethod"/>
         </aop:aspect>
     </aop:config>
</beans>
四、 Hibernate编程式事务
A.        创建工程
1.            工程说明
采用编程式事务
 
1、getCurrentSession()与openSession()的区别？
     * 采用getCurrentSession()创建的session会绑定到当前的线程中，
       而采用openSession()创建的session则不会。
     * 采用getCurrentSession()创建的session在commit或rollback时会自动关闭，
       而采用openSession()创建的session必须手动关闭。
      
2、使用getCurrentSession()需要在hibernante.cfg.xml文件中加入如下配置：
     * 如果使用的是本地事务(JDBC事务)
     <property name="hibernate.current_session_context_class">thread</property>
     * 如果使用的全局事物(jta事物)
     <property name="hibernate.current_session_context_class">jta</property>   
2.            代码整理
a.              LogManagerImpl.java
package com.bjsxt.usermgr.manager;
import com.bjsxt.usermgr.model.Log;
import com.bjsxt.usermgr.util.HibernateUtils;
public class LogManagerImpl implements LogManager {
    public void addLog(Log log) {
        HibernateUtils.getSessionFactory().getCurrentSession().save(log);
    }
}
UserManagerImpl.java
package com.bjsxt.usermgr.manager;
import java.util.Date;
import org.hibernate.Session;
import org.hibernate.Transaction;
import com.bjsxt.usermgr.model.Log;
import com.bjsxt.usermgr.model.User;
import com.bjsxt.usermgr.util.HibernateUtils;
 
public class UserManagerImpl implements UserManager {
 
    public void addUser(User user) {
        Session session = null;
        Transaction tx = null;
        try {
            //session = HibernateUtils.getSession();
            session = HibernateUtils.getSessionFactory().getCurrentSession();
            tx = session.beginTransaction();
           
            session.save(user);
           
            Log log = new Log();
            log.setType("安全日志");
            log.setDetail("XXX进入系统");
            log.setTime(new Date());
            LogManager logManager = new LogManagerImpl();
            logManager.addLog(log);
           
            tx.commit();
        } catch (Exception e) {
            // 打印异常....
            if (tx != null) {
                tx.rollback();
            }
            e.printStackTrace();
//      } finally {
//          if (session != null) {
//              session.close();
//          }
        }
    }
 
}
Log.hbm.xml
<?xml version="1.0"?>
<!DOCTYPE hibernate-mapping PUBLIC
    "-//Hibernate/Hibernate Mapping DTD 3.0//EN"
    "http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd">
<hibernate-mapping package="com.bjsxt.usermgr.model">
    <class name="Log" table="t_log">
        <id name="id">
            <generator class="native"/>
        </id>
        <property name="type"/>
        <property name="detail"/>
        <property name="time"/>
    </class>
</hibernate-mapping>
1-2.          工具包：com.bjsxt.usermgr.util
a.              HibernateUtils.java
package com.bjsxt.usermgr.util;
 
import java.io.Serializable;
import java.util.List;
 
import org.hibernate.Query;
import org.hibernate.Session;
import org.hibernate.SessionFactory;
import org.hibernate.Transaction;
import org.hibernate.cfg.Configuration;
 
/**
 * 因为SessionFactory是重量级的，最好只初始化一次 因此写一个封装类，用来初始化这个对象
 *
 * @author Administrator
 *
 */
public class HibernateUtils {
 
    private static SessionFactory factory;
 
    /**
     * static块只执行一次，里面可以放多条语句 也可以用单例singleton. factory的创建比较耗时，一个factory对应一个数据库
     */
    static {
        try {
            Configuration cfg = new Configuration().configure();
            factory = cfg.buildSessionFactory();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
 
    public static SessionFactory getSessionFactory() {
        return factory;
    }
 
    public static Session getSession() {
        return factory.openSession();
    }
 
    public static void closeSession(Session session) {
        if (session != null) {
            if (session.isOpen()) {
                session.close();
            }
        }
    }
    /**
     * session.save()
     *
     * @param o
     *            -->需要插入的对象
     */
    public static void sessionSave(Object o) {
        Session session = null;
        if (o == null) {
            return;
        }
        try {
            session = getSession();
            session.beginTransaction();
            session.save(o);
            session.getTransaction().commit();
        } catch (RuntimeException e) {
            e.printStackTrace();
            session.getTransaction().rollback();
        } finally {
            closeSession(session);
        }
    }
    /**
     * session.update()
     *
     * @param o :
     *            o-->需要更新的对象
     */
    public static void sessionUpdate(Object o) {
        Session session = null;
        if (o == null) {
            return;
        }
        try {
            session = getSession();
            session.beginTransaction();
            session.update(o);
            session.getTransaction().commit();
        } catch (RuntimeException e) {
            e.printStackTrace();
            session.getTransaction().rollback();
        } finally {
            closeSession(session);
        }
    }
    /**
     * 采用get加载数据，在数据库中不存在相应的数据，则返回null
     *
     * @param o
     *            需要查询的对象的class
     * @param id
     *            必须是一个实现了序列化的id
     * @return 需要查找的对象的一个实例
     */
    public static Object sessionGet(Object o, Serializable id) {
        Session session = null;
        Object retObj = null;
        if (o == null) {
            return retObj;
        }
        try {
            session = getSession();
            session.beginTransaction();
            retObj = (Object) session.get(o.getClass(), id);
            session.getTransaction().commit();
        } catch (RuntimeException e) {
            e.printStackTrace();
            session.getTransaction().rollback();
        } finally {
            closeSession(session);
        }
        return retObj;
    }
    /**
     * 采用load方法加载数据，不会发出sql语句，因为load方法实现了lazy(懒加载或延迟加载)
     * 延迟加载：只有真正使用这个对象的时候，才加载(发出sql语句) hibernate延迟加载的实现原理是代理方式(CGLIB)
     *
     * 采用load加载数据，如果数据库中没有相应的数据 那么抛出objectNotFoundException
     *
     * @param o
     * @param id
     * @return
     */
    public static Object sessionLoad(Object o, Serializable id) {
        Session session = null;
        Object retObj = null;
        if (o == null) {
            return retObj;
        }
        try {
            session = getSession();
            session.beginTransaction();
            retObj = (Object) session.load(o.getClass(), id);
            session.getTransaction().commit();
        } catch (RuntimeException e) {
            e.printStackTrace();
            session.getTransaction().rollback();
            throw new java.lang.RuntimeException();
        } finally {
            closeSession(session);
        }
        return retObj;
    }
    /**
     *
     * @param o
     */
    public static void sessionDelete(Object o, Serializable id) {
        Session session = null;
        try {
            session = getSession();
            session.beginTransaction();
            Object retObj = (Object) sessionGet(o.getClass(), id);
            session.delete(retObj);
            session.getTransaction().commit();
        } catch (RuntimeException e) {
            e.printStackTrace();
            session.getTransaction().rollback();
            throw new java.lang.RuntimeException();
        } finally {
            closeSession(session);
        }
    }
    /**
     * hibernate Query 查询多条记录
     * @param className
     * @return
     */
    public static List sessionQuery(String className) {
        return sessionQuery(className, -1, -1);
    }
    /**
     * hibernate Query 查询多条记录
     * @param className     类名
     * 分页
     * @param firstResult   从第几个元素开始显示
     * @param maxResults    每页显示多少笔记录
     * @return list
     */
    public static List sessionQuery(String className, int firstResult,
            int maxResults) {
        List list = null;
        Session session = null;
        Transaction tx = null;
        try {
            session = getSession();
            tx = session.beginTransaction();
            Query query = session.createQuery("from  " + className);
            if (firstResult >= 0 && maxResults >= 0) {
                // 设置从第几个元素开始显示，默然是第0个
                query.setFirstResult(firstResult);
                // 设置每页显示多少条数据
                query.setMaxResults(maxResults);
            }
            list = query.list();
            tx.commit();
        } catch (RuntimeException e) {
            e.printStackTrace();
            if (tx != null) {
                tx.rollback();
            }
            throw e;
        } finally {
            closeSession(session);
        }
        return list;
    }
}
1-3.          hibernate.cfg.xml
<!DOCTYPE hibernate-configuration PUBLIC
    "-//Hibernate/Hibernate Configuration DTD 3.0//EN"
    "http://hibernate.sourceforge.net/hibernate-configuration-3.0.dtd">
 
<hibernate-configuration>
    <session-factory>
        <!-- 配置数据库 -->
        <property name="hibernate.connection.url">jdbc:oracle:thin:@localhost:1521:oleora</property>
        <property name="hibernate.connection.driver_class">oracle.jdbc.driver.OracleDriver</property>
        <property name="hibernate.connection.username">TESTDB</property>
        <property name="hibernate.connection.password">TESTDB</property>
       
        <!-- 配置适配器：方言 -->
        <property name="hibernate.dialect">org.hibernate.dialect.Oracle9Dialect</property>
       
        <!-- 是否打印SQL语句 -->
        <property name="hibernate.show_sql">true</property>
       
        <!-- 如果只跟一个数据库、或者资源绑定,本地事务,如果使用getCurrentSession()时,需要配置 -->
        <property name="hibernate.current_session_context_class">thread</property>
        <!-- 如果只跟多个数据库、或者资源绑定, jta事务
        <property name="hibernate.current_session_context_class">jta</property>
        -->
       
        <!-- 此标签要放在property标签后，配置映射文件 -->
        <mapping resource="com/bjsxt/usermgr/model/User.hbm.xml"/>
        <mapping resource="com/bjsxt/usermgr/model/Log.hbm.xml"/>
    </session-factory>
</hibernate-configuration>
五、 Spring与Hibernate集成_声明式事务
A.        事务的传播特性
事务属性
T1(UserManager)
Required
无
有
RequiredNew
无
T1
Support
无
有
Mandatory
无
T1
NoSupport
无
有
Never
无
T1
 
1.            项目说明
采用声明式事务
 
1、声明式事务配置
       * 配置SessionFactory
       * 配置事务管理器
       * 事务的传播特性
       * 那些类那些方法使用事务
 
2、编写业务逻辑方法
       * 继承HibernateDaoSupport类，使用HibernateTemplate来持久化，HibernateTemplate是
         Hibernate Session的轻量级封装
       * 默认情况下运行期异常才会回滚（包括继承了RuntimeException子类），普通异常是不会回滚的
       * 编写业务逻辑方法时，最好将异常一直向上抛出，在表示层（struts）处理
       * 关于事务边界的设置，通常设置到业务层，不要添加到Dao上 
 
3、了解事务的几种传播特性
       1.     PROPAGATION_REQUIRED: 如果存在一个事务，则支持当前事务。如果没有事务则开启
       2.     PROPAGATION_SUPPORTS: 如果存在一个事务，支持当前事务。如果没有事务，则非事务的执行
       3.     PROPAGATION_MANDATORY: 如果已经存在一个事务，支持当前事务。如果没有一个活动的事务，则抛出异常。
       4.     PROPAGATION_REQUIRES_NEW: 总是开启一个新的事务。如果一个事务已经存在，则将这个存在的事务挂起。
       5.     PROPAGATION_NOT_SUPPORTED: 总是非事务地执行，并挂起任何存在的事务。
       6.     PROPAGATION_NEVER: 总是非事务地执行，如果存在一个活动事务，则抛出异常
       7.     PROPAGATION_NESTED：如果一个活动的事务存在，则运行在一个嵌套的事务中. 如果没有活动事务,
            则按TransactionDefinition.PROPAGATION_REQUIRED 属性执行
 
4、Spring事务的隔离级别
       1.     ISOLATION_DEFAULT： 这是一个PlatfromTransactionManager默认的隔离级别，使用数据库默认的事务隔离级别.
            另外四个与JDBC的隔离级别相对应
       2.     ISOLATION_READ_UNCOMMITTED： 这是事务最低的隔离级别，它充许令外一个事务可以看到这个事务未提交的数据。
            这种隔离级别会产生脏读，不可重复读和幻像读。
       3.     ISOLATION_READ_COMMITTED： 保证一个事务修改的数据提交后才能被另外一个事务读取。另外一个事务不能读取该事务未提交的数据
       4.     ISOLATION_REPEATABLE_READ： 这种事务隔离级别可以防止脏读，不可重复读。但是可能出现幻像读。
            它除了保证一个事务不能读取另一个事务未提交的数据外，还保证了避免下面的情况产生(不可重复读)。
       5.     ISOLATION_SERIALIZABLE 这是花费最高代价但是最可靠的事务隔离级别。事务被处理为顺序执行。
            除了防止脏读，不可重复读外，还避免了幻像读。               
1-1.          applicationContext-common.xml
<?xml version="1.0" encoding="UTF-8"?>
 
<beans xmlns="http://www.springframework.org/schema/beans"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xmlns:aop="http://www.springframework.org/schema/aop"
         xmlns:tx="http://www.springframework.org/schema/tx"
         xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.0.xsd
           http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-2.0.xsd
           http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-2.0.xsd">
    <!-- 配置sessionFactory -->
    <bean id="sessionFactory" class="org.springframework.orm.hibernate3.LocalSessionFactoryBean">
        <property name="configLocation">
            <value>classpath:hibernate.cfg.xml</value>
        </property>
    </bean>
    <!-- 配置事务管理器 -->
    <bean id="transactionManager" class="org.springframework.orm.hibernate3.HibernateTransactionManager">
        <property name="sessionFactory">
            <ref bean="sessionFactory"/>
        </property>
    </bean>
    <!-- 配置事务的传播特性 -->
    <tx:advice id="txAdvice" transaction-manager="transactionManager">
        <tx:attributes>
            <tx:method name="add*" propagation="REQUIRED"/>
            <tx:method name="del*" propagation="REQUIRED"/>
            <tx:method name="modify*" propagation="REQUIRED"/>
            <tx:method name="*" read-only="true"/>
        </tx:attributes>
    </tx:advice>
    <!--
          配置哪些类的哪些方法参与事务，即配置事务边界
         expression表达式：(*匹配所有返回值 包.所有类.所有方法(返回值匹配任何情况))
    -->
    <aop:config>
        <aop:pointcut id="allManagerMethod" expression="execution(* com.bjsxt.usermgr.manager.*.*(..))"/>
        <aop:advisor pointcut-ref="allManagerMethod" advice-ref="txAdvice"/>
    </aop:config>
</beans>
1-2.          applicationContext-beans.xml
<?xml version="1.0" encoding="UTF-8"?>
 
<beans xmlns="http://www.springframework.org/schema/beans"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xmlns:aop="http://www.springframework.org/schema/aop"
         xmlns:tx="http://www.springframework.org/schema/tx"
         xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.0.xsd
           http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-2.0.xsd
           http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-2.0.xsd">
    <!--
           因为HibernateDaoSupport需要一个sessionFactory变量，
           因此要为这个变量注入一个工厂，此工厂引用 applicationContext-common.xml中的工厂
    -->
    <bean id="userManager" class="com.bjsxt.usermgr.manager.UserManagerImpl">
        <property name="sessionFactory" ref="sessionFactory"/>
        <property name="logManager" ref="logManager"/>
    </bean>
   
    <bean id="logManager" class="com.bjsxt.usermgr.manager.LogManagerImpl">
    <property name="sessionFactory" ref="sessionFactory"/>
    </bean>
</beans>
六、 SSH集成
A.        Spring与Struts集成_第一种方案（依赖查找）
1.            分析图
 
2.            项目创建过程
1-1.          第一步：创建Web工程    File-->New-->Web Project
 
Note.    注意：Web工程，需要把需要的jar包拷贝到WEB-INF/lib目录中。
1-2.          第二步：修改Web工程的字符集
1-3.          Window→Preferences.→MyEclipse→Files and Editors→JSP
 
Note.    选择简体中文
 
1-4.          第三步：拷贝struts和spring需要的配置文件到指定目录
*          拷贝struts-config.xml到WEB-INF目录下
*          拷贝applicationContext.xml到src目录下
*          拷贝log4j.properties到src目录下
*          拷贝MessageResources.properties到src目录下
 
1-5.          第四步：修改web.xml文件，把struts的ActionServlet配置到web.xml中
<?xml version="1.0" encoding="UTF-8"?>
<web-app version="2.4"
    xmlns="http://java.sun.com/xml/ns/j2ee"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://java.sun.com/xml/ns/j2ee
    http://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd">
  <!-- 
  <context-param>
      <param-name>contextConfigLocation</param-name>
      <param-value>classpath*:applicationContext-*.xml,
/WEB-INF/applicationContext-*.xml</param-value>
  </context-param>
  -->
  <context-param>
      <param-name>contextConfigLocation</param-name>
      <param-value>classpath*:applicationContext-*.xml</param-value>
  </context-param>
  <listener>
<listener-class>
org.springframework.web.context.ContextLoaderListener
</listener-class>
  </listener>
 
  <!-- Standard Action Servlet Configuration -->
  <servlet>
    <servlet-name>action</servlet-name>
    <servlet-class>org.apache.struts.action.ActionServlet</servlet-class>
    <init-param>
      <param-name>config</param-name>
      <param-value>/WEB-INF/struts-config.xml</param-value>
    </init-param>
    <init-param>
      <param-name>debug</param-name>
      <param-value>2</param-value>
    </init-param>
    <init-param>
      <param-name>detail</param-name>
      <param-value>2</param-value>
    </init-param>
    <load-on-startup>2</load-on-startup>
  </servlet>
  <!-- Standard Action Servlet Mapping -->
  <servlet-mapping>
    <servlet-name>action</servlet-name>
    <url-pattern>*.do</url-pattern>
  </servlet-mapping>
  <welcome-file-list>
    <welcome-file>index.jsp</welcome-file>
  </welcome-file-list>
</web-app>
1-6.          创建success.jsp用户登录成功后的页面-----使用了el表达式取用户名
<%@ page language="java" contentType="text/html; charset=GB18030"
    pageEncoding="GB18030"%>
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=GB18030">
</head>
<body>
    ${loginForm.username },用户登录成功！
</body>
</html>
1-7.          创建com.bjsxt.usermgr.action，并创建LoginAction.java
public class LoginAction extends Action {
    public ActionForward execute(ActionMapping mapping, ActionForm form,
            HttpServletRequest request, HttpServletResponse response)
            throws Exception {
        LoginActionForm laf = (LoginActionForm)form;
//      UserManager userManager = new UserManagerImpl();
//      userManager.login(laf.getUsername(), laf.getPassword());
        //从IOC容器中获取BeanFactory
//      BeanFactory factory =
new ClassPathXmlApplicationContext("applicationContext-beans.xml");
//      UserManager userManager = (UserManager) factory.getBean("userManager");
//      userManager.login(laf.getUsername(), laf.getPassword());
        //通过spring提供的帮助类获取BeanFactory
        BeanFactory factory = WebApplicationContextUtils.
getRequiredWebApplicationContext(request.getSession().getServletContext());
//      ApplicationContext ac = WebApplicationContextUtils.
getRequiredWebApplicationContext(request.getSession().getServletContext());
        UserManager userManager = (UserManager) factory.getBean("userManager");
        userManager.login(laf.getUsername(), laf.getPassword());
        return mapping.findForward("success");
       }
}
B.        Spring与Struts集成_第二种方案（依赖注入）
 Copyright ©2011 lyt. All Rights Reserved.
 
 
 
 
java核心技术学习
spring源码解析

1.1 Spring源代码解析(一）：IOC容器
在Spring中，IOC容器的重要地位我们就不多说了，对于Spring的使用者而言，IOC容器实际上是什么呢？我们可以说BeanFactory就是
我们看到的IoC容器，当然了Spring为我们准备了许多种IoC容器来使用，这样可以方便我们从不同的层面，不同的资源位置，不同的形
式的定义信息来建立我们需要的IoC容器。
在Spring中，最基本的IOC容器接口是BeanFactory - 这个接口为具体的IOC容器的实现作了最基本的功能规定 - 不管怎么着，作为IOC容
器，这些接口你必须要满足应用程序的最基本要求：
public interface BeanFactory {
//这里是对FactoryBean的转义定义，因为如果使用bean的名字检索FactoryBean得到的对象是工厂生成的对象，
//如果需要得到工厂本身，需要转义
String FACTORY_BEAN_PREFIX = "&";
//这里根据bean的名字，在IOC容器中得到bean实例，这个IOC容器就是一个大的抽象工厂。
Object getBean(String name) throws BeansException;
//这里根据bean的名字和Class类型来得到bean实例，和上面的方法不同在于它会抛出异常：如果根据名字取得的bean实例的Class类型和需要的Object getBean(String name, Class requiredType) throws BeansException;
//这里提供对bean的检索，看看是否在IOC容器有这个名字的bean
boolean containsBean(String name);
//这里根据bean名字得到bean实例，并同时判断这个bean是不是单件
boolean isSingleton(String name) throws NoSuchBeanDefinitionException;
//这里对得到bean实例的Class类型
Class getType(String name) throws NoSuchBeanDefinitionException;
//这里得到bean的别名，如果根据别名检索，那么其原名也会被检索出来
String[] getAliases(String name);
}
在BeanFactory里只对IOC容器的基本行为作了定义，根本不关心你的bean是怎样定义怎样加载的 - 就像我们只关心从这个工厂里我们
得到到什么产品对象，至于工厂是怎么生产这些对象的，这个基本的接口不关心这些。如果要关心工厂是怎样产生对象的，应用程序
需要使用具体的IOC容器实现- 当然你可以自己根据这个BeanFactory来实现自己的IOC容器，但这个没有必要，因为Spring已经为我们准备好了一系列工厂来让我们使用。比如XmlBeanFactory就是针对最基础的BeanFactory的IOC容器的实现 - 这个实现使用xml来定义IOC容器中的bean。
Spring提供了一个BeanFactory的基本实现，XmlBeanFactory同样的通过使用模板模式来得到对IOC容器的抽象-
AbstractBeanFactory,DefaultListableBeanFactory这些抽象类为其提供模板服务。其中通过resource 接口来抽象bean定义数据，对Xml
定义文件的解析通过委托给XmlBeanDefinitionReader来完成。下面我们根据书上的例子，简单的演示IOC容器的创建过程：
ClassPathResource res = new ClassPathResource("beans.xml");
DefaultListableBeanFactory factory = new DefaultListableBeanFactory();
XmlBeanDefinitionReader reader = new XmlBeanDefinitionReader(factory);
reader.loadBeanDefinitions(res);
这些代码演示了以下几个步骤：
1. 创建IOC配置文件的抽象资源
2. 创建一个BeanFactory
3. 把读取配置信息的BeanDefinitionReader,这里是XmlBeanDefinitionReader配置给BeanFactory
4. 从定义好的资源位置读入配置信息，具体的解析过程由XmlBeanDefinitionReader来完成，这样完成整个载入bean定义的过程。我
们的IoC容器就建立起来了。在BeanFactory的源代码中我们可以看到：
public class XmlBeanFactory extends DefaultListableBeanFactory {
//这里为容器定义了一个默认使用的bean定义读取器
private final XmlBeanDefinitionReader reader = new XmlBeanDefinitionReader(this);
public XmlBeanFactory(Resource resource) throws BeansException {
this(resource, null);
}
//在初始化函数中使用读取器来对资源进行读取，得到bean定义信息。
public XmlBeanFactory(Resource resource, BeanFactory parentBeanFactory) throws BeansException {
super(parentBeanFactory);
this.reader.loadBeanDefinitions(resource);
}
我们在后面会看到读取器读取资源和注册bean定义信息的整个过程，基本上是和上下文的处理是一样的，从这里我们可以看到上下文
和 XmlBeanFactory这两种IOC容器的区别，BeanFactory往往不具备对资源定义的能力，而上下文可以自己完成资源定义，从这个角度
上看上下文更好用一些。
仔细分析Spring BeanFactory的结构，我们来看看在BeanFactory基础上扩展出的ApplicationContext - 我们最常使用的上下文。除了具备
BeanFactory的全部能力，上下文为应用程序又增添了许多便利：
* 可以支持不同的信息源，我们看到ApplicationContext扩展了MessageSource
* 访问资源 , 体现在对ResourceLoader和Resource的支持上面，这样我们可以从不同地方得到bean定义资源
* 支持应用事件，继承了接口ApplicationEventPublisher,这样在上下文中引入了事件机制而BeanFactory是没有的。
ApplicationContext允许上下文嵌套 - 通过保持父上下文可以维持一个上下文体系 - 这个体系我们在以后对Web容器中的上下文环境的分析中可以清楚地看到。对于bean的查找可以在这个上下文体系中发生，首先检查当前上下文，其次是父上下文，逐级向上，这样为
不同的Spring应用提供了一个共享的bean定义环境。这个我们在分析Web容器中的上下文环境时也能看到。
ApplicationContext提供IoC容器的主要接口，在其体系中有许多抽象子类比如AbstractApplicationContext为具体的BeanFactory的实现，
比如FileSystemXmlApplicationContext和 ClassPathXmlApplicationContext提供上下文的模板，使得他们只需要关心具体的资源定位问
题。当应用程序代码实例化 FileSystemXmlApplicationContext的时候，得到IoC容器的一种具体表现 - ApplicationContext，从而应用程
序通过ApplicationContext来管理对bean的操作。
BeanFactory 是一个接口，在实际应用中我们一般使用ApplicationContext来使用IOC容器，它们也是IOC容器展现给应用开发者的使用
接口。对应用程序开发者来说，可以认为BeanFactory和ApplicationFactory在不同的使用层面上代表了SPRING提供的IOC容器服务。
下面我们具体看看通过FileSystemXmlApplicationContext是怎样建立起IOC容器的, 显而易见我们可以通过new来得到IoC容器：
ApplicationContext = new FileSystemXmlApplicationContext(xmlPath);
调用的是它初始化代码：
public FileSystemXmlApplicationContext(String[] configLocations, boolean refresh, ApplicationContext parent)
throws BeansException {
super(parent);
this.configLocations = configLocations;
if (refresh) {
　//这里是IoC容器的初始化过程，其初始化过程的大致步骤由AbstractApplicationContext来定义
refresh();
}
}
refresh的模板在AbstractApplicationContext:
public void refresh() throws BeansException, IllegalStateException {
synchronized (this.startupShutdownMonitor) {
synchronized (this.activeMonitor) {
this.active = true;
}
// 这里需要子类来协助完成资源位置定义,bean载入和向IOC容器注册的过程
refreshBeanFactory();
............
}
这个方法包含了整个BeanFactory初始化的过程，对于特定的FileSystemXmlBeanFactory,我们看到定位资源位置由refreshBeanFactory()
来实现：
在AbstractXmlApplicationContext中定义了对资源的读取过程，默认由XmlBeanDefinitionReader来读取：
protected void loadBeanDefinitions(DefaultListableBeanFactory beanFactory) throws IOException {
// 这里使用XMLBeanDefinitionReader来载入bean定义信息的XML文件
XmlBeanDefinitionReader beanDefinitionReader = new XmlBeanDefinitionReader(beanFactory);
//这里配置reader的环境，其中ResourceLoader是我们用来定位bean定义信息资源位置的
///因为上下文本身实现了ResourceLoader接口，所以可以直接把上下文作为ResourceLoader传递给XmlBeanDefinitionReader
beanDefinitionReader.setResourceLoader(this);
beanDefinitionReader.setEntityResolver(new ResourceEntityResolver(this));
initBeanDefinitionReader(beanDefinitionReader);
//这里转到定义好的XmlBeanDefinitionReader中对载入bean信息进行处理
loadBeanDefinitions(beanDefinitionReader);
}
转到beanDefinitionReader中进行处理：
protected void loadBeanDefinitions(XmlBeanDefinitionReader reader) throws BeansException, IOException {
Resource[] configResources = getConfigResources();
if (configResources != null) {
//调用XmlBeanDefinitionReader来载入bean定义信息。
reader.loadBeanDefinitions(configResources);
}
String[] configLocations = getConfigLocations();
if (configLocations != null) {
reader.loadBeanDefinitions(configLocations);
}
}
而在作为其抽象父类的AbstractBeanDefinitionReader中来定义载入过程：
public int loadBeanDefinitions(String location) throws BeanDefinitionStoreException {
//这里得到当前定义的ResourceLoader,默认的我们使用DefaultResourceLoader
ResourceLoader resourceLoader = getResourceLoader();
.........//如果没有找到我们需要的ResourceLoader，直接抛出异常
if (resourceLoader instanceof ResourcePatternResolver) {
// 这里处理我们在定义位置时使用的各种pattern,需要ResourcePatternResolver来完成
try {
Resource[] resources = ((ResourcePatternResolver) resourceLoader).getResources(location);
int loadCount = loadBeanDefinitions(resources);
return loadCount;
}
........
}
else {
// 这里通过ResourceLoader来完成位置定位
Resource resource = resourceLoader.getResource(location);
// 这里已经把一个位置定义转化为Resource接口，可以供XmlBeanDefinitionReader来使用了
int loadCount = loadBeanDefinitions(resource);
return loadCount;
}
}
当我们通过ResourceLoader来载入资源，别忘了了我们的GenericApplicationContext也实现了ResourceLoader接口：
public class GenericApplicationContext extends AbstractApplicationContext implements BeanDefinitionRegistry {
public Resource getResource(String location) {
//这里调用当前的loader也就是DefaultResourceLoader来完成载入
if (this.resourceLoader != null) {
return this.resourceLoader.getResource(location);
}
return super.getResource(location);
}
.......
}
而我们的FileSystemXmlApplicationContext就是一个DefaultResourceLoader - GenericApplicationContext()通过DefaultResourceLoader:
public Resource getResource(String location) {
//如果是类路径的方式，那需要使用ClassPathResource来得到bean文件的资源对象
if (location.startsWith(CLASSPATH_URL_PREFIX)) {
return new ClassPathResource(location.substring(CLASSPATH_URL_PREFIX.length()), getClassLoader());
}
else {
try {
// 如果是URL方式，使用UrlResource作为bean文件的资源对象
URL url = new URL(location);
return new UrlResource(url);
}
catch (MalformedURLException ex) {
// 如果都不是，那我们只能委托给子类由子类来决定使用什么样的资源对象了
return getResourceByPath(location);
}
}
}
我们的FileSystemXmlApplicationContext本身就是是DefaultResourceLoader的实现类，他实现了以下的接口：
protected Resource getResourceByPath(String path) {
if (path != null && path.startsWith("/")) {
path = path.substring(1);
}
//这里使用文件系统资源对象来定义bean文件
return new FileSystemResource(path);
}
这样代码就回到了FileSystemXmlApplicationContext中来，他提供了FileSystemResource来完成从文件系统得到配置文件的资源定义。
这样，就可以从文件系统路径上对IOC配置文件进行加载 - 当然我们可以按照这个逻辑从任何地方加载，在Spring中我们看到它提供的
各种资源抽象，比如ClassPathResource, URLResource,FileSystemResource等来供我们使用。上面我们看到的是定位Resource的一个
过程，而这只是加载过程的一部分 - 我们回到AbstractBeanDefinitionReaderz中的loadDefinitions(resource)来看看得到代表bean文件的
资源定义以后的载入过程,默认的我们使用XmlBeanDefinitionReader：
public int loadBeanDefinitions(EncodedResource encodedResource) throws BeanDefinitionStoreException {
.......
try {
//这里通过Resource得到InputStream的IO流
InputStream inputStream = encodedResource.getResource().getInputStream();
try {
//从InputStream中得到XML的解析源
InputSource inputSource = new InputSource(inputStream);
if (encodedResource.getEncoding() != null) {
inputSource.setEncoding(encodedResource.getEncoding());
}
//这里是具体的解析和注册过程
return doLoadBeanDefinitions(inputSource, encodedResource.getResource());
}
finally {
//关闭从Resource中得到的IO流
inputStream.close();
}
}
.........
}第 8 / 90 页
protected int doLoadBeanDefinitions(InputSource inputSource, Resource resource)
throws BeanDefinitionStoreException {
try {
int validationMode = getValidationModeForResource(resource);
//通过解析得到DOM，然后完成bean在IOC容器中的注册
Document doc = this.documentLoader.loadDocument(
inputSource, this.entityResolver, this.errorHandler, validationMode, this.namespaceAware);
return registerBeanDefinitions(doc, resource);
}
.......
}
我们看到先把定义文件解析为DOM对象，然后进行具体的注册过程：
public int registerBeanDefinitions(Document doc, Resource resource) throws BeanDefinitionStoreException {
// 这里定义解析器，使用XmlBeanDefinitionParser来解析xml方式的bean定义文件 - 现在的版本不用这个解析器了，使用的是XmlBeanDefinitionReader
if (this.parserClass != null) {
XmlBeanDefinitionParser parser =
(XmlBeanDefinitionParser) BeanUtils.instantiateClass(this.parserClass);
return parser.registerBeanDefinitions(this, doc, resource);
}
// 具体的注册过程,首先得到XmlBeanDefinitionReader,来处理xml的bean定义文件
BeanDefinitionDocumentReader documentReader = createBeanDefinitionDocumentReader();
int countBefore = getBeanFactory().getBeanDefinitionCount();
documentReader.registerBeanDefinitions(doc, createReaderContext(resource));
return getBeanFactory().getBeanDefinitionCount() - countBefore;
}
具体的在BeanDefinitionDocumentReader中完成对，下面是一个简要的注册过程来完成bean定义文件的解析和IOC容器中bean的初始
化
public void registerBeanDefinitions(Document doc, XmlReaderContext readerContext) {
this.readerContext = readerContext;
logger.debug("Loading bean definitions");
Element root = doc.getDocumentElement();
BeanDefinitionParserDelegate delegate = createHelper(readerContext, root);
preProcessXml(root);
parseBeanDefinitions(root, delegate);
postProcessXml(root);
}
protected void parseBeanDefinitions(Element root, BeanDefinitionParserDelegate delegate) {
if (delegate.isDefaultNamespace(root.getNamespaceURI())) {
//这里得到xml文件的子节点，比如各个bean节点
NodeList nl = root.getChildNodes();
//这里对每个节点进行分析处理
for (int i = 0; i < nl.getLength(); i++) {
Node node = nl.item(i);
if (node instanceof Element) {
Element ele = (Element) node;
String namespaceUri = ele.getNamespaceURI();
if (delegate.isDefaultNamespace(namespaceUri)) {
//这里是解析过程的调用，对缺省的元素进行分析比如bean元素
parseDefaultElement(ele, delegate);
}
else {
delegate.parseCustomElement(ele);
}
}
}
} else {
delegate.parseCustomElement(root);
}
}
private void parseDefaultElement(Element ele, BeanDefinitionParserDelegate delegate) {
//这里对元素Import进行处理
if (DomUtils.nodeNameEquals(ele, IMPORT_ELEMENT)) {
importBeanDefinitionResource(ele);
}
else if (DomUtils.nodeNameEquals(ele, ALIAS_ELEMENT)) {
String name = ele.getAttribute(NAME_ATTRIBUTE);
String alias = ele.getAttribute(ALIAS_ATTRIBUTE);
getReaderContext().getReader().getBeanFactory().registerAlias(name, alias);
getReaderContext().fireAliasRegistered(name, alias, extractSource(ele));
}
//这里对我们最熟悉的bean元素进行处理
else if (DomUtils.nodeNameEquals(ele, BEAN_ELEMENT)) {
//委托给BeanDefinitionParserDelegate来完成对bean元素的处理，这个类包含了具体的bean解析的过程。
// 把解析bean文件得到的信息放到BeanDefinition里，他是bean信息的主要载体，也是IOC容器的管理对象。
BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);
if (bdHolder != null) {
bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);
// 这里是向IOC容器注册，实际上是放到IOC容器的一个map里
BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());
// 这里向IOC容器发送事件，表示解析和注册完成。
getReaderContext().fireComponentRegistered(new BeanComponentDefinition(bdHolder));
}
}
}
我们看到在parseBeanDefinition中对具体bean元素的解析式交给BeanDefinitionParserDelegate来完成的，下面我们看看解析完的bean
是怎样在IOC容器中注册的：
在BeanDefinitionReaderUtils调用的是：
public static void registerBeanDefinition(
BeanDefinitionHolder bdHolder, BeanDefinitionRegistry beanFactory) throws BeansException {
// 这里得到需要注册bean的名字；
String beanName = bdHolder.getBeanName();
//这是调用IOC来注册的bean的过程，需要得到BeanDefinition
beanFactory.registerBeanDefinition(beanName, bdHolder.getBeanDefinition());
// 别名也是可以通过IOC容器和bean联系起来的进行注册
String[] aliases = bdHolder.getAliases();
if (aliases != null) {
for (int i = 0; i < aliases.length; i++) {
beanFactory.registerAlias(beanName, aliases[i]);
}
}
}
我们看看XmlBeanFactory中的注册实现：
//---------------------------------------------------------------------
// 这里是IOC容器对BeanDefinitionRegistry接口的实现
//---------------------------------------------------------------------
public void registerBeanDefinition(String beanName, BeanDefinition beanDefinition)
throws BeanDefinitionStoreException {
.....//这里省略了对BeanDefinition的验证过程
//先看看在容器里是不是已经有了同名的bean,如果有抛出异常。
Object oldBeanDefinition = this.beanDefinitionMap.get(beanName);
if (oldBeanDefinition != null) {
if (!this.allowBeanDefinitionOverriding) {
...........
}
else {
//把bean的名字加到IOC容器中去
this.beanDefinitionNames.add(beanName);
}
//这里把bean的名字和Bean定义联系起来放到一个HashMap中去,IOC容器通过这个Map来维护容器里的Bean定义信息。
this.beanDefinitionMap.put(beanName, beanDefinition);
removeSingleton(beanName);
}
这样就完成了Bean定义在IOC容器中的注册，就可被IOC容器进行管理和使用了。
从上面的代码来看，我们总结一下IOC容器初始化的基本步骤：
* 初始化的入口在容器实现中的refresh()调用来完成
* 对bean 定义载入IOC容器使用的方法是loadBeanDefinition,其中的大致过程如下：通过ResourceLoader来完成资源文件位置的定
位，DefaultResourceLoader是默认的实现，同时上下文本身就给出了ResourceLoader的实现，可以从类路径，文件系统, URL等方式来
定为资源位置。如果是XmlBeanFactory作为IOC容器，那么需要为它指定bean定义的资源，也就是说bean定义文件时通过抽象成
Resource来被IOC容器处理的，容器通过BeanDefinitionReader来完成定义信息的解析和Bean信息的注册,往往使用的是
XmlBeanDefinitionReader来解析bean的xml定义文件 - 实际的处理过程是委托给BeanDefinitionParserDelegate来完成的，从而得到
bean的定义信息，这些信息在Spring中使用BeanDefinition对象来表示 - 这个名字可以让我们想到
loadBeanDefinition,RegisterBeanDefinition这些相关的方法 - 他们都是为处理BeanDefinitin服务的，IoC容器解析得到BeanDefinition以
后，需要把它在IOC容器中注册，这由IOC实现 BeanDefinitionRegistry接口来实现。注册过程就是在IOC容器内部维护的一个HashMap
来保存得到的 BeanDefinition的过程。这个HashMap是IoC容器持有bean信息的场所，以后对bean的操作都是围绕这个HashMap来实现
的。
* 然后我们就可以通过BeanFactory和ApplicationContext来享受到Spring IOC的服务了.
在使用IOC容器的时候，我们注意到除了少量粘合代码，绝大多数以正确IoC风格编写的应用程序代码完全不用关心如何到达工厂，因
为容器将把这些对象与容器管理的其他对象钩在一起。基本的策略是把工厂放到已知的地方，最好是放在对预期使用的上下文有意义
的地方，以及代码将实际需要访问工厂的地方。 Spring本身提供了对声明式载入web应用程序用法的应用程序上下文，并将其存储在
ServletContext中的框架实现。具体可以参见以后的文章。
在使用Spring IOC容器的时候我们还需要区别两个概念：
Beanfactory 和Factory bean，其中BeanFactory指的是IOC容器的编程抽象，比如ApplicationContext， XmlBeanFactory等，这些都是IOC
容器的具体表现，需要使用什么样的容器由客户决定但Spring为我们提供了丰富的选择。而 FactoryBean只是一个可以在IOC容器中被
管理的一个bean,是对各种处理过程和资源使用的抽象,Factory bean在需要时产生另一个对象，而不返回FactoryBean本省，我们可以把
它看成是一个抽象工厂，对它的调用返回的是工厂生产的产品。所有的 Factory bean都实现特殊的
org.springframework.beans.factory.FactoryBean接口，当使用容器中factory bean的时候，该容器不会返回factory bean本身，而是返回
其生成的对象。Spring包括了大部分的通用资源和服务访问抽象的Factory bean的实现，其中包括：
对JNDI查询的处理，对代理对象的处理，对事务性代理的处理，对RMI代理的处理等，这些我们都可以看成是具体的工厂，看成是
SPRING为我们建立好的工厂。也就是说Spring通过使用抽象工厂模式为我们准备了一系列工厂来生产一些特定的对象，免除我们手工
重复的工作，我们要使用时只需要在IOC容器里配置好就能很方便的使用了。
现在我们来看看在Spring的事件机制，Spring中有3个标准事件，ContextRefreshEvent, ContextCloseEvent,RequestHandledEvent他们
通过ApplicationEvent接口，同样的如果需要自定义时间也只需要实现ApplicationEvent接口，参照ContextCloseEvent的实现可以定制自
己的事件实现：
public class ContextClosedEvent extends ApplicationEvent {
public ContextClosedEvent(ApplicationContext source) {
super(source);
}
public ApplicationContext getApplicationContext() {
return (ApplicationContext) getSource();
}
}
可以通过显现ApplicationEventPublishAware接口，将事件发布器耦合到ApplicationContext这样可以使用 ApplicationContext框架来传递
和消费消息,然后在ApplicationContext中配置好bean就可以了，在消费消息的过程中，接受者通过实现ApplicationListener接收消息。
比如可以直接使用Spring的ScheduleTimerTask和TimerFactoryBean作为定时器定时产生消息，具体可以参见《Spring框架高级编
程》。
TimerFactoryBean是一个工厂bean，对其中的ScheduleTimerTask进行处理后输出，参考ScheduleTimerTask的实现发现它最后调用的
是jre的TimerTask：
public void setRunnable(Runnable timerTask) {
this.timerTask = new DelegatingTimerTask(timerTask);
}
在书中给出了一个定时发送消息的例子，当然可以可以通过定时器作其他的动作，有两种方法：
1.定义MethodInvokingTimerTaskFactoryBean定义要执行的特定bean的特定方法，对需要做什么进行封装定义；
2.定义TimerTask类，通过extends TimerTask来得到，同时对需要做什么进行自定义
然后需要定义具体的定时器参数，通过配置ScheduledTimerTask中的参数和timerTask来完成，以下是它需要定义的具体属性，
timerTask是在前面已经定义好的bean
private TimerTask timerTask;
private long delay = 0;
private long period = 0;
private boolean fixedRate = false;
最后，需要在ApplicationContext中注册，需要把ScheduledTimerTask配置到FactoryBean - TimerFactoryBean，这样就由IOC容器来管理
定时器了。参照
TimerFactoryBean的属性，可以定制一组定时器。
public class TimerFactoryBean implements FactoryBean, InitializingBean, DisposableBean {
protected final Log logger = LogFactory.getLog(getClass());
private ScheduledTimerTask[] scheduledTimerTasks;
private boolean daemon = false;
private Timer timer;
...........
}
如果要发送时间我们只需要在定义好的ScheduledTimerTasks中publish定义好的事件就可以了。具体可以参考书中例子的实现，这里只
是结合FactoryBean的原理做一些解释。如果结合事件和定时器机制，我们可以很方便的实现heartbeat(看门狗），书中给出了这个例
子，这个例子实际上结合了Spring事件和定时机制的使用两个方面的知识 - 当然了还有IOC容器的知识（任何Spring应用我想都逃不掉
IOC的魔爪：）
1.2 Spring源代码解析(二)：IoC容器在Web容器中的启动
发表时间: 2007-06-04
以下引用自博客：http://jiwenke-spring.blogspot.com/
上面我们分析了IOC容器本身的实现，下面我们看看在典型的web环境中，Spring IOC容器是怎样被载入和起作用的。
简单的说，在web容器中，通过ServletContext为Spring的IOC容器提供宿主环境，对应的建立起一个IOC容器的体系。其中，首先需要
建立的是根上下文，这个上下文持有的对象可以有业务对象，数据存取对象，资源，事物管理器等各种中间层对象。在这个上下文的
基础上，和web MVC相关还会有一个上下文来保存控制器之类的MVC对象，这样就构成了一个层次化的上下文结构。在web容器中启
动Spring应用程序就是一个建立这个上下文体系的过程。Spring为web应用提供了上下文的扩展接口
WebApplicationContext:
public interface WebApplicationContext extends ApplicationContext {
//这里定义的常量用于在ServletContext中存取根上下文
String ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE = WebApplicationContext.class.getName() + ".ROOT";
......
//对WebApplicationContext来说，需要得到Web容器的ServletContext
ServletContext getServletContext();
}
而一般的启动过程，Spring会使用一个默认的实现，XmlWebApplicationContext - 这个上下文实现作为在web容器中的根上下文容器被
建立起来，具体的建立过程在下面我们会详细分析。
public class XmlWebApplicationContext extends AbstractRefreshableWebApplicationContext {
/** 这是和web部署相关的位置信息，用来作为默认的根上下文bean定义信息的存放位置*/
public static final String DEFAULT_CONFIG_LOCATION = "/WEB-INF/applicationContext.xml";
public static final String DEFAULT_CONFIG_LOCATION_PREFIX = "/WEB-INF/";
public static final String DEFAULT_CONFIG_LOCATION_SUFFIX = ".xml";
//我们又看到了熟悉的loadBeanDefinition,就像我们前面对IOC容器的分析中一样，这个加载工程在容器的refresh()的时候启动。
protected void loadBeanDefinitions(DefaultListableBeanFactory beanFactory) throws IOException {
//对于XmlWebApplicationContext,当然使用的是XmlBeanDefinitionReader来对bean定义信息来进行解析
XmlBeanDefinitionReader beanDefinitionReader = new XmlBeanDefinitionReader(beanFactory);
beanDefinitionReader.setResourceLoader(this);
beanDefinitionReader.setEntityResolver(new ResourceEntityResolver(this));
initBeanDefinitionReader(beanDefinitionReader);
loadBeanDefinitions(beanDefinitionReader);
}
protected void initBeanDefinitionReader(XmlBeanDefinitionReader beanDefinitionReader) {
}
//使用XmlBeanDefinitionReader来读入bean定义信息
protected void loadBeanDefinitions(XmlBeanDefinitionReader reader) throws BeansException, IOException {
String[] configLocations = getConfigLocations();
if (configLocations != null) {
for (int i = 0; i < configLocations.length; i++) {
reader.loadBeanDefinitions(configLocations[i]);
}
}
}
//这里取得bean定义信息位置，默认的地方是/WEB-INF/applicationContext.xml
protected String[] getDefaultConfigLocations() {
if (getNamespace() != null) {
return new String[] {DEFAULT_CONFIG_LOCATION_PREFIX + getNamespace() + DEFAULT_CONFIG_LOCATION_SUFFIX};
}
else {
return new String[] {DEFAULT_CONFIG_LOCATION};
}
}
}
对于一个Spring激活的web应用程序，可以通过使用Spring代码声明式的指定在web应用程序启动时载入应用程序上下文
（WebApplicationContext),Spring的ContextLoader是提供这样性能的类，我们可以使用 ContextLoaderServlet或者
ContextLoaderListener的启动时载入的Servlet来实例化Spring IOC容器 - 为什么会有两个不同的类来装载它呢，这是因为它们的使用需
要区别不同的Servlet容器支持的Serlvet版本。但不管是 ContextLoaderSevlet还是 ContextLoaderListener都使用ContextLoader来完成实
际的WebApplicationContext的初始化工作。这个ContextLoder就像是Spring Web应用程序在Web容器中的加载器booter。当然这些
Servlet的具体使用我们都要借助web容器中的部署描述符来进行相关的定义。
下面我们使用ContextLoaderListener作为载入器作一个详细的分析，这个Servlet的监听器是根上下文被载入的地方，也是整个
Spring　web应用加载上下文的第一个地方；从加载过程我们可以看到，首先从Servlet事件中得到ServletContext，然后可以读到配置
好的在web.xml的中的各个属性值，然后ContextLoder实例化WebApplicationContext并完成其载入和初始化作为根上下文。当这个根上
下文被载入后，它被绑定到web应用程序的ServletContext上。任何需要访问该ApplicationContext的应用程序代码都可以从
WebApplicationContextUtils类的静态方法来得到：
WebApplicationContext getWebApplicationContext(ServletContext sc)
以Tomcat作为Servlet容器为例，下面是具体的步骤：
1.Tomcat 启动时需要从web.xml中读取启动参数，在web.xml中我们需要对ContextLoaderListener进行配置，对于在web应用启动入口
是在ContextLoaderListener中的初始化部分；从Spring MVC上看，实际上在web容器中维护了一系列的IOC容器，其中在ContextLoader
中载入的IOC容器作为根上下文而存在于 ServletContext中。
//这里对根上下文进行初始化。
public void contextInitialized(ServletContextEvent event) {
//这里创建需要的ContextLoader
this.contextLoader = createContextLoader();
//这里使用ContextLoader对根上下文进行载入和初始化
this.contextLoader.initWebApplicationContext(event.getServletContext());
}
通过ContextLoader建立起根上下文的过程,我们可以在ContextLoader中看到：
public WebApplicationContext initWebApplicationContext(ServletContext servletContext)
throws IllegalStateException, BeansException {
//这里先看看是不是已经在ServletContext中存在上下文,如果有说明前面已经被载入过，或者是配置文件有错误。
if (servletContext.getAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE) != null) {
//直接抛出异常
.........
}
...............
try {
// 这里载入根上下文的父上下文
ApplicationContext parent = loadParentContext(servletContext);
//这里创建根上下文作为整个应用的上下文同时把它存到ServletContext中去,注意这里使用的ServletContext的属性值是
//ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE，以后的应用都是根据这个属性值来取得根上下文的 - 往往作为自己上下文的父上下文
this.context = createWebApplicationContext(servletContext, parent);
servletContext.setAttribute(
WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, this.context);
..........
return this.context;
}
............
}
建立根上下文的父上下文使用的是下面的代码，取决于在web.xml中定义的参数：locatorFactorySelector，这是一个可选参数：
protected ApplicationContext loadParentContext(ServletContext servletContext)
throws BeansException {
ApplicationContext parentContext = null;
String locatorFactorySelector = servletContext.getInitParameter(LOCATOR_FACTORY_SELECTOR_PARAM);
String parentContextKey = servletContext.getInitParameter(LOCATOR_FACTORY_KEY_PARAM);
if (locatorFactorySelector != null) {
BeanFactoryLocator locator = ContextSingletonBeanFactoryLocator.getInstance(locatorFactorySelector);
........
//得到根上下文的父上下文的引用
this.parentContextRef = locator.useBeanFactory(parentContextKey);
//这里建立得到根上下文的父上下文
parentContext = (ApplicationContext) this.parentContextRef.getFactory();
}
return parentContext;
}
得到根上下文的父上下文以后，就是根上下文的创建过程：
protected WebApplicationContext createWebApplicationContext(
ServletContext servletContext, ApplicationContext parent) throws BeansException {
//这里需要确定我们载入的根WebApplication的类型，由在web.xml中配置的contextClass中配置的参数可以决定我们需要载入什么样的ApplicationContext,
//如果没有使用默认的。
Class contextClass = determineContextClass(servletContext);
.........
//这里就是上下文的创建过程
ConfigurableWebApplicationContext wac =
(ConfigurableWebApplicationContext) BeanUtils.instantiateClass(contextClass);
//这里保持对父上下文和ServletContext的引用到根上下文中
wac.setParent(parent);
wac.setServletContext(servletContext);
//这里从web.xml中取得相关的初始化参数
String configLocation = servletContext.getInitParameter(CONFIG_LOCATION_PARAM);
if (configLocation != null) {
wac.setConfigLocations(StringUtils.tokenizeToStringArray(configLocation,
ConfigurableWebApplicationContext.CONFIG_LOCATION_DELIMITERS));
}
//这里对WebApplicationContext进行初始化，我们又看到了熟悉的refresh调用。
wac.refresh();
return wac;
}
初始化根ApplicationContext后将其存储到SevletContext中去以后,这样就建立了一个全局的关于整个应用的上下文。这个根上下文会被
以后的DispatcherServlet初始化自己的时候作为自己ApplicationContext的父上下文。这个在对 DispatcherServlet做分析的时候我们可
以看看到。
3.完成对ContextLoaderListener的初始化以后， Tomcat开始初始化DispatchServlet，- 还记得我们在web.xml中队载入次序进行了定
义。DispatcherServlet会建立自己的ApplicationContext,同时建立这个自己的上下文的时候会从ServletContext中得到根上下文作为父上
下文,然后再对自己的上下文进行初始化，并最后存到 ServletContext中去供以后检索和使用。
可以从DispatchServlet的父类FrameworkServlet的代码中看到大致的初始化过程，整个ApplicationContext的创建过程和ContextLoder创
建的过程相类似：
protected final void initServletBean() throws ServletException, BeansException {
.........
try {
//这里是对上下文的初始化过程。
this.webApplicationContext = initWebApplicationContext();
//在完成对上下文的初始化过程结束后，根据bean配置信息建立MVC框架的各个主要元素
initFrameworkServlet();
}
........
}
对initWebApplicationContext()调用的代码如下：
protected WebApplicationContext initWebApplicationContext() throws BeansException {
//这里调用WebApplicationContextUtils静态类来得到根上下文
WebApplicationContext parent = WebApplicationContextUtils.getWebApplicationContext(getServletContext());
//创建当前DispatcherServlet的上下文，其上下文种类使用默认的在FrameworkServlet定义好的：DEFAULT_CONTEXT_CLASS = XmlWebApplicationContext.WebApplicationContext wac = createWebApplicationContext(parent);
........
if (isPublishContext()) {
//把当前建立的上下文存到ServletContext中去，注意使用的属性名是和当前Servlet名相关的。
String attrName = getServletContextAttributeName();
getServletContext().setAttribute(attrName, wac);
}
return wac;
}
其中我们看到调用了WebApplicationContextUtils的静态方法得到根ApplicationContext:
public static WebApplicationContext getWebApplicationContext(ServletContext sc) {
//很简单，直接从ServletContext中通过属性名得到根上下文
Object attr = sc.getAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE);
.......
return (WebApplicationContext) attr;
}
然后创建DispatcherServlet自己的WebApplicationContext:
protected WebApplicationContext createWebApplicationContext(WebApplicationContext parent)
throws BeansException {
.......
//这里使用了BeanUtils直接得到WebApplicationContext,ContextClass是前面定义好的DEFAULT_CONTEXT_CLASS =
//XmlWebApplicationContext.class;
ConfigurableWebApplicationContext wac =
(ConfigurableWebApplicationContext) BeanUtils.instantiateClass(getContextClass());
//这里配置父上下文，就是在ContextLoader中建立的根上下文
wac.setParent(parent);
//保留ServletContext的引用和相关的配置信息。
wac.setServletContext(getServletContext());
wac.setServletConfig(getServletConfig());
wac.setNamespace(getNamespace());
//这里得到ApplicationContext配置文件的位置
if (getContextConfigLocation() != null) {
wac.setConfigLocations(
StringUtils.tokenizeToStringArray(
getContextConfigLocation(), ConfigurableWebApplicationContext.CONFIG_LOCATION_DELIMITERS));
}
//这里调用ApplicationContext的初始化过程，同样需要使用refresh()
wac.refresh();
return wac;
}
4. 然后就是DispatchServlet中对Spring MVC的配置过程，首先对配置文件中的定义元素进行配置 - 请注意这个时候我们的
WebApplicationContext已经建立起来了，也意味着DispatcherServlet有自己的定义资源，可以需要从web.xml中读取bean的配置信息，
通常我们会使用单独的xml文件来配置MVC中各个要素定义，这里和web容器相关的加载过程实际上已经完成了，下面的处理和普通的
Spring应用程序的编写没有什么太大的差别，我们先看看MVC的初始化过程：
protected void initFrameworkServlet() throws ServletException, BeansException {
initMultipartResolver();
initLocaleResolver();
initThemeResolver();
initHandlerMappings();
initHandlerAdapters();
initHandlerExceptionResolvers();
initRequestToViewNameTranslator();
initViewResolvers();
}
5. 这样MVC的框架就建立起来了，DispatchServlet对接受到的HTTP Request进行分发处理由doService()完成，具体的MVC处理过程我
们在doDispatch()中完成，其中包括使用Command模式建立执行链，显示模型数据等，这些处理我们都可以在DispatcherServlet的代码
中看到：
protected void doService(HttpServletRequest request, HttpServletResponse response) throws Exception {
......
try {
doDispatch(request, response);
}
.......
}
实际的请求分发由doDispatch(request,response)来完成：
protected void doDispatch(final HttpServletRequest request, HttpServletResponse response) throws Exception {
.......
// 这是Spring定义的执行链，里面放了映射关系对应的handler和定义的相关拦截器。
HandlerExecutionChain mappedHandler = null;
......
try {
//我们熟悉的ModelAndView在这里出现了。
ModelAndView mv = null;
try {
processedRequest = checkMultipart(request);
//这里更具request中的参数和映射关系定义决定使用的handler
mappedHandler = getHandler(processedRequest, false);
......
//这里是handler的调用过程，类似于Command模式中的execute.
HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());
mv = ha.handle(processedRequest, response, mappedHandler.getHandler());
.......
//这里将模型数据通过视图进行展现
if (mv != null && !mv.wasCleared()) {
render(mv, processedRequest, response);
}
........
}
这样具体的MVC模型的实现就由bean配置文件里定义好的view resolver,handler这些类来实现用户代码的功能。
总结上面的过程，我们看到在web容器中，ServletContext可以持有一系列的web上下文，而在整个web上下文中存在一个根上下文来作
为其它 Servlet上下文的父上下文。这个根上下文是由ContextLoader载入并进行初始化的，对于我们的web应用， DispatcherSerlvet载
入并初始化自己的上下文,这个上下文的父上下文是根上下文，并且我们也能从ServletContext中根据 Servlet的名字来检索到我们需要
的对应于这个Servlet的上下文，但是根上下文的名字是由Spring唯一确定的。这个 DispactcherServlet建立的上下文就是我们开发
Spring MVC应用的IOC容器。
具体的web请求处理在上下文体系建立完成以后由DispactcherServlet来完成，上面对MVC的运作做了一个大致的描述，下面我们会具
体就SpringMVC的框架实现作一个详细的分析。
1.3 Spring源代码解析(三）：Spring JDBC
发表时间: 2007-06-05
引用自博客：http://jiwenke-spring.blogspot.com/
下面我们看看Spring JDBC相关的实现，
在Spring中，JdbcTemplate是经常被使用的类来帮助用户程序操作数据库，在JdbcTemplate为用户程序提供了许多便利的数据库操作方
法，比如查询，更新等，而且在Spring中，有许多类似 JdbcTemplate的模板,比如HibernateTemplate等等 - 看来这是Rod.Johnson的惯
用手法，一般而言这种Template中都是通过回调函数CallBack类的使用来完成功能的，客户需要在回调接口中实现自己需要的定制行
为，比如使用客户想要用的SQL语句等。不过往往Spring通过这种回调函数的实现已经为我们提供了许多现成的方法供客户使用。一般
来说回调函数的用法采用匿名类的方式来实现，比如：
JdbcTemplate = new JdbcTemplate(datasource);
jdbcTemplate.execute(new CallBack(){
public CallbackInterfacedoInAction(){
......
//用户定义的代码或者说Spring替我们实现的代码
}
}
在模板中嵌入的是需要客户化的代码，由Spring来作或者需要客户程序亲自动手完成。下面让我们具体看看在JdbcTemplate中的代码是
怎样完成使命的，我们举JdbcTemplate.execute()为例，这个方法是在JdbcTemplate中被其他方法调用的基本方法之一，客户程序往往
用这个方法来执行基本的SQL语句：
public Object execute(ConnectionCallback action) throws DataAccessException {
//这里得到数据库联接
Connection con = DataSourceUtils.getConnection(getDataSource());
try {
Connection conToUse = con;
//有些特殊的数据库，需要我们使用特别的方法取得datasource
if (this.nativeJdbcExtractor != null) {
// Extract native JDBC Connection, castable to OracleConnection or the like.
conToUse = this.nativeJdbcExtractor.getNativeConnection(con);
}
else {
// Create close-suppressing Connection proxy, also preparing returned Statements.
conToUse = createConnectionProxy(con);
}
//这里调用的是传递进来的匿名类的方法，也就是用户程序需要实现CallBack接口的地方。
return action.doInConnection(conToUse);
}
catch (SQLException ex) {
//如果捕捉到数据库异常，把数据库联接释放，同时抛出一个经过Spring转换过的Spring数据库异常，
//我们知道，Spring做了一个有意义的工作是把这些数据库异常统一到自己的异常体系里了。
DataSourceUtils.releaseConnection(con, getDataSource());
con = null;
throw getExceptionTranslator().translate("ConnectionCallback", getSql(action), ex);
}
finally {
//最后不管怎样都会把数据库连接释放
DataSourceUtils.releaseConnection(con, getDataSource());
}
}
对于JdbcTemplate中给出的其他方法，比如query,update,execute等的实现，我们看看query()：
public Object query(PreparedStatementCreator psc, final PreparedStatementSetter pss, final ResultSetExtractor rse)
throws DataAccessException {
..........
//这里调用了我们上面看到的execute()基本方法,然而这里的回调实现是Spring为我们完成的查询过程
return execute(psc, new PreparedStatementCallback() {
public Object doInPreparedStatement(PreparedStatement ps) throws SQLException {
//准备查询结果集
ResultSet rs = null;
try {
//这里配置SQL参数
if (pss != null) {
pss.setValues(ps);
}
//这里执行的SQL查询
rs = ps.executeQuery();
ResultSet rsToUse = rs;
if (nativeJdbcExtractor != null) {
rsToUse = nativeJdbcExtractor.getNativeResultSet(rs);
}
//返回需要的记录集合
return rse.extractData(rsToUse);
}
finally {
//最后关闭查询的纪录集，对数据库连接的释放在execute()中释放，就像我们在上面分析的看到那样。
JdbcUtils.closeResultSet(rs);
if (pss instanceof ParameterDisposer) {
((ParameterDisposer) pss).cleanupParameters();
}
}
}
});
}
辅助类DataSourceUtils来用来对数据库连接进行管理的主要工具，比如打开和关闭数据库连接等基本操作：
public static Connection doGetConnection(DataSource dataSource) throws SQLException {
//把对数据库连接放到事务管理里面进行管理
ConnectionHolder conHolder = (ConnectionHolder) TransactionSynchronizationManager.getResource(dataSource);
if (conHolder != null && (conHolder.hasConnection() || conHolder.isSynchronizedWithTransaction())) {
conHolder.requested();
if (!conHolder.hasConnection()) {
logger.debug("Fetching resumed JDBC Connection from DataSource");
conHolder.setConnection(dataSource.getConnection());
}
return conHolder.getConnection();
}
// 这里得到需要的数据库连接，在配置文件中定义好的。
logger.debug("Fetching JDBC Connection from DataSource");
Connection con = dataSource.getConnection();
if (TransactionSynchronizationManager.isSynchronizationActive()) {
logger.debug("Registering transaction synchronization for JDBC Connection");
// Use same Connection for further JDBC actions within the transaction.
// Thread-bound object will get removed by synchronization at transaction completion.
ConnectionHolder holderToUse = conHolder;
if (holderToUse == null) {
holderToUse = new ConnectionHolder(con);
}
else {
holderToUse.setConnection(con);
}
holderToUse.requested();
TransactionSynchronizationManager.registerSynchronization(
new ConnectionSynchronization(holderToUse, dataSource));
holderToUse.setSynchronizedWithTransaction(true);
if (holderToUse != conHolder) {
TransactionSynchronizationManager.bindResource(dataSource, holderToUse);
}
}
return con;
}
那我们实际的DataSource对象是怎样得到的？很清楚我们需要在上下文中进行配置：它作为JdbcTemplate父类JdbcAccessor的属性存
在：
public abstract class JdbcAccessor implements InitializingBean {
/** 这里是我们依赖注入数据库数据源的地方。 */
private DataSource dataSource;
/** Helper to translate SQL exceptions to DataAccessExceptions */
private SQLExceptionTranslator exceptionTranslator;
private boolean lazyInit = true;
........
}
而对于DataSource的缓冲池实现，我们通过定义Apache Jakarta Commons DBCP或者C3P0提供的DataSource来完成，然后只要在上下
文中配置好就可以使用了。从上面我们看到JdbcTemplate提供了许多简单查询和更新功能，但是如果需要更高层次的抽象，以及更面
向对象的方法来访问数据库。Spring为我们提供了org.springframework.jdbc.object包，这里面包含了SqlQuery,SqlMappingQuery,
SqlUpdate和StoredProcedure等类，这些类都是Spring JDBC应用程序可以使用的主要类，但我们要注意使用这些类的时候，用户需要
为他们配置好一个JdbcTemplate作为其基本的操作的实现。
比如说我们使用MappingSqlQuery来将表数据直接映射到一个对象集合 - 具体可以参考书中的例子
1.我们需要建立DataSource和sql语句并建立持有这些对象的MappingSqlQuery对象
2.然后我们需要定义传递的SqlParameter,具体的实现我们在MappingSqlQuery的父类RdbmsOperation中可以找到：
public void declareParameter(SqlParameter param) throws InvalidDataAccessApiUsageException {
//如果声明已经被编译过，则该声明无效
if (isCompiled()) {
throw new InvalidDataAccessApiUsageException("Cannot add parameters once query is compiled");
}
//这里对参数值进行声明定义
this.declaredParameters.add(param);
}
而这个declareParameters维护的是一个列表：
/** List of SqlParameter objects */
private List declaredParameters = new LinkedList();
这个列表在以后compile的过程中会被使用。
3.然后用户程序需要实现MappingSqlQuery的mapRow接口，将具体的ResultSet数据生成我们需要的对象，这是我们迭代使用的方法。
1，2，3步实际上为我们定义好了一个迭代的基本单元作为操作模板。
4.在应用程序，我们直接调用execute()方法得到我们需要的对象列表，列表中的每一个对象的数据来自于执行SQL语句得到记录集的每
一条记录，事实上执行的execute在父类SqlQuery中起作用：
public List executeByNamedParam(Map paramMap, Map context) throws DataAccessException {
validateNamedParameters(paramMap);
Object[] parameters = NamedParameterUtils.buildValueArray(getSql(), paramMap);
RowMapper rowMapper = newRowMapper(parameters, context);
String sqlToUse = NamedParameterUtils.substituteNamedParameters(getSql(), new MapSqlParameterSource(paramMap));
//我们又看到了JdbcTemplate,这里使用JdbcTemplate来完成对数据库的查询操作，所以我们说JdbcTemplate是基本的操作类。
return getJdbcTemplate().query(newPreparedStatementCreator(sqlToUse, parameters), rowMapper);
}
在这里我们可以看到template模式的精彩应用和对JdbcTemplate的灵活使用。通过使用它，我们免去了手工迭代ResultSet并将其中的
数据转化为对象列表的重复过程。在这里我们只需要定义SQL语句和SqlParameter - 如果需要的话，往往SQL语句就常常能够满足我们
的要求了。这是灵活使用JdbcTemplate的一个很好的例子。
Spring还为其他数据库操作提供了许多服务，比如使用SqlUpdate插入和更新数据库，使用UpdatableSqlQuery更新ResultSet，生成主
键，调用存储过程等。
书中还给出了对BLOB数据和CLOB数据进行数据库操作的例子：
对BLOB数据的操作通过LobHander来完成，通过调用JdbcTemplate和RDBMS都可以进行操作：
在JdbcTemplate中，具体的调用可以参考书中的例子 - 是通过以下调用起作用的：
public Object execute(String sql, PreparedStatementCallback action) throws DataAccessException {
return execute(new SimplePreparedStatementCreator(sql), action);
}
然后通过对实现PreparedStatementCallback接口的AbstractLobCreatingPreparedStatementCallback的回调函数来完成：
public final Object doInPreparedStatement(PreparedStatement ps) throws SQLException, DataAccessException {
LobCreator lobCreator = this.lobHandler.getLobCreator();
try {
//这是一个模板方法，具体需要由客户程序实现
setValues(ps, lobCreator);
return new Integer(ps.executeUpdate());
}
finally {
lobCreator.close();
}
}
//定义的需要客户程序实现的虚函数
protected abstract void setValues(PreparedStatement ps, LobCreator lobCreator)
throws SQLException, DataAccessException;
而我们注意到setValues()是一个需要实现的抽象方法，应用程序通过实现setValues来定义自己的操作 - 在setValues中调用
lobCreator.setBlobAsBinaryStrem()。让我们看看具体的BLOB操作在LobCreator是怎样完成的，我们一般使用DefaultLobCreator作为
BLOB操作的驱动：
public void setBlobAsBinaryStream(
PreparedStatement ps, int paramIndex, InputStream binaryStream, int contentLength)
throws SQLException {
//通过JDBC来完成对BLOB数据的操作，对Oracle,Spring提供了OracleLobHandler来支持BLOB操作。
ps.setBinaryStream(paramIndex, binaryStream, contentLength);
........
}
上面提到的是零零碎碎的Spring JDBC使用的例子，可以看到使用Spring JDBC可以帮助我们完成许多数据库的操作。Spring对数据库操
作最基本的服务是通过JdbcTeamplate和他常用的回调函数来实现的，在此之上，又提供了许多RMDB的操作来帮助我们更便利的对数
据库的数据进行操作 - 注意这里没有引入向Hibernate这样的O/R方案。对这些O/R方案的支持，Spring由其他包来完成服务。
书中还提到关于execute和update方法之间的区别，update方法返回的是受影响的记录数目的一个计数，并且如果传入参数的话，使用
的是java.sql.PreparedStatement,而execute方法总是使用 java.sql.Statement,不接受参数，而且他不返回受影响记录的计数，更适合于
创建和丢弃表的语句，而update方法更适合于插入，更新和删除操作，这也是我们在使用时需要注意的。
1.4 Spring源代码解析(四）：Spring MVC
发表时间: 2007-06-07
下面我们对Spring MVC框架代码进行分析,对于webApplicationContext的相关分析可以参见以前的文档，我们这里着重分析Spring Web
MVC框架的实现.我们从分析DispatcherServlet入手：
//这里是对DispatcherServlet的初始化方法，根据名字我们很方面的看到对各个Spring MVC主要元素的初始化
protected void initFrameworkServlet() throws ServletException, BeansException {
initMultipartResolver();
initLocaleResolver();
initThemeResolver();
initHandlerMappings();
initHandlerAdapters();
initHandlerExceptionResolvers();
initRequestToViewNameTranslator();
initViewResolvers();
}
看到注解我们知道，这是DispatcherSerlvet的初始化过程，它是在WebApplicationContext已经存在的情况下进行的，也就意味着在初始
化它的时候，IOC容器应该已经工作了，这也是我们在web.xml中配置Spring的时候，需要把DispatcherServlet的 load-on-startup的属性
配置为2的原因。
对于具体的初始化过程，很容易理解，我们拿initHandlerMappings（）来看看：
private void initHandlerMappings() throws BeansException {
if (this.detectAllHandlerMappings) {
// 这里找到所有在上下文中定义的HandlerMapping,同时把他们排序
// 因为在同一个上下文中可以有不止一个handlerMapping,所以我们把他们都载入到一个链里进行维护和管理
Map matchingBeans = BeanFactoryUtils.beansOfTypeIncludingAncestors(
getWebApplicationContext(), HandlerMapping.class, true, false);
if (!matchingBeans.isEmpty()) {
this.handlerMappings = new ArrayList(matchingBeans.values());
// 这里通过order属性来对handlerMapping来在list中排序
Collections.sort(this.handlerMappings, new OrderComparator());
}
}
else {
try {
Object hm = getWebApplicationContext().getBean(HANDLER_MAPPING_BEAN_NAME, HandlerMapping.class);
this.handlerMappings = Collections.singletonList(hm);
}
catch (NoSuchBeanDefinitionException ex) {
// Ignore, we'll add a default HandlerMapping later.
}
}
//如果在上下文中没有定义的话，那么我们使用默认的BeanNameUrlHandlerMapping
if (this.handlerMappings == null) {
this.handlerMappings = getDefaultStrategies(HandlerMapping.class);
........
}
}
怎样获得上下文环境，可以参见我们前面的对IOC容器在web环境中加载的分析。 DispatcherServlet把定义了的所有HandlerMapping都
加载了放在一个List里待以后进行使用,这个链的每一个元素都是一个handlerMapping的配置，而一般每一个handlerMapping可以持有
一系列从URL请求到 Spring Controller的映射，比如SimpleUrl
HandlerMaaping中就定义了一个map来持有这一系列的映射关系。
DisptcherServlet通过HandlerMapping使得Web应用程序确定一个执行路径，就像我们在HanderMapping中看到的那样，
HandlerMapping只是一个借口：
public interface HandlerMapping {
public static final String PATH_WITHIN_HANDLER_MAPPING_ATTRIBUTE =
Conventions.getQualifiedAttributeName(HandlerMapping.class, "pathWithinHandlerMapping");
//实际上维护一个HandlerExecutionChain,这是典型的Command的模式的使用，这个执行链里面维护handler和拦截器
HandlerExecutionChain getHandler(HttpServletRequest request) throws Exception;
}
他的具体实现只需要实现一个接口方法，而这个接口方法返回的是一个HandlerExecutionChain,实际上就是一个执行链，就像在
Command模式描述的那样，这个类很简单，就是一个持有一个Interceptor链和一个Controller：
public class HandlerExecutionChain {
private Object handler;
private HandlerInterceptor[] interceptors;
........
}
而这些Handler和Interceptor需要我们定义HandlerMapping的时候配置好，比如对具体的 SimpleURLHandlerMapping,他要做的就是根据
URL映射的方式注册Handler和Interceptor，自己维护一个放映映射的handlerMap，当需要匹配Http请求的时候需要使用这个表里的信
息来得到执行链。这个注册的过程在IOC容器初始化 SimpleUrlHandlerMapping的时候就被完成了，这样以后的解析才可以用到map里
的映射信息，这里的信息和bean文件的信息是等价的，下面是具体的注册过程：
protected void registerHandlers(Map urlMap) throws BeansException {
if (urlMap.isEmpty()) {
logger.warn("Neither 'urlMap' nor 'mappings' set on SimpleUrlHandlerMapping");
}
else {
//这里迭代在SimpleUrlHandlerMapping中定义的所有映射元素
Iterator it = urlMap.keySet().iterator();
while (it.hasNext()) {
//这里取得配置的url
String url = (String) it.next();
//这里根据url在bean定义中取得对应的handler
Object handler = urlMap.get(url);
// Prepend with slash if not already present.
if (!url.startsWith("/")) {
url = "/" + url;
}
//这里调用AbstractHandlerMapping中的注册过程
registerHandler(url, handler);
}
}
}
在AbstractMappingHandler中的注册代码：
protected void registerHandler(String urlPath, Object handler) throws BeansException, IllegalStateException {
//试图从handlerMap中取handler,看看是否已经存在同样的Url映射关系
Object mappedHandler = this.handlerMap.get(urlPath);
if (mappedHandler != null) {
........
}
//如果是直接用bean名做映射那就直接从容器中取handler
if (!this.lazyInitHandlers && handler instanceof String) {
String handlerName = (String) handler;
if (getApplicationContext().isSingleton(handlerName)) {
handler = getApplicationContext().getBean(handlerName);
}
}
//或者使用默认的handler.
if (urlPath.equals("/*")) {
setDefaultHandler(handler);
}
else {
//把url和handler的对应关系放到handlerMap中去
this.handlerMap.put(urlPath, handler);
........
}
}
handlerMap是持有的一个HashMap,里面就保存了具体的映射信息：
private final Map handlerMap = new HashMap();
而SimpleUrlHandlerMapping对接口HandlerMapping的实现是这样的，这个getHandler根据在初始化的时候就得到的映射表来生成
DispatcherServlet需要的执行链
public final HandlerExecutionChain getHandler(HttpServletRequest request) throws Exception {
//这里根据request中的参数得到其对应的handler,具体处理在AbstractUrlHandlerMapping中
Object handler = getHandlerInternal(request);
//如果找不到对应的，就使用缺省的handler
if (handler == null) {
handler = this.defaultHandler;
}
//如果缺省的也没有，那就没办法了
if (handler == null) {
return null;
}
// 如果handler不是一个具体的handler,那我们还要到上下文中取
if (handler instanceof String) {
String handlerName = (String) handler;
handler = getApplicationContext().getBean(handlerName);
}
//生成一个HandlerExecutionChain,其中放了我们匹配上的handler和定义好的拦截器，就像我们在HandlerExecutionChain中看到的那样，return new HandlerExecutionChain(handler, this.adaptedInterceptors);
}
我们看看具体的handler查找过程：
protected Object getHandlerInternal(HttpServletRequest request) throws Exception {
//这里的HTTP Request传进来的参数进行分析，得到具体的路径信息。
String lookupPath = this.urlPathHelper.getLookupPathForRequest(request);
.......//下面是根据请求信息的查找
return lookupHandler(lookupPath, request);
}
protected Object lookupHandler(String urlPath, HttpServletRequest request) {
// 如果能够直接能在SimpleUrlHandlerMapping的映射表中找到，那最好。
Object handler = this.handlerMap.get(urlPath);
if (handler == null) {
// 这里使用模式来对map中的所有handler进行匹配，调用了Jre中的Matcher类来完成匹配处理。
String bestPathMatch = null;
for (Iterator it = this.handlerMap.keySet().iterator(); it.hasNext();) {
String registeredPath = (String) it.next();
if (this.pathMatcher.match(registeredPath, urlPath) &&
(bestPathMatch == null || bestPathMatch.length() <= registeredPath.length())) {
//这里根据匹配路径找到最象的一个
handler = this.handlerMap.get(registeredPath);
bestPathMatch = registeredPath;
}
}
if (handler != null) {
exposePathWithinMapping(this.pathMatcher.extractPathWithinPattern(bestPathMatch, urlPath), request);
}
}
else {
exposePathWithinMapping(urlPath, request);
}
//
return handler;
}
我们可以看到，总是在handlerMap这个HashMap中找，当然如果直接找到最好，如果找不到，就看看是不是能通过Match Pattern的模
式找，我们一定还记得在配置HnaderMapping的时候是可以通过ANT语法进行配置的，其中的处理就在这里。
这样可以清楚地看到整个HandlerMapping的初始化过程 - 同时，我们也看到了一个具体的handler映射是怎样被存储和查找的 - 这里生
成一个ExecutionChain来储存我们找到的handler和在定义bean的时候定义的Interceptors.
让我们回到DispatcherServlet，初始化完成以后，实际的对web请求是在doService()方法中处理的，我们知道DispatcherServlet只是一
个普通的Servlet:
protected void doService(HttpServletRequest request, HttpServletResponse response) throws Exception {
.......
//这里把属性信息进行保存
Map attributesSnapshot = null;
if (WebUtils.isIncludeRequest(request)) {
logger.debug("Taking snapshot of request attributes before include");
attributesSnapshot = new HashMap();
Enumeration attrNames = request.getAttributeNames();
while (attrNames.hasMoreElements()) {
String attrName = (String) attrNames.nextElement();
if (this.cleanupAfterInclude || attrName.startsWith(DispatcherServlet.class.getName())) {
attributesSnapshot.put(attrName, request.getAttribute(attrName));
}
}
}
// Make framework objects available to handlers and view objects.
request.setAttribute(WEB_APPLICATION_CONTEXT_ATTRIBUTE, getWebApplicationContext());
request.setAttribute(LOCALE_RESOLVER_ATTRIBUTE, this.localeResolver);
request.setAttribute(THEME_RESOLVER_ATTRIBUTE, this.themeResolver);
request.setAttribute(THEME_SOURCE_ATTRIBUTE, getThemeSource());
try {
//这里使实际的处理入口
doDispatch(request, response);
}
finally {
// Restore the original attribute snapshot, in case of an include.
if (attributesSnapshot != null) {
restoreAttributesAfterInclude(request, attributesSnapshot);
}
}
}
我们看到，对于请求的处理实际上是让doDispatch()来完成的 - 这个方法很长，但是过程很简单明了：
protected void doDispatch(final HttpServletRequest request, HttpServletResponse response) throws Exception {
HttpServletRequest processedRequest = request;
//这是从handlerMapping中得到的执行链
HandlerExecutionChain mappedHandler = null;
int interceptorIndex = -1;
........
try {
//我们熟悉的ModelAndView开始出现了。
ModelAndView mv = null;
try {
processedRequest = checkMultipart(request);
// 这是我们得到handler的过程
mappedHandler = getHandler(processedRequest, false);
if (mappedHandler == null || mappedHandler.getHandler() == null) {
noHandlerFound(processedRequest, response);
return;
}
// 这里取出执行链中的Interceptor进行前处理
if (mappedHandler.getInterceptors() != null) {
for (int i = 0; i < mappedHandler.getInterceptors().length; i++) {
HandlerInterceptor interceptor = mappedHandler.getInterceptors()[i];
if (!interceptor.preHandle(processedRequest, response, mappedHandler.getHandler())) {
triggerAfterCompletion(mappedHandler, interceptorIndex, processedRequest, response, null);
return;
}
interceptorIndex = i;
}
}
//在执行handler之前，用HandlerAdapter先检查一下handler的合法性：是不是按Spring的要求编写的。
HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());
mv = ha.handle(processedRequest, response, mappedHandler.getHandler());
// 这里取出执行链中的Interceptor进行后处理
if (mappedHandler.getInterceptors() != null) {
for (int i = mappedHandler.getInterceptors().length - 1; i >= 0; i--) {
HandlerInterceptor interceptor = mappedHandler.getInterceptors()[i];
interceptor.postHandle(processedRequest, response, mappedHandler.getHandler(), mv);
}
}
}
........
// Did the handler return a view to render?
//这里对视图生成进行处理
if (mv != null && !mv.wasCleared()) {
render(mv, processedRequest, response);
}
.......
}
我们很清楚的看到和MVC框架紧密相关的代码,比如如何得到和http请求相对应的执行链，怎样执行执行链和怎样把模型数据展现到视
图中去。
先看怎样取得Command对象，对我们来说就是Handler - 下面是getHandler的代码：
protected HandlerExecutionChain getHandler(HttpServletRequest request, boolean cache) throws Exception {
//在ServletContext取得执行链 - 实际上第一次得到它的时候，我们把它放在ServletContext进行了缓存。
HandlerExecutionChain handler =
(HandlerExecutionChain) request.getAttribute(HANDLER_EXECUTION_CHAIN_ATTRIBUTE);
if (handler != null) {
if (!cache) {
request.removeAttribute(HANDLER_EXECUTION_CHAIN_ATTRIBUTE);
}
return handler;
}
//这里的迭代器迭代的时在initHandlerMapping中载入的上下文所有的HandlerMapping
Iterator it = this.handlerMappings.iterator();
while (it.hasNext()) {
HandlerMapping hm = (HandlerMapping) it.next();
.......
//这里是实际取得handler的过程,在每个HandlerMapping中建立的映射表进行检索得到请求对应的handler
handler = hm.getHandler(request);
//然后把handler存到ServletContext中去进行缓存
if (handler != null) {
if (cache) {
request.setAttribute(HANDLER_EXECUTION_CHAIN_ATTRIBUTE, handler);
}
return handler;
}
}
return null;
}
如果在ServletContext中可以取得handler则直接返回，实际上这个handler是缓冲了上次处理的结果 - 总要有第一次把这个handler放到
ServletContext中去：
如果在ServletContext中找不到handler,那就通过持有的handlerMapping生成一个，我们看到它会迭代当前持有的所有的
handlerMapping,因为可以定义不止一个，他们在定义的时候也可以指定顺序，直到找到第一个，然后返回。先找到一个
handlerMapping,然后通过这个handlerMapping返回一个执行链，里面包含了最终的Handler和我们定义的一连串的 Interceptor。具体的
我们可以参考上面的SimpleUrlHandlerMapping的代码分析知道getHandler是怎样得到一个 HandlerExecutionChain的。
得到HandlerExecutionChain以后，我们通过HandlerAdapter对这个Handler的合法性进行判断：
protected HandlerAdapter getHandlerAdapter(Object handler) throws ServletException {
Iterator it = this.handlerAdapters.iterator();
while (it.hasNext()) {
//同样对持有的所有adapter进行匹配
HandlerAdapter ha = (HandlerAdapter) it.next();
if (ha.supports(handler)) {
return ha;
}
}
........
}
通过判断，我们知道这个handler是不是一个Controller接口的实现，比如对于具体的HandlerAdapter - SimpleControllerHandlerAdapter:
public class SimpleControllerHandlerAdapter implements HandlerAdapter {
public boolean supports(Object handler) {
return (handler instanceof Controller);
}
.......
}
简单的判断一下handler是不是实现了Controller接口。这也体现了一种对配置文件进行验证的机制。
让我们再回到DispatcherServlet看到代码：
mv = ha.handle(processedRequest, response, mappedHandler.getHandler());
这个就是对handle的具体调用！相当于Command模式里的Command.execute();理所当然的返回一个ModelAndView，下面就是一个对
View进行处理的过程：
if (mv != null && !mv.wasCleared()) {
render(mv, processedRequest, response);
}
调用的是render方法：
protected void render(ModelAndView mv, HttpServletRequest request, HttpServletResponse response)
throws Exception {response.setLocale(locale);
View view = null;
//这里把默认的视图放到ModelAndView中去。
if (!mv.hasView()) {
mv.setViewName(getDefaultViewName(request));
}
if (mv.isReference()) {
// 这里对视图名字进行解析
view = resolveViewName(mv.getViewName(), mv.getModelInternal(), locale, request);
.......
}
else {
// 有可能在ModelAndView里已经直接包含了View对象，那我们就直接使用。
view = mv.getView();
........
}
//得到具体的View对象以后，我们用它来生成视图。
view.render(mv.getModelInternal(), request, response);
}
从整个过程我们看到先在ModelAndView中寻找视图的逻辑名，如果找不到那就使用缺省的视图，如果能够找到视图的名字，那就对他
进行解析得到实际的需要使用的视图对象。还有一种可能就是在ModelAndView中已经包含了实际的视图对象，这个视图对象是可以直
接使用的。
不管怎样，得到一个视图对象以后，通过调用视图对象的render来完成数据的显示过程，我们可以看看具体的JstlView是怎样实现的，
我们在JstlView的抽象父类 AbstractView中找到render方法：
public void render(Map model, HttpServletRequest request, HttpServletResponse response) throws Exception {
......
// 这里把所有的相关信息都收集到一个Map里
Map mergedModel = new HashMap(this.staticAttributes.size() + (model != null ? model.size() : 0));
mergedModel.putAll(this.staticAttributes);
if (model != null) {
mergedModel.putAll(model);
}
// Expose RequestContext?
if (this.requestContextAttribute != null) {
mergedModel.put(this.requestContextAttribute, createRequestContext(request, mergedModel));
}
//这是实际的展现模型数据到视图的调用。
renderMergedOutputModel(mergedModel, request, response);
}
注解写的很清楚了，先把所有的数据模型进行整合放到一个Map - mergedModel里，然后调用renderMergedOutputModel();这个
renderMergedOutputModel是一个模板方法，他的实现在InternalResourceView也就是JstlView的父类：
protected void renderMergedOutputModel(
Map model, HttpServletRequest request, HttpServletResponse response) throws Exception {
// Expose the model object as request attributes.
exposeModelAsRequestAttributes(model, request);
// Expose helpers as request attributes, if any.
exposeHelpers(request);
// 这里得到InternalResource定义的内部资源路径。
String dispatcherPath = prepareForRendering(request, response);
//这里把请求转发到前面得到的内部资源路径中去。
RequestDispatcher rd = request.getRequestDispatcher(dispatcherPath);
if (rd == null) {
throw new ServletException(
"Could not get RequestDispatcher for [" + getUrl() + "]: check that this file exists within your WAR");
}
.......
}
首先对模型数据进行处理，exposeModelAsRequestAttributes是在AbstractView中实现的，这个方法把 ModelAndView中的模型数据和
其他request数据统统放到ServletContext当中去，这样整个模型数据就通过 ServletContext暴露并得到共享使用了：
protected void exposeModelAsRequestAttributes(Map model, HttpServletRequest request) throws Exception {
Iterator it = model.entrySet().iterator();
while (it.hasNext()) {
Map.Entry entry = (Map.Entry) it.next();
..........
String modelName = (String) entry.getKey();
Object modelValue = entry.getValue();
if (modelValue != null) {
request.setAttribute(modelName, modelValue);
...........
}
else {
request.removeAttribute(modelName);
.......
}
}
}
让我们回到数据处理部分的exposeHelper();这是一个模板方法，其实现在JstlView中实现：
public class JstlView extends InternalResourceView {
private MessageSource jstlAwareMessageSource;
protected void initApplicationContext() {
super.initApplicationContext();
this.jstlAwareMessageSource =
JstlUtils.getJstlAwareMessageSource(getServletContext(), getApplicationContext());
}
protected void exposeHelpers(HttpServletRequest request) throws Exception {
JstlUtils.exposeLocalizationContext(request, this.jstlAwareMessageSource);
}
}
在JstlUtils中包含了对于其他而言jstl特殊的数据处理和设置。
过程是不是很长？我们现在在哪里了？呵呵，我们刚刚完成的事MVC中View的render，对于InternalResourceView的render 过程比较简
单只是完成一个资源的重定向处理。需要做的就是得到实际view的internalResource路径，然后转发到那个资源中去。怎样得到资源的
路径呢通过调用：
protected String prepareForRendering(HttpServletRequest request, HttpServletResponse response)
throws Exception {
return getUrl();
}
那这个url在哪里生成呢？我们在View相关的代码中没有找到，实际上，他在ViewRosolve的时候就生成了，在UrlBasedViewResolver
中：
protected AbstractUrlBasedView buildView(String viewName) throws Exception {
AbstractUrlBasedView view = (AbstractUrlBasedView) BeanUtils.instantiateClass(getViewClass());
view.setUrl(getPrefix() + viewName + getSuffix());
String contentType = getContentType();
if (contentType != null) {
view.setContentType(contentType);
}
view.setRequestContextAttribute(getRequestContextAttribute());
view.setAttributesMap(getAttributesMap());
return view;
}
这里是生成View的地方，自然也把生成的url和其他一些和view相关的属性也配置好了。
那这个ViewResolve是什么时候被调用的呢？哈哈，我们这样又要回到DispatcherServlet中去看看究竟，在DispatcherServlet中：
protected void render(ModelAndView mv, HttpServletRequest request, HttpServletResponse response)
throws Exception {
........
View view = null;
// 这里设置视图名为默认的名字
if (!mv.hasView()) {
mv.setViewName(getDefaultViewName(request));
}
if (mv.isReference()) {
//这里对视图名进行解析，在解析的过程中根据需要生成实际需要的视图对象。
view = resolveViewName(mv.getViewName(), mv.getModelInternal(), locale, request);
..........
}
......
}
下面是对视图名进行解析的具体过程：
protected View resolveViewName(String viewName, Map model, Locale locale, HttpServletRequest request)
throws Exception {
//我们有可能不止一个视图解析器
for (Iterator it = this.viewResolvers.iterator(); it.hasNext();) {
ViewResolver viewResolver = (ViewResolver) it.next();
//这里是视图解析器进行解析并生成视图的过程。
View view = viewResolver.resolveViewName(viewName, locale);
if (view != null) {
return view;
}
}
return null;
}
这里调用具体的ViewResolver对视图的名字进行解析 - 除了单纯的解析之外，它还根据我们的要求生成了我们实际需要的视图对象。具
体的viewResolver在bean定义文件中进行定义同时在 initViewResolver()方法中被初始化到viewResolver变量中，我们看看具体的
InternalResourceViewResolver是怎样对视图名进行处理的并生成V视图对象的：对resolveViewName的调用模板在
AbstractCachingViewResolver中,
public View resolveViewName(String viewName, Locale locale) throws Exception {
//如果没有打开缓存设置，那创建需要的视图
if (!isCache()) {
logger.warn("View caching is SWITCHED OFF -- DEVELOPMENT SETTING ONLY: This can severely impair performance");
return createView(viewName, locale);
}
else {
Object cacheKey = getCacheKey(viewName, locale);
// No synchronization, as we can live with occasional double caching.
synchronized (this.viewCache) {
//这里查找缓存里的视图对象
View view = (View) this.viewCache.get(cacheKey);
if (view == null) {
//如果在缓存中没有找到，创建一个并把创建的放到缓存中去
view = createView(viewName, locale);
this.viewCache.put(cacheKey, view);
........
}
return view;
}
}
}
关于这些createView(),loadView(),buildView()的关系，我们看看Eclipse里的call hiearchy
然后我们回到view.render中完成数据的最终对httpResponse的写入，比如在AbstractExcelView中的实现:
protected final void renderMergedOutputModel(
Map model, HttpServletRequest request, HttpServletResponse response) throws Exception {
.........
// response.setContentLength(workbook.getBytes().length);
response.setContentType(getContentType());
ServletOutputStream out = response.getOutputStream();
workbook.write(out);
out.flush();
}
这样就和我们前面的分析一致起来了:DispatcherServlet在解析视图名的时候就根据要求生成了视图对象,包括在InternalResourceView中
需要使用的url和其他各种和HTTP response相关的属性都会写保持在生成的视图对象中，然后就直接调用视图对象的render来完成数据
的展示。
这就是整个Spring Web MVC框架的大致流程，整个MVC流程由DispatcherServlet来控制。MVC的关键过程包括：
配置到handler的映射关系和怎样根据请求参数得到对应的handler,在Spring中，这是由handlerMapping通过执行链来完成的，而具体的
映射关系我们在bean定义文件中定义并在HandlerMapping载入上下文的时候就被配置好了。然后 DispatcherServlet调用
HandlerMapping来得到对应的执行链，最后通过视图来展现模型数据，但我们要注意的是视图对象是在解析视图名的时候生成配置好
的。这些作为核心类的HanderMapping,ViewResolver,View,Handler的紧密协作实现了MVC的功能。
1.5 Spring源代码解析(五）：Spring AOP获取Proxy
发表时间: 2007-06-08
下面我们来看看Spring的AOP的一些相关代码是怎么得到Proxy的，让我们我们先看看AOP和Spring AOP的一些基本概念：
Advice：
通知，制定在连接点做什么，在Sping中，他主要描述Spring围绕方法调用注入的额外的行为，Spring提供的通知类型有：
before advice,AfterReturningAdvice,ThrowAdvice,MethodBeforeAdvice，这些都是Spring AOP定义的接口类，具体的动作实现需要用
户程序来完成。
Pointcut:
切点，其决定一个advice应该应用于哪个连接点，也就是需要插入额外处理的地方的集合，例如，被某个advice作为目标的一组方
法。Spring pointcut通常意味着标示方法，可以选择一组方法调用作为pointcut,Spring提供了具体的切点来给用户使用，比如正则表达
式切点 JdkRegexpMethodPointcut通过正则表达式对方法名进行匹配，其通过使用 AbstractJdkRegexpMethodPointcut中的对
MethodMatcher接口的实现来完成pointcut功能：
public final boolean matches(Method method, Class targetClass) {
//这里通过放射得到方法的全名
String patt = method.getDeclaringClass().getName() + "." + method.getName();
for (int i = 0; i < this.patterns.length; i++) {
// 这里是判断是否和方法名是否匹配的代码
boolean matched = matches(patt, i);
if (matched) {
for (int j = 0; j < this.excludedPatterns.length; j++) {
boolean excluded = matchesExclusion(patt, j);
if(excluded) {
return false;
}
}
return true;
}
}
return false;
}
在JDKRegexpMethodPointcut中通过JDK中的正则表达式匹配来完成pointcut的最终确定：
protected boolean matches(String pattern, int patternIndex) {
Matcher matcher = this.compiledPatterns[patternIndex].matcher(pattern);
return matcher.matches();
}
Advisor：
当我们完成额外的动作设计（advice)和额外动作插入点的设计（pointcut)以后,我们需要一个对象把他们结合起来，这就是通知器 -
advisor,定义应该在哪里应用哪个通知。Advisor的实现有：DefaultPointcutAdvisor他有两个属性advice和 pointcut来让我们配置advice
和pointcut。
接着我们就可以通过ProxyFactoryBean来配置我们的代理对象和方面行为，在ProxyFactoryBean中有interceptorNames来配置已经定义
好的通知器-advisor,虽然这里的名字叫做interceptNames,但实际上是供我们配置advisor的地方，具体的代理实现通过JDK 的Proxy或者
CGLIB来完成。因为ProxyFactoryBean是一个FactoryBean,在ProxyFactoryBean中我们通过getObject()可以直接得到代理对象：
public Object getObject() throws BeansException {
//这里初始化通知器链
initializeAdvisorChain();
if (isSingleton()) {
//根据定义需要生成单件的Proxy
return getSingletonInstance();
}
else {
.......
//这里根据定义需要生成Prototype类型的Proxy
return newPrototypeInstance();
}
}
我们看看怎样生成单件的代理对象：
private synchronized Object getSingletonInstance() {
if (this.singletonInstance == null) {
this.targetSource = freshTargetSource();
if (this.autodetectInterfaces && getProxiedInterfaces().length == 0 && !isProxyTargetClass()) {
// 这里设置代理对象的接口
setInterfaces(ClassUtils.getAllInterfacesForClass(this.targetSource.getTargetClass()));
}
// Eagerly initialize the shared singleton instance.
super.setFrozen(this.freezeProxy);
// 注意这里的方法会使用ProxyFactory来生成我们需要的Proxy
this.singletonInstance = getProxy(createAopProxy());
// We must listen to superclass advice change events to recache the singleton
// instance if necessary.
addListener(this);
}
return this.singletonInstance;
}
//使用createAopProxy放回的AopProxy来得到代理对象。
protected Object getProxy(AopProxy aopProxy) {
return aopProxy.getProxy(this.beanClassLoader);
}
ProxyFactoryBean的父类是AdvisedSupport，Spring使用AopProxy接口把AOP代理的实现与框架的其他部分分离开来；在AdvisedSupport
中通过这样的方式来得到AopProxy,当然这里需要得到AopProxyFactory的帮助 - 下面我们看到Spring为我们提供的实现，来帮助我们方
便的从JDK或者cglib中得到我们想要的代理对象：
protected synchronized AopProxy createAopProxy() {
if (!this.isActive) {
activate();
}
return getAopProxyFactory().createAopProxy(this);
}
而在ProxyConfig中对使用的AopProxyFactory做了定义：
//这个DefaultAopProxyFactory是Spring用来生成AopProxy的地方，
//当然了它包含JDK和Cglib两种实现方式。
private transient AopProxyFactory aopProxyFactory = new DefaultAopProxyFactory();
其中在DefaultAopProxyFactory中是这样生成AopProxy的：
public AopProxy createAopProxy(AdvisedSupport advisedSupport) throws AopConfigException {
//首先考虑使用cglib来实现代理对象，当然如果同时目标对象不是接口的实现类的话
if (advisedSupport.isOptimize() || advisedSupport.isProxyTargetClass() ||
advisedSupport.getProxiedInterfaces().length == 0) {
//这里判断如果不存在cglib库，直接抛出异常。
if (!cglibAvailable) {
throw new AopConfigException(
"Cannot proxy target class because CGLIB2 is not available. " +
"Add CGLIB to the class path or specify proxy interfaces.");
}
// 这里使用Cglib来生成Proxy，如果target不是接口的实现的话，返回cglib类型的AopProxy
return CglibProxyFactory.createCglibProxy(advisedSupport);
}
else {
// 这里使用JDK来生成Proxy,返回JDK类型的AopProxy
return new JdkDynamicAopProxy(advisedSupport);
}
}
于是我们就可以看到其中的代理对象可以由JDK或者Cglib来生成，我们看到JdkDynamicAopProxy类和Cglib2AopProxy都实现的是
AopProxy的接口，在JdkDynamicAopProxy实现中我们可以看到Proxy是怎样生成的：
public Object getProxy(ClassLoader classLoader) {
if (logger.isDebugEnabled()) {
Class targetClass = this.advised.getTargetSource().getTargetClass();
logger.debug("Creating JDK dynamic proxy" +
(targetClass != null ? " for [" + targetClass.getName() + "]" : ""));
}
Class[] proxiedInterfaces = AopProxyUtils.completeProxiedInterfaces(this.advised);
findDefinedEqualsAndHashCodeMethods(proxiedInterfaces);
//这里我们调用JDK Proxy来生成需要的Proxy实例
return Proxy.newProxyInstance(classLoader, proxiedInterfaces, this);
}
这样用Proxy包装target之后，通过ProxyFactoryBean得到对其方法的调用就被Proxy拦截了， ProxyFactoryBean的getObject()方法得到的
实际上是一个Proxy了，我们的target对象已经被封装了。对 ProxyFactoryBean这个工厂bean而言，其生产出来的对象是封装了目标对
象的代理对象。
1.6 Spring源代码解析(六）：Spring声明式事务处理
发表时间: 2007-06-08
我们看看Spring中的事务处理的代码，使用Spring管理事务有声明式和编程式两种方式，声明式事务处理通过AOP的实现把事物管理代
码作为方面封装来横向插入到业务代码中，使得事务管理代码和业务代码解藕。在这种方式我们结合IoC容器和Spirng已有的
FactoryBean来对事务管理进行属性配置，比如传播行为，隔离级别等。其中最简单的方式就是通过配置TransactionProxyFactoryBean
来实现声明式事物；
在整个源代码分析中，我们可以大致可以看到Spring实现声明式事物管理有这么几个部分：
* 对在上下文中配置的属性的处理，这里涉及的类是TransactionAttributeSourceAdvisor，这是一个通知器，用它来对属性值进行处
理，属性信息放在TransactionAttribute中来使用,而这些属性的处理往往是和对切入点的处理是结合起来的。对属性的处理放在类
TransactionAttributeSource中完成。
* 创建事物的过程，这个过程是委托给具体的事物管理器来创建的，但Spring通过TransactionStatus来传递相关的信息。
* 对事物的处理通过对相关信息的判断来委托给具体的事物管理器完成。
我们下面看看具体的实现，在TransactionFactoryBean中：
public class TransactionProxyFactoryBean extends AbstractSingletonProxyFactoryBean
implements FactoryBean, BeanFactoryAware {
//这里是Spring事务处理而使用的AOP拦截器，中间封装了Spring对事务处理的代码来支持声明式事务处理的实现
private final TransactionInterceptor transactionInterceptor = new TransactionInterceptor();
private Pointcut pointcut;
//这里Spring把TransactionManager注入到TransactionInterceptor中去
public void setTransactionManager(PlatformTransactionManager transactionManager) {
this.transactionInterceptor.setTransactionManager(transactionManager);
}
//这里把在bean配置文件中读到的事务管理的属性信息注入到TransactionInterceptor中去
public void setTransactionAttributes(Properties transactionAttributes) {
this.transactionInterceptor.setTransactionAttributes(transactionAttributes);
}
.........中间省略了其他一些方法.......
//这里创建Spring AOP对事务处理的Advisor
protected Object createMainInterceptor() {
this.transactionInterceptor.afterPropertiesSet();
if (this.pointcut != null) {
//这里使用默认的通知器
return new DefaultPointcutAdvisor(this.pointcut, this.transactionInterceptor);
}
else {
// 使用上面定义好的TransactionInterceptor作为拦截器，同时使用TransactionAttributeSourceAdvisor
return new TransactionAttributeSourceAdvisor(this.transactionInterceptor);
}
}
}
那什么时候Spring的TransactionInterceptor被注入到Spring AOP中成为Advisor中的一部分呢？我们看到在TransactionProxyFactoryBean
中，这个方法在IOC初始化bean的时候被执行：
public void afterPropertiesSet() {
.......
//TransactionProxyFactoryBean实际上使用ProxyFactory完成AOP的基本功能。
ProxyFactory proxyFactory = new ProxyFactory();
if (this.preInterceptors != null) {
for (int i = 0; i < this.preInterceptors.length; i++) {
proxyFactory.addAdvisor(this.advisorAdapterRegistry.wrap(this.preInterceptors[i]));
}
}
//这里是Spring加入通知器的地方
//有两种通知器可以被加入DefaultPointcutAdvisor或者TransactionAttributeSourceAdvisor
//这里把Spring处理声明式事务处理的AOP代码都放到ProxyFactory中去，怎样加入advisor我们可以参考ProxyFactory的父类AdvisedSupport()
//由它来维护一个advice的链表，通过这个链表的增删改来抽象我们对整个通知器配置的增删改操作。
proxyFactory.addAdvisor(this.advisorAdapterRegistry.wrap(createMainInterceptor()));
if (this.postInterceptors != null) {
for (int i = 0; i < this.postInterceptors.length; i++) {
proxyFactory.addAdvisor(this.advisorAdapterRegistry.wrap(this.postInterceptors[i]));
}
}
proxyFactory.copyFrom(this);
//这里创建AOP的目标源
TargetSource targetSource = createTargetSource(this.target);
proxyFactory.setTargetSource(targetSource);
if (this.proxyInterfaces != null) {
proxyFactory.setInterfaces(this.proxyInterfaces);
}
else if (!isProxyTargetClass()) {
proxyFactory.setInterfaces(ClassUtils.getAllInterfacesForClass(targetSource.getTargetClass()));
}
this.proxy = getProxy(proxyFactory);
}
Spring 已经定义了一个transctionInterceptor作为拦截器或者AOP advice的实现，在IOC容器中定义的其他属性比如transactionManager
和事务管理的属性都会传到已经定义好的 TransactionInterceptor那里去进行处理。以上反映了基本的Spring AOP的定义过程，其中
pointcut和advice都已经定义好，同时也通过通知器配置到ProxyFactory中去了。
下面让我们回到TransactionProxyFactoryBean中看看TransactionAttributeSourceAdvisor是怎样定义的，这样我们可以理解具体的属性是
怎样起作用，这里我们分析一下类TransactionAttributeSourceAdvisor:
public class TransactionAttributeSourceAdvisor extends AbstractPointcutAdvisor {
//和其他Advisor一样，同样需要定义AOP中的用到的Interceptor和Pointcut
//Interceptor使用传进来的TransactionInterceptor
//而对于pointcut,这里定义了一个内部类，参见下面的代码
private TransactionInterceptor transactionInterceptor;
private final TransactionAttributeSourcePointcut pointcut = new TransactionAttributeSourcePointcut();
.........
//定义的PointCut内部类
private class TransactionAttributeSourcePointcut extends StaticMethodMatcherPointcut implements Serializable {
.......
//方法匹配的实现，使用了TransactionAttributeSource类
public boolean matches(Method method, Class targetClass) {
TransactionAttributeSource tas = getTransactionAttributeSource();
//这里使用TransactionAttributeSource来对配置属性进行处理
return (tas != null && tas.getTransactionAttribute(method, targetClass) != null);
}
........省略了equal,hashcode,tostring的代码
}
这里我们看看属性值是怎样被读入的：AbstractFallbackTransactionAttributeSource负责具体的属性读入任务，我们可以有两种读入方
式，比如annotation和直接配置.我们下面看看直接配置的读入方式，在Spring中同时对读入的属性值进行了缓存处理，这是一个
decorator模式：
public final TransactionAttribute getTransactionAttribute(Method method, Class targetClass) {
//这里先查一下缓存里有没有事务管理的属性配置，如果有从缓存中取得TransactionAttribute
Object cacheKey = getCacheKey(method, targetClass);
Object cached = this.cache.get(cacheKey);
if (cached != null) {
if (cached == NULL_TRANSACTION_ATTRIBUTE) {
return null;
}
else {
return (TransactionAttribute) cached;
}
}
else {
// 这里通过对方法和目标对象的信息来计算事务缓存属性
TransactionAttribute txAtt = computeTransactionAttribute(method, targetClass);
//把得到的事务缓存属性存到缓存中，下次可以直接从缓存中取得。
if (txAtt == null) {
this.cache.put(cacheKey, NULL_TRANSACTION_ATTRIBUTE);
}
else {
...........
this.cache.put(cacheKey, txAtt);
}
return txAtt;
}
}
别急，基本的处理在computeTransactionAttribute（）中：
private TransactionAttribute computeTransactionAttribute(Method method, Class targetClass) {
//这里检测是不是public方法
if(allowPublicMethodsOnly() && !Modifier.isPublic(method.getModifiers())) {
return null;
}
Method specificMethod = AopUtils.getMostSpecificMethod(method, targetClass);
// First try is the method in the target class.
TransactionAttribute txAtt = findTransactionAttribute(findAllAttributes(specificMethod));
if (txAtt != null) {
return txAtt;
}
// Second try is the transaction attribute on the target class.
txAtt = findTransactionAttribute(findAllAttributes(specificMethod.getDeclaringClass()));
if (txAtt != null) {
return txAtt;
}
if (specificMethod != method) {
// Fallback is to look at the original method.
txAtt = findTransactionAttribute(findAllAttributes(method));
if (txAtt != null) {
return txAtt;
}
// Last fallback is the class of the original method.
return findTransactionAttribute(findAllAttributes(method.getDeclaringClass()));
}
return null;
}
经过一系列的尝试我们可以通过findTransactionAttribute（）通过调用findAllAttribute()得到TransactionAttribute的对象，如果返回的是
null,这说明该方法不是我们需要事务处理的方法。
在完成把需要的通知器加到ProxyFactory中去的基础上，我们看看具体的看事务处理代码怎样起作用，在TransactionInterceptor中：
public Object invoke(final MethodInvocation invocation) throws Throwable {
//这里得到目标对象
Class targetClass = (invocation.getThis() != null ? invocation.getThis().getClass() : null);
//这里同样的通过判断是否能够得到TransactionAttribute来决定是否对当前方法进行事务处理，有可能该属性已经被缓存，
//具体可以参考上面对getTransactionAttribute的分析，同样是通过TransactionAttributeSource
final TransactionAttribute txAttr =
getTransactionAttributeSource().getTransactionAttribute(invocation.getMethod(), targetClass);
final String joinpointIdentification = methodIdentification(invocation.getMethod());
//这里判断我们使用了什么TransactionManager
if (txAttr == null || !(getTransactionManager() instanceof CallbackPreferringPlatformTransactionManager)) {
// 这里创建事务，同时把创建事务过程中得到的信息放到TransactionInfo中去
TransactionInfo txInfo = createTransactionIfNecessary(txAttr, joinpointIdentification);
Object retVal = null;
try {
retVal = invocation.proceed();
}
catch (Throwable ex) {
// target invocation exception
completeTransactionAfterThrowing(txInfo, ex);
throw ex;
}
finally {
cleanupTransactionInfo(txInfo);
}
commitTransactionAfterReturning(txInfo);
return retVal;
}
else {
// 使用的是Spring定义的PlatformTransactionManager同时实现了回调接口,我们通过其回调函数完成事务处理，就像我们使用编程式try {
Object result = ((CallbackPreferringPlatformTransactionManager) getTransactionManager()).execute(txAttr,
new TransactionCallback() {
public Object doInTransaction(TransactionStatus status) {
//同样的需要一个TransactonInfo
TransactionInfo txInfo = prepareTransactionInfo(txAttr, joinpointIdentification, status);
try {
return invocation.proceed();
}
.....这里省去了异常处理和事务信息的清理代码
});
...........
}
}
这里面涉及到事务的创建，我们可以在TransactionAspectSupport实现的事务管理代码：
protected TransactionInfo createTransactionIfNecessary(
TransactionAttribute txAttr, final String joinpointIdentification) {
// If no name specified, apply method identification as transaction name.
if (txAttr != null && txAttr.getName() == null) {
txAttr = new DelegatingTransactionAttribute(txAttr) {
public String getName() {
return joinpointIdentification;
}
};
}
TransactionStatus status = null;
if (txAttr != null) {
//这里使用了我们定义好的事务配置信息,有事务管理器来创建事务，同时返回TransactionInfo
status = getTransactionManager().getTransaction(txAttr);
}
return prepareTransactionInfo(txAttr, joinpointIdentification, status);
}
首先通过TransactionManager得到需要的事务，事务的创建根据我们定义的事务配置决定，在 AbstractTransactionManager中给出一个
标准的创建过程，当然创建什么样的事务还是需要具体的 PlatformTransactionManager来决定，但这里给出了创建事务的模板：
public final TransactionStatus getTransaction(TransactionDefinition definition) throws TransactionException {
Object transaction = doGetTransaction();
......
if (definition == null) {
//如果事务信息没有被配置，我们使用Spring默认的配置方式
definition = new DefaultTransactionDefinition();
}
if (isExistingTransaction(transaction)) {
// Existing transaction found -> check propagation behavior to find out how to behave.
return handleExistingTransaction(definition, transaction, debugEnabled);
}
// Check definition settings for new transaction.
//下面就是使用配置信息来创建我们需要的事务;比如传播属性和同步属性等
//最后把创建过程中的信息收集起来放到TransactionStatus中返回；
if (definition.getTimeout() < TransactionDefinition.TIMEOUT_DEFAULT) {
throw new InvalidTimeoutException("Invalid transaction timeout", definition.getTimeout());
}
// No existing transaction found -> check propagation behavior to find out how to behave.
if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_MANDATORY) {
throw new IllegalTransactionStateException(
"Transaction propagation 'mandatory' but no existing transaction found");
}
else if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRED ||
definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRES_NEW ||
definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NESTED) {
//这里是事务管理器创建事务的地方，并将创建过程中得到的信息放到TransactionStatus中去，包括创建出来的事务
doBegin(transaction, definition);
boolean newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER);
return newTransactionStatus(definition, transaction, true, newSynchronization, debugEnabled, null);
}
else {
boolean newSynchronization = (getTransactionSynchronization() == SYNCHRONIZATION_ALWAYS);
return newTransactionStatus(definition, null, false, newSynchronization, debugEnabled, null);
}
}
接着通过调用prepareTransactionInfo完成事务创建的准备，创建过程中得到的信息存储在TransactionInfo对象中进行传递同时把信息
和当前线程绑定；
protected TransactionInfo prepareTransactionInfo(
TransactionAttribute txAttr, String joinpointIdentification, TransactionStatus status) {
TransactionInfo txInfo = new TransactionInfo(txAttr, joinpointIdentification);
if (txAttr != null) {
.....
// 同样的需要把在getTransaction中得到的TransactionStatus放到TransactionInfo中来。
txInfo.newTransactionStatus(status);
}
else {
.......
}
// 绑定事务创建信息到当前线程
txInfo.bindToThread();
return txInfo;
}
将创建事务的信息返回，然后看到其他的事务管理代码：
protected void commitTransactionAfterReturning(TransactionInfo txInfo) {
if (txInfo != null && txInfo.hasTransaction()) {
if (logger.isDebugEnabled()) {
logger.debug("Invoking commit for transaction on " + txInfo.getJoinpointIdentification());
}
this.transactionManager.commit(txInfo.getTransactionStatus());
}
}
通过transactionManager对事务进行处理，包括异常抛出和正常的提交事务，具体的事务管理器由用户程序设定。
protected void completeTransactionAfterThrowing(TransactionInfo txInfo, Throwable ex) {
if (txInfo != null && txInfo.hasTransaction()) {
if (txInfo.transactionAttribute.rollbackOn(ex)) {
......
try {
this.transactionManager.rollback(txInfo.getTransactionStatus());
}
..........
}
else {
.........
try {
this.transactionManager.commit(txInfo.getTransactionStatus());
}
...........
}
protected void commitTransactionAfterReturning(TransactionInfo txInfo) {
if (txInfo != null && txInfo.hasTransaction()) {
......
this.transactionManager.commit(txInfo.getTransactionStatus());
}
}
Spring通过以上代码对transactionManager进行事务处理的过程进行了AOP包装，到这里我们看到为了方便客户实现声明式的事务处
理，Spring还是做了许多工作的。如果说使用编程式事务处理，过程其实比较清楚，我们可以参考书中的例子：
TransactionDefinition td = new DefaultTransactionDefinition();
TransactionStatus status = transactionManager.getTransaction(td);
try{
......//这里是我们的业务方法
}catch (ApplicationException e) {
transactionManager.rollback(status);
throw e
}
transactionManager.commit(status);
........
我们看到这里选取了默认的事务配置DefaultTransactionDefinition，同时在创建事物的过程中得到TransactionStatus,然后通过直接调用
事务管理器的相关方法就能完成事务处理。
声明式事务处理也同样实现了类似的过程，只是因为采用了声明的方法，需要增加对属性的读取处理，并且需要把整个过程整合到
Spring AOP框架中和IoC容器中去的过程。
下面我们选取一个具体的transactionManager - DataSourceTransactionManager来看看其中事务处理的实现：
同样的通过使用AbstractPlatformTransactionManager使用模板方法，这些都体现了对具体平台相关的事务管理器操作的封装，比如
commit：
public final void commit(TransactionStatus status) throws TransactionException {
......
DefaultTransactionStatus defStatus = (DefaultTransactionStatus) status;
if (defStatus.isLocalRollbackOnly()) {
......
processRollback(defStatus);
return;
}
.......
processRollback(defStatus);
......
}
processCommit(defStatus);
}
通过对TransactionStatus的具体状态的判断，来决定具体的事务处理：
private void processCommit(DefaultTransactionStatus status) throws TransactionException {
try {
boolean beforeCompletionInvoked = false;
try {
triggerBeforeCommit(status);
triggerBeforeCompletion(status);
beforeCompletionInvoked = true;
boolean globalRollbackOnly = false;
if (status.isNewTransaction() || isFailEarlyOnGlobalRollbackOnly()) {
globalRollbackOnly = status.isGlobalRollbackOnly();
}
if (status.hasSavepoint()) {
........
status.releaseHeldSavepoint();
}
else if (status.isNewTransaction()) {
......
doCommit(status);
}
.........
}
这些模板方法的实现由具体的transactionManager来实现，比如在DataSourceTransactionManager:
protected void doCommit(DefaultTransactionStatus status) {
//这里得到存在TransactionInfo中已经创建好的事务
DataSourceTransactionObject txObject = (DataSourceTransactionObject) status.getTransaction();
//这里得到和事务绑定的数据库连接
Connection con = txObject.getConnectionHolder().getConnection();
........
try {
//这里通过数据库连接来提交事务
con.commit();
}
.......
}
protected void doRollback(DefaultTransactionStatus status) {
DataSourceTransactionObject txObject = (DataSourceTransactionObject) status.getTransaction();
Connection con = txObject.getConnectionHolder().getConnection();
if (status.isDebug()) {
logger.debug("Rolling back JDBC transaction on Connection [" + con + "]");
}
try {
//这里通过数据库连接来回滚事务
con.rollback();
}
catch (SQLException ex) {
throw new TransactionSystemException("Could not roll back JDBC transaction", ex);
}
}
我们看到在DataSourceTransactionManager中最后还是交给connection来实现事务的提交和rollback。整个声明式事务处理是事务处理
在Spring AOP中的应用，我们看到了一个很好的使用Spring AOP的例子，在Spring声明式事务处理的源代码中我们可以看到：
1.怎样封装各种不同平台下的事务处理代码
2.怎样读取属性值和结合事务处理代码来完成既定的事务处理策略
3.怎样灵活的使用SpringAOP框架。
如果能够结合前面的Spring AOP的源代码来学习，理解可能会更深刻些。
1.7 Spring源代码解析（七）：Spring AOP中对拦截器调用的实现
发表时间: 2007-08-01
前面我们分析了Spring AOP实现中得到Proxy对象的过程，下面我们看看在Spring AOP中拦截器链是怎样被调用的，也就是Proxy模式是
怎样起作用的，或者说Spring是怎样为我们提供AOP功能的；
在JdkDynamicAopProxy中生成Proxy对象的时候：
return Proxy.newProxyInstance(classLoader, proxiedInterfaces, this);
这里的this参数对应的是InvocationHandler对象,这里我们的JdkDynamicAopProxy实现了这个接口，也就是说当Proxy对象的函数被调用
的时候，这个InvocationHandler的invoke方法会被作为回调函数调用，下面我们看看这个方法的实现：
public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
MethodInvocation invocation = null;
Object oldProxy = null;
boolean setProxyContext = false;
TargetSource targetSource = this.advised.targetSource;
Class targetClass = null;
Object target = null;
try {
// Try special rules for equals() method and implementation of the
// Advised AOP configuration interface.
if (!this.equalsDefined && AopUtils.isEqualsMethod(method)) {
// What if equals throws exception!?
// This class implements the equals(Object) method itself.
return equals(args[0]) ? Boolean.TRUE : Boolean.FALSE;
}
if (!this.hashCodeDefined && AopUtils.isHashCodeMethod(method)) {
// This class implements the hashCode() method itself.
return new Integer(hashCode());
}
if (Advised.class == method.getDeclaringClass()) {
// service invocations on ProxyConfig with the proxy config
return AopUtils.invokeJoinpointUsingReflection(this.advised, method, args);
}
Object retVal = null;
if (this.advised.exposeProxy) {
// make invocation available if necessary
oldProxy = AopContext.setCurrentProxy(proxy);
setProxyContext = true;
}
// May be <code>null</code>. Get as late as possible to minimize the time we "own" the target,
// in case it comes from a pool.
// 这里是得到目标对象的地方，当然这个目标对象可能来自于一个实例池或者是一个简单的JAVA对象
target = targetSource.getTarget();
if (target != null) {
targetClass = target.getClass();
}
// get the interception chain for this method
// 这里获得定义好的拦截器链
List chain = this.advised.advisorChainFactory.getInterceptorsAndDynamicInterceptionAdvice(
this.advised, proxy, method, targetClass);
// Check whether we have any advice. If we don't, we can fallback on direct
// reflective invocation of the target, and avoid creating a MethodInvocation.
// 如果没有设定拦截器，那么我们就直接调用目标的对应方法
if (chain.isEmpty()) {
// We can skip creating a MethodInvocation: just invoke the target directly
// Note that the final invoker must be an InvokerInterceptor so we know it does
// nothing but a reflective operation on the target, and no hot swapping or fancy proxying
retVal = AopUtils.invokeJoinpointUsingReflection(target, method, args);
}
else {
// We need to create a method invocation...
// invocation = advised.getMethodInvocationFactory().getMethodInvocation(
// proxy, method, targetClass, target, args, chain, advised);
// 如果有拦截器的设定，那么需要调用拦截器之后才调用目标对象的相应方法
// 这里通过构造一个ReflectiveMethodInvocation来实现，下面我们会看这个ReflectiveMethodInvocation类
invocation = new ReflectiveMethodInvocation(
proxy, target, method, args, targetClass, chain);
// proceed to the joinpoint through the interceptor chain
// 这里通过ReflectiveMethodInvocation来调用拦截器链和相应的目标方法
retVal = invocation.proceed();
}
// massage return value if necessary
if (retVal != null && retVal == target && method.getReturnType().isInstance(proxy)) {
// Special case: it returned "this" and the return type of the method is type-compatible
// Note that we can't help if the target sets
// a reference to itself in another returned object.
retVal = proxy;
}
return retVal;
}
finally {
if (target != null && !targetSource.isStatic()) {
// must have come from TargetSource
targetSource.releaseTarget(target);
}
if (setProxyContext) {
// restore old proxy
AopContext.setCurrentProxy(oldProxy);
}
}
}
我们先看看目标对象方法的调用，这里是通过AopUtils的方法调用 - 使用反射机制来对目标对象的方法进行调用：
public static Object invokeJoinpointUsingReflection(Object target, Method method, Object[] args)
throws Throwable {
// Use reflection to invoke the method.
// 利用放射机制得到相应的方法，并且调用invoke
try {
if (!Modifier.isPublic(method.getModifiers()) ||
!Modifier.isPublic(method.getDeclaringClass().getModifiers())) {
method.setAccessible(true);
}
return method.invoke(target, args);
}
catch (InvocationTargetException ex) {
// Invoked method threw a checked exception.
// We must rethrow it. The client won't see the interceptor.
throw ex.getTargetException();
}
catch (IllegalArgumentException ex) {
throw new AopInvocationException("AOP configuration seems to be invalid: tried calling method [" +
method + "] on target [" + target + "]", ex);
}
catch (IllegalAccessException ex) {
throw new AopInvocationException("Couldn't access method: " + method, ex);
}
}
对拦截器链的调用处理是在ReflectiveMethodInvocation里实现的：
public Object proceed() throws Throwable {
// We start with an index of -1 and increment early.
// 这里直接调用目标对象的方法，没有拦截器的调用或者拦截器已经调用完了，这个currentInterceptorIndex的初始值是0
if (this.currentInterceptorIndex == this.interceptorsAndDynamicMethodMatchers.size()) {
return invokeJoinpoint();
}
Object interceptorOrInterceptionAdvice =
this.interceptorsAndDynamicMethodMatchers.get(this.currentInterceptorIndex);
if (interceptorOrInterceptionAdvice instanceof InterceptorAndDynamicMethodMatcher) {
// Evaluate dynamic method matcher here: static part will already have
// been evaluated and found to match.
// 这里获得相应的拦截器，如果拦截器可以匹配的上的话，那就调用拦截器的invoke方法
InterceptorAndDynamicMethodMatcher dm =
(InterceptorAndDynamicMethodMatcher) interceptorOrInterceptionAdvice;
if (dm.methodMatcher.matches(this.method, this.targetClass, this.arguments)) {
return dm.interceptor.invoke(nextInvocation());
}
else {
// Dynamic matching failed.
// Skip this interceptor and invoke the next in the chain.
// 如果拦截器匹配不上，那就调用下一个拦截器，这个时候拦截器链的位置指示后移并迭代调用当前的proceed方法
this.currentInterceptorIndex++;
return proceed();
}
}
else {
// It's an interceptor, so we just invoke it: The pointcut will have
// been evaluated statically before this object was constructed.
return ((MethodInterceptor) interceptorOrInterceptionAdvice).invoke(nextInvocation());
}
}
http://jiwenke.javaeye.com 1.7 Spring源代码解析（七）：Spring AOP中对拦截器调用的实现
第 62 / 90 页
这里把当前的拦截器链以及在拦截器链的位置标志都clone到一个MethodInvocation对象了，作用是当前的拦截器执行完之后，会继续
沿着得到这个拦截器链执行下面的拦截行为，也就是会迭代的调用上面这个proceed:
private ReflectiveMethodInvocation nextInvocation() throws CloneNotSupportedException {
ReflectiveMethodInvocation invocation = (ReflectiveMethodInvocation) clone();
invocation.currentInterceptorIndex = this.currentInterceptorIndex + 1;
invocation.parent = this;
return invocation;
}
这里的nextInvocation就已经包含了当前的拦截链的基本信息，我们看到在Interceptor中的实现比如TransactionInterceptor的实现中：
public Object invoke(final MethodInvocation invocation) throws Throwable {
......//这里是TransactionInterceptor插入的事务处理代码，我们会在后面分析事务处理实现的时候进行分析
try {
//这里是对配置的拦截器链进行迭代处理的调用
retVal = invocation.proceed();
}
......//省略了和事务处理的异常处理代码，也是TransactionInterceptor插入的处理
else {
try {
Object result = ((CallbackPreferringPlatformTransactionManager) getTransactionManager()).execute(txAttr,
new TransactionCallback() {
public Object doInTransaction(TransactionStatus status) {
//这里是TransactionInterceptor插入对事务处理的代码
TransactionInfo txInfo = prepareTransactionInfo(txAttr, joinpointIdentification, status);
//这里是对配置的拦截器链进行迭代处理的调用，接着顺着拦截器进行处理
try {
return invocation.proceed();
}
......//省略了和事务处理的异常处理代码，也是TransactionInterceptor插入的处理
}
从上面的分析我们看到了Spring AOP的基本实现，比如Spring怎样得到Proxy,怎样利用JAVA Proxy以及反射机制对用户定义的拦截器链
进行处理。
http://jiwenke.javaeye.com 1.7 Spring源代码解析（七）：Spring AOP中对拦截器调用的实现
第 63 / 90 页
1.8 Spring源代码解析（八）：Spring驱动Hibernate的实现
发表时间: 2007-08-10
O/R工具出现之后，简化了许多复杂的信息持久化的开发。Spring应用开发者可以通过Spring提供的O/R方案更方便的使用各种持久化
工具，比如Hibernate；下面我们就Spring+Hibernate中的Spring实现做一个简单的剖析。
Spring对Hinberanate的配置是通过LocalSessionFactoryBean来完成的，这是一个工厂Bean的实现，在基类
AbstractSessionFactoryBean中：
/**
* 这是FactoryBean需要实现的接口方法，直接取得当前的sessionFactory的值
*/
public Object getObject() {
return this.sessionFactory;
}
这个值在afterPropertySet中定义：
public void afterPropertiesSet() throws Exception {
//这个buildSessionFactory是通过配置信息得到SessionFactory的地方
SessionFactory rawSf = buildSessionFactory();
//这里使用了Proxy方法插入对getCurrentSession的拦截，得到和事务相关的session
this.sessionFactory = wrapSessionFactoryIfNecessary(rawSf);
}
我们先看看SessionFactory是怎样创建的，这个方法很长，包含了创建Hibernate的SessionFactory的详尽步骤：
protected SessionFactory buildSessionFactory() throws Exception {
SessionFactory sf = null;
// Create Configuration instance.
Configuration config = newConfiguration();
//这里配置数据源，事务管理器，LobHander到Holder中，这个Holder是一个ThreadLocal变量,这样这些资源就和线程绑定了
if (this.dataSource != null) {
// Make given DataSource available for SessionFactory configuration.
configTimeDataSourceHolder.set(this.dataSource);
}
if (this.jtaTransactionManager != null) {
// Make Spring-provided JTA TransactionManager available.
configTimeTransactionManagerHolder.set(this.jtaTransactionManager);
http://jiwenke.javaeye.com 1.8 Spring源代码解析（八）：Spring驱动Hibernate的实现
第 64 / 90 页
}
if (this.lobHandler != null) {
// Make given LobHandler available for SessionFactory configuration.
// Do early because because mapping resource might refer to custom types.
configTimeLobHandlerHolder.set(this.lobHandler);
}
//这里是使用Hibernate的各个属性的配置，这里使用了Configuration类来抽象这些数据
try {
// Set connection release mode "on_close" as default.
// This was the case for Hibernate 3.0; Hibernate 3.1 changed
// it to "auto" (i.e. "after_statement" or "after_transaction").
// However, for Spring's resource management (in particular for
// HibernateTransactionManager), "on_close" is the better default.
config.setProperty(Environment.RELEASE_CONNECTIONS, ConnectionReleaseMode.ON_CLOSE.toString());
if (!isExposeTransactionAwareSessionFactory()) {
// Not exposing a SessionFactory proxy with transaction-aware
// getCurrentSession() method -> set Hibernate 3.1 CurrentSessionContext
// implementation instead, providing the Spring-managed Session that way.
// Can be overridden by a custom value for corresponding Hibernate property.
config.setProperty(Environment.CURRENT_SESSION_CONTEXT_CLASS,
"org.springframework.orm.hibernate3.SpringSessionContext");
}
if (this.entityInterceptor != null) {
// Set given entity interceptor at SessionFactory level.
config.setInterceptor(this.entityInterceptor);
}
if (this.namingStrategy != null) {
// Pass given naming strategy to Hibernate Configuration.
config.setNamingStrategy(this.namingStrategy);
}
if (this.typeDefinitions != null) {
// Register specified Hibernate type definitions.
Mappings mappings = config.createMappings();
for (int i = 0; i < this.typeDefinitions.length; i++) {
TypeDefinitionBean typeDef = this.typeDefinitions[i];
mappings.addTypeDef(typeDef.getTypeName(), typeDef.getTypeClass(), typeDef.getParameters());
http://jiwenke.javaeye.com 1.8 Spring源代码解析（八）：Spring驱动Hibernate的实现
第 65 / 90 页
}
}
if (this.filterDefinitions != null) {
// Register specified Hibernate FilterDefinitions.
for (int i = 0; i < this.filterDefinitions.length; i++) {
config.addFilterDefinition(this.filterDefinitions[i]);
}
}
if (this.configLocations != null) {
for (int i = 0; i < this.configLocations.length; i++) {
// Load Hibernate configuration from given location.
config.configure(this.configLocations[i].getURL());
}
}
if (this.hibernateProperties != null) {
// Add given Hibernate properties to Configuration.
config.addProperties(this.hibernateProperties);
}
if (this.dataSource != null) {
boolean actuallyTransactionAware =
(this.useTransactionAwareDataSource || this.dataSource instanceof TransactionAwareDataSourceProxy);
// Set Spring-provided DataSource as Hibernate ConnectionProvider.
config.setProperty(Environment.CONNECTION_PROVIDER,
actuallyTransactionAware ?
TransactionAwareDataSourceConnectionProvider.class.getName() :
LocalDataSourceConnectionProvider.class.getName());
}
if (this.jtaTransactionManager != null) {
// Set Spring-provided JTA TransactionManager as Hibernate property.
config.setProperty(
Environment.TRANSACTION_MANAGER_STRATEGY, LocalTransactionManagerLookup.class.getName());
}
if (this.mappingLocations != null) {
// Register given Hibernate mapping definitions, contained in resource files.
for (int i = 0; i < this.mappingLocations.length; i++) {
config.addInputStream(this.mappingLocations[i].getInputStream());
http://jiwenke.javaeye.com 1.8 Spring源代码解析（八）：Spring驱动Hibernate的实现
第 66 / 90 页
}
}
if (this.cacheableMappingLocations != null) {
// Register given cacheable Hibernate mapping definitions, read from the file system.
for (int i = 0; i < this.cacheableMappingLocations.length; i++) {
config.addCacheableFile(this.cacheableMappingLocations[i].getFile());
}
}
if (this.mappingJarLocations != null) {
// Register given Hibernate mapping definitions, contained in jar files.
for (int i = 0; i < this.mappingJarLocations.length; i++) {
Resource resource = this.mappingJarLocations[i];
config.addJar(resource.getFile());
}
}
if (this.mappingDirectoryLocations != null) {
// Register all Hibernate mapping definitions in the given directories.
for (int i = 0; i < this.mappingDirectoryLocations.length; i++) {
File file = this.mappingDirectoryLocations[i].getFile();
if (!file.isDirectory()) {
throw new IllegalArgumentException(
"Mapping directory location [" + this.mappingDirectoryLocations[i] +
"] does not denote a directory");
}
config.addDirectory(file);
}
}
if (this.entityCacheStrategies != null) {
// Register cache strategies for mapped entities.
for (Enumeration classNames = this.entityCacheStrategies.propertyNames(); classNames.hasMoreElements();) {
String className = (String) classNames.nextElement();
String[] strategyAndRegion =
StringUtils.commaDelimitedListToStringArray(this.entityCacheStrategies.getProperty(className));
if (strategyAndRegion.length > 1) {
config.setCacheConcurrencyStrategy(className, strategyAndRegion[0], strategyAndRegion[1]);
}
else if (strategyAndRegion.length > 0) {
config.setCacheConcurrencyStrategy(className, strategyAndRegion[0]);
http://jiwenke.javaeye.com 1.8 Spring源代码解析（八）：Spring驱动Hibernate的实现
第 67 / 90 页
}
}
}
if (this.collectionCacheStrategies != null) {
// Register cache strategies for mapped collections.
for (Enumeration collRoles = this.collectionCacheStrategies.propertyNames(); collRoles.hasMoreElements();) {
String collRole = (String) collRoles.nextElement();
String[] strategyAndRegion =
StringUtils.commaDelimitedListToStringArray(this.collectionCacheStrategies.getProperty(collRole));
if (strategyAndRegion.length > 1) {
config.setCollectionCacheConcurrencyStrategy(collRole, strategyAndRegion[0], strategyAndRegion[1]);
}
else if (strategyAndRegion.length > 0) {
config.setCollectionCacheConcurrencyStrategy(collRole, strategyAndRegion[0]);
}
}
}
if (this.eventListeners != null) {
// Register specified Hibernate event listeners.
for (Iterator it = this.eventListeners.entrySet().iterator(); it.hasNext();) {
Map.Entry entry = (Map.Entry) it.next();
Assert.isTrue(entry.getKey() instanceof String, "Event listener key needs to be of type String");
String listenerType = (String) entry.getKey();
Object listenerObject = entry.getValue();
if (listenerObject instanceof Collection) {
Collection listeners = (Collection) listenerObject;
EventListeners listenerRegistry = config.getEventListeners();
Object[] listenerArray =
(Object[]) Array.newInstance(listenerRegistry.getListenerClassFor(listenerType), listeners.size());
listenerArray = listeners.toArray(listenerArray);
config.setListeners(listenerType, listenerArray);
}
else {
config.setListener(listenerType, listenerObject);
}
}
}
// Perform custom post-processing in subclasses.
postProcessConfiguration(config);
http://jiwenke.javaeye.com 1.8 Spring源代码解析（八）：Spring驱动Hibernate的实现
第 68 / 90 页
// 这里是根据Configuration配置创建SessionFactory的地方
logger.info("Building new Hibernate SessionFactory");
this.configuration = config;
sf = newSessionFactory(config);
}
//最后把和线程绑定的资源清空
finally {
if (this.dataSource != null) {
// Reset DataSource holder.
configTimeDataSourceHolder.set(null);
}
if (this.jtaTransactionManager != null) {
// Reset TransactionManager holder.
configTimeTransactionManagerHolder.set(null);
}
if (this.lobHandler != null) {
// Reset LobHandler holder.
configTimeLobHandlerHolder.set(null);
}
}
// Execute schema update if requested.
if (this.schemaUpdate) {
updateDatabaseSchema();
}
return sf;
}
而直接调用org.hibernate.cfg.Configuration来得到需要的SessionFactory:
protected SessionFactory newSessionFactory(Configuration config) throws HibernateException {
return config.buildSessionFactory();
}
所以我们这里看到LocalSessionFactory大致起到的一个读取资源配置然后生成SessionFactory的作用；当然这里在得到 SessionFactory
之后，还需要对session的事务管理作一些处理 - 使用了一个Proxy模式对getCurrentSession方法进行了拦截；
http://jiwenke.javaeye.com 1.8 Spring源代码解析（八）：Spring驱动Hibernate的实现
第 69 / 90 页
//这里先根据当前的SessionFactory的类型得到Proxy，然后插入Spring定义好的getCurrentSession拦截器
protected SessionFactory getTransactionAwareSessionFactoryProxy(SessionFactory target) {
Class sfInterface = SessionFactory.class;
if (target instanceof SessionFactoryImplementor) {
sfInterface = SessionFactoryImplementor.class;
}
return (SessionFactory) Proxy.newProxyInstance(sfInterface.getClassLoader(),
new Class[] {sfInterface}, new TransactionAwareInvocationHandler(target));
}
拦截器的实现如下：
private static class TransactionAwareInvocationHandler implements InvocationHandler {
private final SessionFactory target;
public TransactionAwareInvocationHandler(SessionFactory target) {
this.target = target;
}
public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
// Invocation on SessionFactory/SessionFactoryImplementor interface coming in...
// 这里对getCurrentSession方法进行拦截，得到一个和当前事务绑定的session交给用户
if (method.getName().equals("getCurrentSession")) {
// Handle getCurrentSession method: return transactional Session, if any.
try {
return SessionFactoryUtils.doGetSession((SessionFactory) proxy, false);
}
catch (IllegalStateException ex) {
throw new HibernateException(ex.getMessage());
}
}
else if (method.getName().equals("equals")) {
// Only consider equal when proxies are identical.
return (proxy == args[0] ? Boolean.TRUE : Boolean.FALSE);
}
else if (method.getName().equals("hashCode")) {
// Use hashCode of SessionFactory proxy.
return new Integer(hashCode());
}
// 这里是需要运行的SessionFactory的目标方法
try {
return method.invoke(this.target, args);
}
catch (InvocationTargetException ex) {
throw ex.getTargetException();
}
}
}
我们看看getCurrentSession的实现，在SessionFactoryUtils中：
private static Session doGetSession(
SessionFactory sessionFactory, Interceptor entityInterceptor,
SQLExceptionTranslator jdbcExceptionTranslator, boolean allowCreate)
throws HibernateException, IllegalStateException {
Assert.notNull(sessionFactory, "No SessionFactory specified");
//这个TransactionSynchronizationManager的Resource是一个ThreadLocal变量,sessionFactory是一个单例，但ThreadLocal是和线程绑定//这样就实现了Hiberante中常用的通过ThreadLocal的session管理机制
SessionHolder sessionHolder = (SessionHolder) TransactionSynchronizationManager.getResource(sessionFactory);
if (sessionHolder != null && !sessionHolder.isEmpty()) {
// pre-bound Hibernate Session
Session session = null;
if (TransactionSynchronizationManager.isSynchronizationActive() &&
sessionHolder.doesNotHoldNonDefaultSession()) {
// Spring transaction management is active ->
// register pre-bound Session with it for transactional flushing.
session = sessionHolder.getValidatedSession();
if (session != null && !sessionHolder.isSynchronizedWithTransaction()) {
logger.debug("Registering Spring transaction synchronization for existing Hibernate Session");
TransactionSynchronizationManager.registerSynchronization(
new SpringSessionSynchronization(sessionHolder, sessionFactory, jdbcExceptionTranslator, false));
sessionHolder.setSynchronizedWithTransaction(true);
// Switch to FlushMode.AUTO, as we have to assume a thread-bound Session
// with FlushMode.NEVER, which needs to allow flushing within the transaction.
FlushMode flushMode = session.getFlushMode();
if (flushMode.lessThan(FlushMode.COMMIT) &&
!TransactionSynchronizationManager.isCurrentTransactionReadOnly()) {
session.setFlushMode(FlushMode.AUTO);
sessionHolder.setPreviousFlushMode(flushMode);
}
}
}
else {
// No Spring transaction management active -> try JTA transaction synchronization.
session = getJtaSynchronizedSession(sessionHolder, sessionFactory, jdbcExceptionTranslator);
}
if (session != null) {
return session;
}
}
//这里直接打开一个Session
logger.debug("Opening Hibernate Session");
Session session = (entityInterceptor != null ?
sessionFactory.openSession(entityInterceptor) : sessionFactory.openSession());
// Use same Session for further Hibernate actions within the transaction.
// Thread object will get removed by synchronization at transaction completion.
// 把新打开的Session放到SessionHolder,然后放到ThreadLocal里面去和线程绑定起来，这个ThreadLocal是在 TransactionSynchronizationManager// 同时根据事务处理的状态来配置session的属性,比如把FlushMode设置为Never，同时把session和事务处理关联起来
if (TransactionSynchronizationManager.isSynchronizationActive()) {
// We're within a Spring-managed transaction, possibly from JtaTransactionManager.
logger.debug("Registering Spring transaction synchronization for new Hibernate Session");
SessionHolder holderToUse = sessionHolder;
if (holderToUse == null) {
holderToUse = new SessionHolder(session);
}
else {
holderToUse.addSession(session);
}
if (TransactionSynchronizationManager.isCurrentTransactionReadOnly()) {
session.setFlushMode(FlushMode.NEVER);
}
TransactionSynchronizationManager.registerSynchronization(
new SpringSessionSynchronization(holderToUse, sessionFactory, jdbcExceptionTranslator, true));
holderToUse.setSynchronizedWithTransaction(true);
if (holderToUse != sessionHolder) {
TransactionSynchronizationManager.bindResource(sessionFactory, holderToUse);
}
}
else {
// No Spring transaction management active -> try JTA transaction synchronization.
registerJtaSynchronization(session, sessionFactory, jdbcExceptionTranslator, sessionHolder);
}
// Check whether we are allowed to return the Session.
if (!allowCreate && !isSessionTransactional(session, sessionFactory)) {
closeSession(session);
throw new IllegalStateException("No Hibernate Session bound to thread, " +
"and configuration does not allow creation of non-transactional one here");
}
return session;
}
这里就是在Spring中为使用Hiberante的SessionFactory以及Session做的准备工作，在这个基础上，用户可以通过使用
HibernateTemplate来使用Hibernate的O/R功能，和以前看到的一样这是一个execute的回调：
public Object execute(HibernateCallback action, boolean exposeNativeSession) throws DataAccessException {
Assert.notNull(action, "Callback object must not be null");
//这里得到配置好的Hibernate的Session
Session session = getSession();
boolean existingTransaction = SessionFactoryUtils.isSessionTransactional(session, getSessionFactory());
if (existingTransaction) {
logger.debug("Found thread-bound Session for HibernateTemplate");
}
FlushMode previousFlushMode = null;
try {
previousFlushMode = applyFlushMode(session, existingTransaction);
enableFilters(session);
Session sessionToExpose = (exposeNativeSession ? session : createSessionProxy(session));
//这里是回调的入口
Object result = action.doInHibernate(sessionToExpose);
flushIfNecessary(session, existingTransaction);
return result;
}
catch (HibernateException ex) {
throw convertHibernateAccessException(ex);
}
catch (SQLException ex) {
throw convertJdbcAccessException(ex);
}
catch (RuntimeException ex) {
// Callback code threw application exception...
throw ex;
}
finally {
//如果这个调用的方法在一个事务当中，
if (existingTransaction) {
logger.debug("Not closing pre-bound Hibernate Session after HibernateTemplate");
disableFilters(session);
if (previousFlushMode != null) {
session.setFlushMode(previousFlushMode);
}
} //否则把Session关闭
else {
// Never use deferred close for an explicitly new Session.
if (isAlwaysUseNewSession()) {
SessionFactoryUtils.closeSession(session);
}
else {
SessionFactoryUtils.closeSessionOrRegisterDeferredClose(session, getSessionFactory());
}
}
}
}
我们看看怎样得到对应的Session的，仍然使用了SessionFactoryUtils的方法doGetSession:
protected Session getSession() {
if (isAlwaysUseNewSession()) {
return SessionFactoryUtils.getNewSession(getSessionFactory(), getEntityInterceptor());
}
else if (!isAllowCreate()) {
return SessionFactoryUtils.getSession(getSessionFactory(), false);
}
else {
return SessionFactoryUtils.getSession(
getSessionFactory(), getEntityInterceptor(), getJdbcExceptionTranslator());
}
}
这样我们就可以和其他的Template那样使用Hibernate的基本功能了，使用的时候Spring已经为我们对Session的获取和关闭，事务处理
的绑定做好了封装 - 从这个角度看也大大方便了用户的使用。
1.9 Spring源代码解析（九）：Spring Acegi框架鉴权的实现
发表时间: 2007-08-16
简单分析一下Spring Acegi的源代码实现：
Servlet.Filter的实现AuthenticationProcessingFilter启动Web页面的验证过程 - 在AbstractProcessingFilter定义了整个验证过程的模板：
public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)
throws IOException, ServletException {
//这里检验是不是符合ServletRequest/SevletResponse的要求
if (!(request instanceof HttpServletRequest)) {
throw new ServletException("Can only process HttpServletRequest");
}
if (!(response instanceof HttpServletResponse)) {
throw new ServletException("Can only process HttpServletResponse");
}
HttpServletRequest httpRequest = (HttpServletRequest) request;
HttpServletResponse httpResponse = (HttpServletResponse) response;
//根据HttpServletRequest和HttpServletResponse来进行验证
if (requiresAuthentication(httpRequest, httpResponse)) {
if (logger.isDebugEnabled()) {
logger.debug("Request is to process authentication");
}
//这里定义Acegi中的Authentication对象来持有相关的用户验证信息
Authentication authResult;
try {
onPreAuthentication(httpRequest, httpResponse);
//这里的具体验证过程委托给子类完成，比如AuthenticationProcessingFilter来完成基于Web页面的用户验证
authResult = attemptAuthentication(httpRequest);
} catch (AuthenticationException failed) {
// Authentication failed
unsuccessfulAuthentication(httpRequest, httpResponse, failed);
return;
}
// Authentication success
if (continueChainBeforeSuccessfulAuthentication) {
chain.doFilter(request, response);
}
//完成验证后的后续工作，比如跳转到相应的页面
successfulAuthentication(httpRequest, httpResponse, authResult);
return;
}
chain.doFilter(request, response);
}
在AuthenticationProcessingFilter中的具体验证过程是这样的：
public Authentication attemptAuthentication(HttpServletRequest request)
throws AuthenticationException {
//这里从HttpServletRequest中得到用户验证的用户名和密码
String username = obtainUsername(request);
String password = obtainPassword(request);
if (username == null) {
username = "";
}
if (password == null) {
password = "";
}
//这里根据得到的用户名和密码去构造一个Authentication对象提供给AuthenticationManager进行验证，里面包含了用户的用户名和密码UsernamePasswordAuthenticationToken authRequest = new UsernamePasswordAuthenticationToken(username, password);
// Place the last username attempted into HttpSession for views
request.getSession().setAttribute(ACEGI_SECURITY_LAST_USERNAME_KEY, username);
// Allow subclasses to set the "details" property
setDetails(request, authRequest);
//这里启动AuthenticationManager进行验证过程
return this.getAuthenticationManager().authenticate(authRequest);
}
在Acegi框架中，进行验证管理的主要类是AuthenticationManager,我们看看它是怎样进行验证管理的 - 验证的调用入口是authenticate
在AbstractAuthenticationManager的实现中：
//这是进行验证的函数，返回一个Authentication对象来记录验证的结果，其中包含了用户的验证信息，权限配置等，同时这个
Authentication会以后被授权模块使用
//如果验证失败，那么在验证过程中会直接抛出异常
public final Authentication authenticate(Authentication authRequest)
throws AuthenticationException {
try {//这里是实际的验证处理，我们下面使用ProviderManager来说明具体的验证过程，传入的参数authRequest里面已经包含了从HttpServletRequestAuthentication authResult = doAuthentication(authRequest);
copyDetails(authRequest, authResult);
return authResult;
} catch (AuthenticationException e) {
e.setAuthentication(authRequest);
throw e;
}
}
在ProviderManager中进行实际的验证工作，假设这里使用数据库来存取用户信息：
public Authentication doAuthentication(Authentication authentication)
throws AuthenticationException {
//这里取得配置好的provider链的迭代器，在配置的时候可以配置多个provider,这里我们配置的是DaoAuthenticationProvider来说明, 它Iterator iter = providers.iterator();
Class toTest = authentication.getClass();
AuthenticationException lastException = null;
while (iter.hasNext()) {
AuthenticationProvider provider = (AuthenticationProvider) iter.next();
if (provider.supports(toTest)) {
logger.debug("Authentication attempt using " + provider.getClass().getName());
//这个result包含了验证中得到的结果信息
Authentication result = null;
try {//这里是provider进行验证处理的过程
result = provider.authenticate(authentication);
sessionController.checkAuthenticationAllowed(result);
} catch (AuthenticationException ae) {
lastException = ae;
result = null;
}
if (result != null) {
sessionController.registerSuccessfulAuthentication(result);
publishEvent(new AuthenticationSuccessEvent(result));
return result;
}
}
}
if (lastException == null) {
lastException = new ProviderNotFoundException(messages.getMessage("ProviderManager.providerNotFound",
new Object[] {toTest.getName()}, "No AuthenticationProvider found for {0}"));
}
// 这里发布事件来通知上下文的监听器
String className = exceptionMappings.getProperty(lastException.getClass().getName());
AbstractAuthenticationEvent event = null;
if (className != null) {
try {
Class clazz = getClass().getClassLoader().loadClass(className);
Constructor constructor = clazz.getConstructor(new Class[] {
Authentication.class, AuthenticationException.class
});
Object obj = constructor.newInstance(new Object[] {authentication, lastException});
Assert.isInstanceOf(AbstractAuthenticationEvent.class, obj, "Must be an AbstractAuthenticationEvent");
event = (AbstractAuthenticationEvent) obj;
} catch (ClassNotFoundException ignored) {}
catch (NoSuchMethodException ignored) {}
catch (IllegalAccessException ignored) {}
catch (InstantiationException ignored) {}
catch (InvocationTargetException ignored) {}
}
if (event != null) {
publishEvent(event);
} else {
if (logger.isDebugEnabled()) {
logger.debug("No event was found for the exception " + lastException.getClass().getName());
}
}
// Throw the exception
throw lastException;
}
我们下面看看在DaoAuthenticationProvider是怎样从数据库中取出对应的验证信息进行用户验证的，在它的基类
AbstractUserDetailsAuthenticationProvider定义了验证的处理模板：
public Authentication authenticate(Authentication authentication)
throws AuthenticationException {
Assert.isInstanceOf(UsernamePasswordAuthenticationToken.class, authentication,
messages.getMessage("AbstractUserDetailsAuthenticationProvider.onlySupports",
"Only UsernamePasswordAuthenticationToken is supported"));
// 这里取得用户输入的用户名
String username = (authentication.getPrincipal() == null) ? "NONE_PROVIDED" : authentication.getName();
// 如果配置了缓存，从缓存中去取以前存入的用户验证信息 - 这里是UserDetail，是服务器端存在数据库里的用户信息，这样就不用每次boolean cacheWasUsed = true;
UserDetails user = this.userCache.getUserFromCache(username);
//没有取到，设置标志位，下面会把这次取到的服务器端用户信息存入缓存中去
if (user == null) {
cacheWasUsed = false;
try {//这里是调用UserDetailService去取用户数据库里信息的地方
user = retrieveUser(username, (UsernamePasswordAuthenticationToken) authentication);
} catch (UsernameNotFoundException notFound) {
if (hideUserNotFoundExceptions) {
throw new BadCredentialsException(messages.getMessage(
"AbstractUserDetailsAuthenticationProvider.badCredentials", "Bad credentials"));
} else {
throw notFound;
}
}
Assert.notNull(user, "retrieveUser returned null - a violation of the interface contract");
}
if (!user.isAccountNonLocked()) {
throw new LockedException(messages.getMessage("AbstractUserDetailsAuthenticationProvider.locked",
"User account is locked"));
}
if (!user.isEnabled()) {
throw new DisabledException(messages.getMessage("AbstractUserDetailsAuthenticationProvider.disabled",
"User is disabled"));
}
if (!user.isAccountNonExpired()) {
throw new AccountExpiredException(messages.getMessage("AbstractUserDetailsAuthenticationProvider.expired",
"User account has expired"));
}
// This check must come here, as we don't want to tell users
// about account status unless they presented the correct credentials
try {//这里是验证过程，在retrieveUser中从数据库中得到用户的信息，在additionalAuthenticationChecks中进行对比用户输入和服务//如果验证通过，那么构造一个Authentication对象来让以后的授权使用，如果验证不通过，直接抛出异常结束鉴权过程
additionalAuthenticationChecks(user, (UsernamePasswordAuthenticationToken) authentication);
} catch (AuthenticationException exception) {
if (cacheWasUsed) {
// There was a problem, so try again after checking
// we're using latest data (ie not from the cache)
cacheWasUsed = false;
user = retrieveUser(username, (UsernamePasswordAuthenticationToken) authentication);
additionalAuthenticationChecks(user, (UsernamePasswordAuthenticationToken) authentication);
} else {
throw exception;
}
}
if (!user.isCredentialsNonExpired()) {
throw new CredentialsExpiredException(messages.getMessage(
"AbstractUserDetailsAuthenticationProvider.credentialsExpired", "User credentials have expired"));
}
//根据前面的缓存结果决定是不是要把当前的用户信息存入缓存以供下次验证使用
if (!cacheWasUsed) {
this.userCache.putUserInCache(user);
}
Object principalToReturn = user;
if (forcePrincipalAsString) {
principalToReturn = user.getUsername();
}
//最后返回Authentication记录了验证结果供以后的授权使用
return createSuccessAuthentication(principalToReturn, authentication, user);
}
//这是是调用UserDetailService去加载服务器端用户信息的地方，从什么地方加载要看设置，这里我们假设由JdbcDaoImp来从数据中进行加载
protected final UserDetails retrieveUser(String username, UsernamePasswordAuthenticationToken authentication)
throws AuthenticationException {
UserDetails loadedUser;
//这里调用UserDetailService去从数据库中加载用户验证信息，同时返回从数据库中返回的信息，这些信息放到了UserDetails对象中去了
try {
loadedUser = this.getUserDetailsService().loadUserByUsername(username);
} catch (DataAccessException repositoryProblem) {
throw new AuthenticationServiceException(repositoryProblem.getMessage(), repositoryProblem);
}
if (loadedUser == null) {
throw new AuthenticationServiceException(
"UserDetailsService returned null, which is an interface contract violation");
}
return loadedUser;
}
下面我们重点分析一下JdbcDaoImp这个类来看看具体是怎样从数据库中得到用户信息的：
public class JdbcDaoImpl extends JdbcDaoSupport implements UserDetailsService {
//~ Static fields/initializers =====================================================================================
//这里是预定义好的对查询语句，对应于默认的数据库表结构，也可以自己定义查询语句对应特定的用户数据库验证表的设计
public static final String DEF_USERS_BY_USERNAME_QUERY =
"SELECT username,password,enabled FROM users WHERE username = ?";
public static final String DEF_AUTHORITIES_BY_USERNAME_QUERY =
"SELECT username,authority FROM authorities WHERE username = ?";
//~ Instance fields ================================================================================================
//这里使用Spring JDBC来进行数据库操作
protected MappingSqlQuery authoritiesByUsernameMapping;
protected MappingSqlQuery usersByUsernameMapping;
private String authoritiesByUsernameQuery;
private String rolePrefix = "";
private String usersByUsernameQuery;
private boolean usernameBasedPrimaryKey = true;
//~ Constructors ===================================================================================================
//在初始化函数中把查询语句设置为预定义的SQL语句
public JdbcDaoImpl() {
usersByUsernameQuery = DEF_USERS_BY_USERNAME_QUERY;
authoritiesByUsernameQuery = DEF_AUTHORITIES_BY_USERNAME_QUERY;
}
//~ Methods ========================================================================================================
protected void addCustomAuthorities(String username, List authorities) {}
public String getAuthoritiesByUsernameQuery() {
return authoritiesByUsernameQuery;
}
public String getRolePrefix() {
return rolePrefix;
}
public String getUsersByUsernameQuery() {
return usersByUsernameQuery;
}
protected void initDao() throws ApplicationContextException {
initMappingSqlQueries();
}
/**
* Extension point to allow other MappingSqlQuery objects to be substituted in a subclass
*/
protected void initMappingSqlQueries() {
this.usersByUsernameMapping = new UsersByUsernameMapping(getDataSource());
this.authoritiesByUsernameMapping = new AuthoritiesByUsernameMapping(getDataSource());
}
public boolean isUsernameBasedPrimaryKey() {
return usernameBasedPrimaryKey;
}
//这里是取得数据库用户信息的具体过程
public UserDetails loadUserByUsername(String username)
throws UsernameNotFoundException, DataAccessException {
//根据用户名在用户表中得到用户信息，包括用户名，密码和用户是否有效的信息
List users = usersByUsernameMapping.execute(username);
if (users.size() == 0) {
throw new UsernameNotFoundException("User not found");
}
//取集合中的第一个作为有效的用户对象
UserDetails user = (UserDetails) users.get(0); // contains no GrantedAuthority[]
//这里在权限表中去取得用户的权限信息，同样的返回一个权限集合对应于这个用户
List dbAuths = authoritiesByUsernameMapping.execute(user.getUsername());
addCustomAuthorities(user.getUsername(), dbAuths);
if (dbAuths.size() == 0) {
throw new UsernameNotFoundException("User has no GrantedAuthority");
}
//这里根据得到的权限集合来配置返回的User对象供以后使用
GrantedAuthority[] arrayAuths = (GrantedAuthority[]) dbAuths.toArray(new GrantedAuthority[dbAuths.size()]);
String returnUsername = user.getUsername();
if (!usernameBasedPrimaryKey) {
returnUsername = username;
}
return new User(returnUsername, user.getPassword(), user.isEnabled(), true, true, true, arrayAuths);
}
public void setAuthoritiesByUsernameQuery(String queryString) {
authoritiesByUsernameQuery = queryString;
}
public void setRolePrefix(String rolePrefix) {
this.rolePrefix = rolePrefix;
}
public void setUsernameBasedPrimaryKey(boolean usernameBasedPrimaryKey) {
this.usernameBasedPrimaryKey = usernameBasedPrimaryKey;
}
public void setUsersByUsernameQuery(String usersByUsernameQueryString) {
this.usersByUsernameQuery = usersByUsernameQueryString;
}
//~ Inner Classes ==================================================================================================
/**
* 这里是调用Spring JDBC的数据库操作，具体可以参考对JDBC的分析，这个类的作用是把数据库查询得到的记录集合转换为对象集合 - 一个http://jiwenke.javaeye.com 1.9 Spring源代码解析（九）：Spring Acegi框架鉴权的实现
第 83 / 90 页
*/
protected class AuthoritiesByUsernameMapping extends MappingSqlQuery {
protected AuthoritiesByUsernameMapping(DataSource ds) {
super(ds, authoritiesByUsernameQuery);
declareParameter(new SqlParameter(Types.VARCHAR));
compile();
}
protected Object mapRow(ResultSet rs, int rownum)
throws SQLException {
String roleName = rolePrefix + rs.getString(2);
GrantedAuthorityImpl authority = new GrantedAuthorityImpl(roleName);
return authority;
}
}
/**
* Query object to look up a user.
*/
protected class UsersByUsernameMapping extends MappingSqlQuery {
protected UsersByUsernameMapping(DataSource ds) {
super(ds, usersByUsernameQuery);
declareParameter(new SqlParameter(Types.VARCHAR));
compile();
}
protected Object mapRow(ResultSet rs, int rownum)
throws SQLException {
String username = rs.getString(1);
String password = rs.getString(2);
boolean enabled = rs.getBoolean(3);
UserDetails user = new User(username, password, enabled, true, true, true,
new GrantedAuthority[] {new GrantedAuthorityImpl("HOLDER")});
return user;
}
}
}
从数据库中得到用户信息后，就是一个比对用户输入的信息和这个数据库用户信息的比对过程，这个比对过程在
DaoAuthenticationProvider:
//这个UserDetail是从数据库中查询到的，这个authentication是从用户输入中得到的
protected void additionalAuthenticationChecks(UserDetails userDetails,
UsernamePasswordAuthenticationToken authentication)
throws AuthenticationException {
Object salt = null;
if (this.saltSource != null) {
salt = this.saltSource.getSalt(userDetails);
}
//如果用户没有输入密码，直接抛出异常
if (authentication.getCredentials() == null) {
throw new BadCredentialsException(messages.getMessage(
"AbstractUserDetailsAuthenticationProvider.badCredentials", "Bad credentials"),
includeDetailsObject ? userDetails : null);
}
//这里取得用户输入的密码
String presentedPassword = authentication.getCredentials() == null ? "" : authentication.getCredentials().toString();
//这里判断用户输入的密码是不是和数据库里的密码相同，这里可以使用passwordEncoder来对数据库里的密码加解密
// 如果不相同，抛出异常，如果相同则鉴权成功
if (!passwordEncoder.isPasswordValid(
userDetails.getPassword(), presentedPassword, salt)) {
throw new BadCredentialsException(messages.getMessage(
"AbstractUserDetailsAuthenticationProvider.badCredentials", "Bad credentials"),
includeDetailsObject ? userDetails : null);
}
}
上面分析了整个Acegi进行验证的过程，从AuthenticationProcessingFilter中拦截Http请求得到用户输入的用户名和密码，这些用户输入
的验证信息会被放到Authentication对象中持有并传递给AuthenticatioManager来对比在服务端的用户信息来完成整个鉴权。这个鉴权
完成以后会把有效的用户信息放在一个Authentication中供以后的授权模块使用。在具体的鉴权过程中，使用了我们配置好的各种
Provider以及对应的UserDetailService和Encoder类来完成相应的获取服务器端用户数据以及与用户输入的验证信息的比对工作。
第 85 / 90 页
1.10 Spring源代码解析（十）：Spring Acegi框架授权的实现
我们从FilterSecurityInterceptor我们从入手看看怎样进行授权的：
//这里是拦截器拦截HTTP请求的入口
public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)
throws IOException, ServletException {
FilterInvocation fi = new FilterInvocation(request, response, chain);
invoke(fi);
}
//这是具体的拦截调用
public void invoke(FilterInvocation fi) throws IOException, ServletException {
if ((fi.getRequest() != null) && (fi.getRequest().getAttribute(FILTER_APPLIED) != null)
&& observeOncePerRequest) {
//在第一次进行过安全检查之后就不会再做了
fi.getChain().doFilter(fi.getRequest(), fi.getResponse());
} else {
//这是第一次收到相应的请求，需要做安全检测，同时把标志为设置好 - FILTER_APPLIED，下次就再有请求就不会作相同的安全检查if (fi.getRequest() != null) {
fi.getRequest().setAttribute(FILTER_APPLIED, Boolean.TRUE);
}
//这里是做安全检查的地方
InterceptorStatusToken token = super.beforeInvocation(fi);
//接着向拦截器链执行
try {
fi.getChain().doFilter(fi.getRequest(), fi.getResponse());
} finally {
super.afterInvocation(token, null);
}
}
}
我们看看在AbstractSecurityInterceptor是怎样对HTTP请求作安全检测的：
protected InterceptorStatusToken beforeInvocation(Object object) {
Assert.notNull(object, "Object was null");
if (!getSecureObjectClass().isAssignableFrom(object.getClass())) {
throw new IllegalArgumentException("Security invocation attempted for object "
+ object.getClass().getName()
+ " but AbstractSecurityInterceptor only configured to support secure objects of type: "第 86 / 90 页
+ getSecureObjectClass());
}
//这里读取配置FilterSecurityInterceptor的ObjectDefinitionSource属性，这些属性配置了资源的安全设置
ConfigAttributeDefinition attr = this.obtainObjectDefinitionSource().getAttributes(object);
if (attr == null) {
if(rejectPublicInvocations) {
throw new IllegalArgumentException(
"No public invocations are allowed via this AbstractSecurityInterceptor. "
+ "This indicates a configuration error because the "
+ "AbstractSecurityInterceptor.rejectPublicInvocations property is set to 'true'");
}
if (logger.isDebugEnabled()) {
logger.debug("Public object - authentication not attempted");
}
publishEvent(new PublicInvocationEvent(object));
return null; // no further work post-invocation
}
if (logger.isDebugEnabled()) {
logger.debug("Secure object: " + object.toString() + "; ConfigAttributes: " + attr.toString());
}
//这里从SecurityContextHolder中去取Authentication对象，一般在登录时会放到SecurityContextHolder中去
if (SecurityContextHolder.getContext().getAuthentication() == null) {
credentialsNotFound(messages.getMessage("AbstractSecurityInterceptor.authenticationNotFound",
"An Authentication object was not found in the SecurityContext"), object, attr);
}
// 如果前面没有处理鉴权，这里需要对鉴权进行处理
Authentication authenticated;
if (!SecurityContextHolder.getContext().getAuthentication().isAuthenticated() || alwaysReauthenticate) {
try {//调用配置好的AuthenticationManager处理鉴权，如果鉴权不成功，抛出异常结束处理
authenticated = this.authenticationManager.authenticate(SecurityContextHolder.getContext()
.getAuthentication());
} catch (AuthenticationException authenticationException) {
throw authenticationException;
}
第 87 / 90 页
// We don't authenticated.setAuthentication(true), because each provider should do that
if (logger.isDebugEnabled()) {
logger.debug("Successfully Authenticated: " + authenticated.toString());
}
//这里把鉴权成功后得到的Authentication保存到SecurityContextHolder中供下次使用
SecurityContextHolder.getContext().setAuthentication(authenticated);
} else {//这里处理前面已经通过鉴权的请求，先从SecurityContextHolder中去取得Authentication
authenticated = SecurityContextHolder.getContext().getAuthentication();
if (logger.isDebugEnabled()) {
logger.debug("Previously Authenticated: " + authenticated.toString());
}
}
// 这是处理授权的过程
try {
//调用配置好的AccessDecisionManager来进行授权
this.accessDecisionManager.decide(authenticated, object, attr);
} catch (AccessDeniedException accessDeniedException) {
//授权不成功向外发布事件
AuthorizationFailureEvent event = new AuthorizationFailureEvent(object, attr, authenticated,
accessDeniedException);
publishEvent(event);
throw accessDeniedException;
}
if (logger.isDebugEnabled()) {
logger.debug("Authorization successful");
}
AuthorizedEvent event = new AuthorizedEvent(object, attr, authenticated);
publishEvent(event);
// 这里构建一个RunAsManager来替代当前的Authentication对象，默认情况下使用的是NullRunAsManager会把SecurityContextHolder中的Authentication runAs = this.runAsManager.buildRunAs(authenticated, object, attr);
if (runAs == null) {
if (logger.isDebugEnabled()) {
logger.debug("RunAsManager did not change Authentication object");
}
第 88 / 90 页
// no further work post-invocation
return new InterceptorStatusToken(authenticated, false, attr, object);
} else {
if (logger.isDebugEnabled()) {
logger.debug("Switching to RunAs Authentication: " + runAs.toString());
}
SecurityContextHolder.getContext().setAuthentication(runAs);
// revert to token.Authenticated post-invocation
return new InterceptorStatusToken(authenticated, true, attr, object);
}
}
到这里我们假设配置AffirmativeBased作为AccessDecisionManager：
//这里定义了决策机制，需要全票才能通过
public void decide(Authentication authentication, Object object, ConfigAttributeDefinition config)
throws AccessDeniedException {
//这里取得配置好的迭代器集合
Iterator iter = this.getDecisionVoters().iterator();
int deny = 0;
//依次使用各个投票器进行投票，并对投票结果进行计票
while (iter.hasNext()) {
AccessDecisionVoter voter = (AccessDecisionVoter) iter.next();
int result = voter.vote(authentication, object, config);
//这是对投票结果进行处理，如果遇到其中一票通过，那就授权通过，如果是弃权或者反对，那就继续投票
switch (result) {
case AccessDecisionVoter.ACCESS_GRANTED:
return;
case AccessDecisionVoter.ACCESS_DENIED:
//这里对反对票进行计数
deny++;
break;
default:
break;
}
}
第 89 / 90 页
//如果有反对票，抛出异常，整个授权不通过
if (deny > 0) {
throw new AccessDeniedException(messages.getMessage("AbstractAccessDecisionManager.accessDenied",
"Access is denied"));
}
// 这里对弃权票进行处理，看看是全是弃权票的决定情况，默认是不通过，由allowIfAllAbstainDecisions变量控制
checkAllowIfAllAbstainDecisions();
}
具体的投票由投票器进行，我们这里配置了RoleVoter来进行投票：
public int vote(Authentication authentication, Object object, ConfigAttributeDefinition config) {
int result = ACCESS_ABSTAIN;
//这里取得资源的安全配置
Iterator iter = config.getConfigAttributes();
while (iter.hasNext()) {
ConfigAttribute attribute = (ConfigAttribute) iter.next();
if (this.supports(attribute)) {
result = ACCESS_DENIED;
// 这里对资源配置的安全授权级别进行判断，也就是匹配ROLE为前缀的角色配置
// 遍历每个配置属性，如果其中一个匹配该主体持有的GrantedAuthority,则访问被允许。
for (int i = 0; i < authentication.getAuthorities().length; i++) {
if (attribute.getAttribute().equals(authentication.getAuthorities()[i].getAuthority())) {
return ACCESS_GRANTED;
}
}
}
}
return result;
}
上面就是对整个授权过程的一个分析，从FilterSecurityInterceptor拦截Http请求入手，然后读取对资源的安全配置以后，把这些信息交
由AccessDecisionManager来进行决策，Spring为我们提供了若干决策器来使用，在决策器中我们可以配置投票器来完成投票，我们在
上面具体分析了角色投票器的使用过程。
 Copyright ©2011 lyt. All Rights Reserved.
 
 
 
java核心技术学习
spring开发指南

Spring 初探
开始Spring研究之前，先让我们来看一个1 分钟上手教程。
Quick Start!
准备工作
下载SpringFramework的最新版本，并解压缩到指定目录。
在IDE中新建一个项目，并将Spring.jar将其相关类库加入项目。
笔者所用IDE为Eclipse，类库配置如下：
Spring采用Apache common_logging，并结合Apache log4j作为日志输出组件。为了在
调试过程中能观察到Spring的日志输出，在CLASSPATH中新建log4j.properties配置文件，
内容如下：

log4j.rootLogger=DEBUG, stdout
log4j.appender.stdout=org.apache.log4j.ConsoleAppender
log4j.appender.stdout.layout=org.apache.log4j.PatternLayout
log4j.appender.stdout.layout.ConversionPattern=%c{1} - %m%n
配置完成后，项目结构如下图所示：
构建 Spring 基础代码
示例基础代码包括：
1． Action接口:
Action 接口定义了一个execute 方法，在我们示例中，不同的Action 实现提供了各自的
execute方法，以完成目标逻辑。
public interface Action {
public String execute(String str);
}
2． Action接口的两个实现UpperAction、LowerAction
public class UpperAction implements Action {
private String message;
public String getMessage() {
return message;
}
public void setMessage(String string) {
message = string;
}
public String execute(String str) {
return (getMessage() + str).toUpperCase();
}
}
UpperAction将其message属性与输入字符串相连接，并返回其大写形式。
public class LowerAction implements Action {
private String message;
public String getMessage() {
return message;
}
public void setMessage(String string) {
message = string;
}
public String execute(String str) {
return (getMessage()+str).toLowerCase();
}
}
LowerAction将其message属性与输入字符串相连接，并返回其小写形式。
3． Spring配置文件（bean.xml）
<beans>
<description>Spring Quick Start</description>
<bean id="TheAction"
class="net.xiaxin.spring.qs.UpperAction">
<property name="message">
<value>HeLLo</value>
</property>
</bean>
</beans>
（请确保配置bean.xml位于工作路径之下，注意工作路径并不等同于CLASSPATH ，eclipse
的默认工作路径为项目根路径，也就是.project文件所在的目录，而默认输出目录/bin是项目
CLASSPATH的一部分，并非工作路径。）
4． 测试代码
public void testQuickStart() {
ApplicationContext ctx=new
FileSystemXmlApplicationContext("bean.xml");
Action action = (Action) ctx.getBean("TheAction");
System.out.println(action.execute("Rod Johnson"));
}
可以看到，上面的测试代码中，我们根据"bean.xml"创建了一个ApplicationContext实
例，并从此实例中获取我们所需的Action实现。
运行测试代码，我们看到控制台输出：
……
HELLO ROD JOHNSON
我们将bean.xml中的配置稍加修改：
<bean id="TheAction"
class="net.xiaxin.spring.qs.LowerAction"/>
再次运行测试代码，看到：
……
hello rod johnson
示例完成！
很简单的示例，的确很简单，甚至简单到了不够真实。
不过，不知大家从这个最简单的例子中看出了什么？
真的只是打印输出了两行不痛不痒的问候语？
仔细观察一下上面的代码，可以看到：
1． 我们的所有程序代码中（除测试代码之外），并没有出现Spring中的任何组件。
2． UpperAction和LowerAction的Message属性均由Spring通过读取配置文件（bean.xml）动
态设置。
3． 客户代码（这里就是我们的测试代码）仅仅面向接口编程，而无需知道实现类的具体名称。同时，
我们可以很简单的通过修改配置文件来切换具体的底层实现类。
上面所说的这些，对于我们的实际开发有何帮助？
首先，我们的组件并不需要实现框架指定的接口，因此可以轻松的将组件从Spring中脱离，甚
至不需要任何修改（这在基于EJB框架实现的应用中是难以想象的）。
其次，组件间的依赖关系减少，极大改善了代码的可重用性。
Spring的依赖注入机制，可以在运行期为组件配置所需资源，而无需在编写组件代码时就加以
指定，从而在相当程度上降低了组件之间的耦合。
上面的例子中，我们通过Spring，在运行期动态将字符串“HeLLo” 注入到Action实现类的
Message属性中。
现在假设我们回到传统的实现模式，应该如何处理？
一般的处理办法也就是编写一个Helper类（辅助类），完成配置文件读写功能，然后在各个
Action的构造函数中，调用这个Helper类设置message属性值。
此时，我们的组件就与这个Helper类库建立了依赖关系，之后我们需要在其他系统中重用这个
组件的话，也必须连同这个Helper类库一并移植。实际开发中，依赖关系往往并非如此简单，
组件与项目基层代码之间复杂的关联，使得组件重用性大大下降。
Spring通过依赖注入模式，将依赖关系从编码中脱离出来，从而大大降低了组件之间的耦合，
实现了组件真正意义上的即插即用。这也是Spring最具价值的特性之一。
面向接口编程。
诚然，即使没有Spring，实现面向接口的设计也不困难。Spring对于面向接口设计的意义，在
于它为面向接口编程提供了一个更加自然的平台。基于Spring开发，程序员会自然而然倾向于
使用接口来定义不同层次之间的关联关系，这种自发的倾向性，来自于Spring所提供的简单舒
适的依赖注入实现。Spring使得接口的定义和使用不再像传统编码过程中那么繁琐（传统编码
过程中，引入一个接口，往往也意味着同时要引入___________一个Factory类，也许还有一个额外的配置文
件及其读写代码）。
既然Spring给我们带来了如此这般的好处，那么，反过来，让我们试想一下，如果不使用Spring框
架，回到我们传统的编码模式（也许正是目前的编码模式），情况会是怎样？
对于上例而言，我们需要怎样才能实现相同的功能？
上面的Action接口及其两个实现类UpperAction和LowerAction都与Spring无关，可以保留。而调
用Action的测试代码，如果要实现同样的功能，应该如何编写？
首先，我们必须编写一个配置文件读取类，以实现Message属性的可配置化。
其次，得有一个Factory模式的实现，并结合配置文件的读写完成Action的动态加载。
于是，我们实现了一个ActionFactory来实现这个功能：
public class ActionFactory{
public static Action getAction(String actionName){
Properties pro = new Properties();
try {
pro.load(new FileInputStream("config.properties"));
String actionImplName =
(String)pro.get(actionName);
String actionMessage =
(String)pro.get(actionName+"_msg");
Object obj =
Class.forName(actionImplName).newInstance();
//BeanUtils是Apache Commons BeanUtils提供的辅助类
BeanUtils.setProperty(obj,"message",actionMessage);
return (Action)obj;
} catch (FileNotFoundException e) {
e.printStackTrace();
} catch (IOException e) {
e.printStackTrace();
} catch (ClassNotFoundException e) {
e.printStackTrace();
} catch (InstantiationException e) {
e.printStackTrace();
} catch (IllegalAccessException e) {
e.printStackTrace();
} catch (InvocationTargetException e) {
e.printStackTrace();
}
return null;
}
}
配置文件则采用最简单的properties文件形式：
TheAction=net.xiaxin.spring.qs.UpperAction
TheAction_msg=HeLLo
测试代码对应更改为：
public void testFactory(){
Action action = ActionFactory.getAction("TheAction");
System.out.println(action.execute("Rod Johnson"));
}
且不论实现质量的好坏，总之通过上面新增的20来行代码，我们实现了类似的功能（如果不引入
BeanUtils，而采用手工编写Reflection代码完成属性设置的话，显然代码将远远不止20行）。
好吧，现在有个新需求，这个ActionFactory每次都新建一个类的实例，这对系统性能不利，考虑
到我们的两个Action都是线程安全的，修改一下ActionFactory，保持系统中只有一个Action实例供其
他线程调用。
另外Action对象创建后，需要做一些初始化工作。修改一下ActionFactory，使其在创建Action实
例之后，随即就调用Action.init方法执行初始化。
嗯，好像每次创建Action对象的时就做初始化工作消耗了很多无谓资源，来个Lazy Loading吧，
只有Action实例被实际调用的时候再做初始化。
差不多了，Action的处理就这样吧。下面我们来看看另外一个Factory。
……
往往这些系统开发中最常见的需求，会导致我们的代码迅速膨胀。纵使苦心经营，往往也未必能得
全功。
而Spring的出现，则大大缓解了这样的窘境。通过对编码中常见问题的分解和抽象，Spring提供了
一套成熟而全面的基础框架。随着本篇的进展，大家可以看到，上面这些开发中常见的问题在Spring框
架中都提供了统一、妥善的处理机制，这为烦杂的应用开发提供了相当有力的支持。
这里暂且抛开Spring Framework在设计上相当出彩的表现不谈。站在应用开发的实际角度来说，
其最大的优势在于：Spring是一个从实际项目开发经验中抽取的，可高度重用的应用框架。认识到这
一点非常重要。
Spring Framework中目前最引人注目的，也就是名为控制反转（IOC ＝Inverse Of Control）
或者依赖注入（DI ＝Dependence Injection）的设计思想，这的确是相当优秀的设计理念，但是，
光一个单纯的设计模式并不能使得Spring如此成功，而Spring最成功的地方也并不仅仅在于采用了
IOC/DI的设计。我们前面示例中的ActionFactory，勉强也可算做是一个IOC/DI设计的实现，但又如
何？
可能相关技术媒体和不明就里的技术追随者对于DI/IOC容器的过分炒作，在某种程度上误导了初学
者的视线。“控制反转”，这显然不是一个能望文知意的好名称；“依赖注入”，也好不到哪里去，也正因
为这样，不少初学者都将Spring和生涩的所谓“控制反转”和“依赖注入”看作一个懵懂的高级概念而
供上了神龛。
而实际上，Spring是笔者所见过的，最具实际意义的Java开发框架。它绝非一个高级概念玩具，而
是一个切实的，能实实在在帮助我们改善系统设计的好帮手。
首先，Spring涵盖了应用系统开发所涉及的大多数技术范畴，包括MVC、ORM以及Remote
Interface等，这些技术往往贯穿了大多数应用系统的开发过程。Spring从开发者的角度对这些技术内
容进行了进一步的封装和抽象，使得应用开发更为简便。在笔者的开发工作中，借助Spring提供的丰富
类库，相对传统开发模式，大大节省了编码量（平均1/3强，对于ORM和Remote层也许更多）。
其次，Spring并非一个强制性框架，它提供了很多独立的组件可供选择。如笔者在一些项目中，就
仅引用了Spring的ORM模板机制对数据存取层进行处理，并取得了相当理想的效果。
评定一个框架是否优良的条件固然有很多种，但是笔者始终认为，对于应用系统开发而言，我们面
临着来自诸多方面的压力，此时，最能提高生产力的技术，也就是最有价值的技术。很高兴，Spring让
笔者找到了这样的感觉。
笔者对Rod Johnson最为钦佩的，并不是他用了IOC或者DI，而是他对J2EE应用开发的透彻的理
解。
他真的明白开发人员需要什么。
Spring 基础语义
Dependency Injection
何谓控制反转（IoC = Inversion of Control），何谓依赖注入（DI = Dependency Injection）？
对于初次接触这些概念的初学者，不免会一头雾水。正如笔者第一次看到这些名词一样，一阵窘迫……
IT界不亏是哄抢眼球的行业，每个新出现的语汇都如此迷离。好在我们也同时拥有Internet这个最
广博的信息来源。
IoC，用白话来讲，就是由容器控制程序之间的关系，而非传统实现中，由程序代码直接操控。这也
就是所谓“控制反转”的概念所在：控制权由应用代码中转到了外部容器，控制权的转移，是所谓反转。
正在业界为IoC争吵不休时，大师级人物Martin Fowler也站出来发话，以一篇经典文章《Inversion
of Control Containers and the Dependency Injection pattern》为IoC正名，至此，IoC又获得了
一个新的名字：“依赖注入（Dependency Injection）”。
相对IoC 而言，“依赖注入”的确更加准确的描述了这种古老而又时兴的设计理念。从名字上理解，
所谓依赖注入，即组件之间的__________依赖关系由容器在运行期决定，形象的来说，即由容器动态的将某种依赖关
系注入到组件之中。
为什么称之为“古老而又时兴”的设计理念？至于“时兴”自然不必多费唇舌，看看国内外大小论坛
上当红的讨论主题便知。至于“古老”……，相信大家对下面图片中的设备不会陌生：
这就是笔者的主要工作装备，IBM T40笔记本电脑一台、USB硬盘和U盘各一只。想必大家在日常
工作中也有类似的一套行头。
这与依赖注入有什么关系？
图中三个设备都有一个共同点，都支持USB 接口。当我们需要将数据复制到外围存储设备时，可以
根据情况，选择是保存在U盘还是USB硬盘，下面的操作大家也都轻车熟路，无非接通USB接口，然后
在资源浏览器中将选定的文件拖放到指定的盘符。
这样的操作在过去几年中每天都在我们身边发生，而这也正是所谓依赖注入的一个典型案例，上面称
之为“古老”想必也不为过分。
再看上例中，笔记本电脑与外围存储设备通过预先指定的一个接口（USB）相连，对于笔记本而言，
只是将用户指定的数据发送到USB接口，而这些数据何去何从，则由当前接入的USB设备决定。在USB
设备加载之前，笔记本不可能预料用户将在USB接口上接入何种设备，只有USB设备接入之后，这种设
备之间的依赖关系才开始形成。
对应上面关于依赖注入机制的描述，在运行时（系统开机，USB 设备加载）由容器（运行在笔记本
中的Windows操作系统）将依赖关系（笔记本依赖USB设备进行数据存取）注入到组件中（Windows
文件访问组件）。
这就是依赖注入模式在现实世界中的一个版本。
很多初学者常常陷入“依赖注入，何用之有？”的疑惑。想来这___________个例子可以帮助大家简单的理解其中
的含义。依赖注入的目标并非为软件系统带来更多的功能，而是为了提升组件重用的概率，并为系统搭建
一个灵活、可扩展的平台。将USB接口和之前的串/并、PS2接口对比，想必大家就能明白其中的意味。
回顾Quick Start中的示例，UpperAction/LowerAction在运行前，其Message节点为空。运行
后由容器将字符串“HeLLo”注入。此时UpperAction/LowerAction即与内存中的“HeLLo”字符串对
象建立了依赖关系。也许区区一个字符串我们无法感受出依赖关系的存在。如果把这里的Message 属性
换成一个数据源（DataSource），可能更有感觉：
<beans>
<bean id="dataSource"
class="org.springframework.jndi.JndiObjectFactoryBean">
<property name="jndiName">
<value>java:comp/env/jdbc/sample</value>
</property>
</bean>
<bean id="SampleDAO" class="net.xiaxin.spring.dao.SampleDAO">
<property name="dataSource">
<ref local="dataSource"/>
</property>
</bean>
</beans>
其中SampleDAO中的dataSource将由容器在运行期动态注入，而DataSource的具体配置和初始化工作
也将由容器在运行期完成。
对比传统的实现方式（如通过编码初始化DataSource实例），我们可以看到，基于依赖注入的系统实现相
当灵活简洁。
通过依赖注入机制，我们只需要通过简单的配置，而无需任何代码就可指定SampleDAO中所需的
DataSource实例。SampleDAO只需利用容器注入的DataSource实例，完成自身的业务逻辑，而不用
关心具体的资源来自何处、由谁实现。
上面的实例中，我们假设SampleDAO是一个运行在J2EE容器中的组件（如Weblogic）。在运行期，通
过JNDI从容器中获取DataSource实例。
现在假设我们的部署环境发生了变化，系统需要脱离应用服务器独立运行，这样，由于失去了容器的支持，
原本通过JNDI获取DataSource的方式不再有效。我们需要如何修改以适应新的系统环境？很简单，我们
只需要修改dataSource的配置：
<beans>
<bean id="dataSource"
class="org.apache.commons.dbcp.BasicDataSource"
destroy-method="close">
<property name="driverClassName">
<value>org.gjt.mm.mysql.Driver</value>
</property>
<property name="url">
<value>jdbc:mysql://localhost/sample</value></property>
<property name="username">
<value>user</value>
</property>
<property name="password">
<value>mypass</value>
</property>
</bean>
<bean id="SampleDAO" class="net.xiaxin.spring.dao.SampleDAO">
<property name="dataSource">
<ref local="dataSource"/>
</property>
</bean>
</beans>
这里我们的DataSource改为由Apache DBCP组件提供。没有编写任何代码我们即实现了DataSource的
切换。回想传统编码模式中，如果要进行同样的修改，我们需要付出多大的努力。
依赖注入机制减轻了组件之间的依赖关系，同时也大大提高了组件的可移植性，这意味着，组件得到重用
的机会将会更多。
依赖注入的几种实现类型
Type1 接口注入
我们常常借助接口来将调用者与实现者分离。如:
public class ClassA {
private InterfaceB clzB;
public init() {
Ojbect obj =
Class.forName(Config.BImplementation).newInstance();
clzB = (InterfaceB)obj;
}
……
}
上面的代码中，ClassA依赖于InterfaceB的实现，如何获得InterfaceB实现类的实例？传统的方法是在
代码中创建InterfaceB实现类的实例，并将起赋予clzB。
而这样一来，ClassA在编译期即依赖于InterfaceB的实现。为了将调用者与实现者在编译期分离，于是有
了上面的代码，我们根据预先在配置文件中设定的实现类的类名，动态加载实现类，并通过InterfaceB强
制转型后为ClassA所用。
这就是接口注入的一个最原始的雏形。
而对于一个Type1型IOC容器而言，加载接口实现并创建其实例的工作由容器完成，如J2EE开发中常用的
Context.lookup（ServletContext.getXXX），都是Type1型IOC的表现形式。
Apache Avalon是一个典型的Type1型IOC容器。
Type2 构造子注入
构造子注入，即通过构造函数完成依赖关系的设定，如：
public class DIByConstructor {
private final DataSource dataSource;
private final String message;
public DIByConstructor(DataSource ds, String msg) {
this.dataSource = ds;
this.message = msg;
}
……
}
可以看到，在Type2类型的依赖注入机制中，依赖关系是通过类构造函数建立，容器通过调用类的构
造方法，将其所需的依赖关系注入其中。
PicoContainer（另一种实现了依赖注入模式的轻量级容器）首先实现了Type2类型的依赖注入模式。
Type3 设值注入
在各种类型的依赖注入模式中，设值注入模式在实际开发中得到了最广泛的应用（其中很大一部分得
力于Spring框架的影响）。
在笔者看来，基于设置模式的依赖注入机制更加直观、也更加自然。Quick Start中的示例，就是典型的设置注入，即通过类的setter方法完成依赖关系的设置。
几种依赖注入模式的对比总结
接口注入模式因为具备侵入性，它要求组件必须与特定的接口相关联，因此并不被看好，实际使用有
限。
Type2和Type3的依赖注入实现模式均具备无侵入性的特点。在笔者看来，这两种实现方式各有特点，
也各具优势（一句经典废话）。
Type2 构造子注入的优势：
1． “在构造期即创建一个完整、合法的对象”，对于这条Java设计原则，Type2无疑是最好的
响应者。
2． 避免了繁琐的setter方法的编写，所有依赖关系均在构造函数中设定，依赖关系集中呈现，
更加易读。
3． 由于没有setter方法，依赖关系在构造时由容器一次性设定，因此组件在被创建之后即处于
相对“不变”的稳定状态，无需担心上层代码在调用过程中执行setter方法对组件依赖关系
产生破坏，特别是对于Singleton模式的组件而言，这可能对整个系统产生重大的影响。
4． 同样，由于关联关系仅在构造函数中表达，只有组件创建者需要关心组件内部的依赖关系。
对调用者而言，组件中的依赖关系处于黑盒之中。对上层屏蔽不必要的信息，也为系统的
层次清晰性提供了保证。
5． 通过构造子注入，意味着我们可以在构造函数中决定依赖关系的注入顺序，对于一个大量
依赖外部服务的组件而言，依赖关系的获得顺序可能非常重要，比如某个依赖关系注入的
先决条件是组件的DataSource及相关资源已经被设定。
Type3 设值注入的优势
1． 对于习惯了传统JavaBean开发的程序员而言，通过setter方法设定依赖关系显得更加直
观，更加自然。
2． 如果依赖关系（或继承关系）较为复杂，那么Type2模式的构造函数也会相当庞大（我们需
要在构造函数中设定所有依赖关系），此时Type3模式往往更___________为简洁。
3． 对于某些第三方类库而言，可能要求我们的组件必须提供一个默认的构造函数（如Struts
中的Action），此时Type2类型的依赖注入机制就体现出其局限性，难以完成我们期望的功
能。
可见，Type2和Type3模式各有千秋，而Spring、PicoContainer都对Type2和Type3类型的依赖注
入机制提供了良好支持。这也就为我们提供了更多的选择余地。理论上，以Type2类型为主，辅之以Type3
类型机制作为补充，可以达到最好的依赖注入效果，不过对于基于Spring Framework开发的应用而言，
Type3使用更加广泛。
Spring Bean 封装机制
Spring 从核心而言，是一个DI 容器，其设计哲学是提供一种无侵入式的高扩展性框架。即无需代
码中涉及Spring专有类，即可将其纳入Spring容器进行管理。
作为对比，EJB则是一种高度侵入性的框架规范，它制定了众多的接口和编码规范，要求实现者必须
遵从。侵入性的后果就是，一旦系统基于侵入性框架设计开发，那么之后任何脱离这个框架的企图都将付
出极大的代价。
为了避免这种情况，实现无侵入性的目标。Spring 大量引入了Java 的Reflection机制，通过动态
调用的方式避免硬编码方式的约束，并在此基础上建立了其核心组件BeanFactory，以此作为其依赖注入
机制的实现基础。
org.springframework.beans包中包括了这些核心组件的实现类，核心中的核心为BeanWrapper
和BeanFactory类。这两个类从技术角度而言并不复杂，但对于Spring 框架而言，却是关键所在，如果
有时间，建议对其源码进行研读，必有所获。
Bean Wrapper
从Quick Start的例子中可以看到，所谓依赖注入，即在运行期由容器将依赖关系注入到组件之中。
讲的通俗点，就是在运行期，由Spring根据配置文件，将其他对象的引用通过组件的提供的setter方法进
行设定。
我们知道，如果动态设置一个对象属性，可以借助Java的Reflection机制完成：
Class cls = Class.forName("net.xiaxin.beans.User");
Method mtd = cls.getMethod("setName",new Class[]{String.class});
Object obj = (Object)cls.newInstance();
mtd.invoke(obj,new Object[]{"Erica"});
return obj;
上面我们通过动态加载了User类，并通过Reflection调用了User.setName方法设置其name属性。
对于这里的例子而言，出于简洁，我们将类名和方法名都以常量的方式硬编码。假设这些常量都是通过配
置文件读入，那我们就实现了一个最简单的BeanWrapper。这个BeanWrapper的功能很简单，提供一个
设置JavaBean属性的通用方法（Apache BeanUtils 类库中提供了大量针对Bean的辅助工具，如果有兴
趣可以下载一份源码加以研读）。
Spring BeanWrapper基于同样的原理，提供了一个更加完善的实现。
看看如何通过Spring BeanWrapper操作一个JavaBean：
Object obj = Class.forName("net.xiaxin.beans.User").newInstance();
BeanWrapper bw = new BeanWrapperImpl(obj);
bw.setPropertyValue("name", "Erica");
System.out.println("User name=>"+bw.getPropertyValue("name"));
对比之前的代码，相信大家已经知道BeanWrapper的实现原理。
诚然，通过这样的方式设定Java Bean属性实在繁琐，但它却提供了一个通用的属性设定机制，而这
样的机制，也正是Spring依赖注入机制所依赖的基础。
通过BeanWrapper，我们可以无需在编码时就指定JavaBean的实现类和属性值，通过在配置文件
加以设定，就可以在运行期动态创建对象并设定其属性（依赖关系）。
上面的代码中，我们仅仅指定了需要设置的属性名“name”，运行期，BeanWrapper将根据Java
Bean规范，动态调用对象的“setName”方法进行属性设定。属性名可包含层次，如对于属性名
“address.zipcode”，BeanWrapper会调用“getAddress().setZipcode”方法。
Bean Factory
Bean Factory，顾名思义，负责创建并维护Bean实例。
Bean Factory负责根据配置文件创建Bean实例，可以配置的项目有：
1． Bean属性值及依赖关系（对其他Bean的引用）
2． Bean创建模式（是否Singleton模式，即是否只针对指定类维持全局唯一的实例）
3． Bean初始化和销毁方法
4． Bean的依赖关系
下面是一个较为完整的Bean配置示例：
<beans>
<description>Spring Bean Configuration Sample</description>
<bean
id="TheAction" ⑴
class="net.xiaxin.spring.qs.UpperAction" ⑵
singleton="true" ⑶
init-method="init" ⑷
destroy-method="cleanup" ⑸
depends-on="ActionManager" ⑹
> 
<property name="message">
<value>HeLLo</value> ⑺
</property>
<property name="desc">
<null/>
</property>
<property name="dataSource">
<ref local="dataSource"/> ⑻
</property>
</bean>
<bean id="dataSource"
class="org.springframework.jndi.JndiObjectFactoryBean">
<property name="jndiName">
<value>java:comp/env/jdbc/sample</value>
</property>
</bean>
</beans>
⑴ id
Java Bean在BeanFactory中的唯一标识，代码中通过BeanFactory获取
JavaBean实例时需以此作为索引名称。
⑵ class
Java Bean 类名
⑶ singleton
指定此Java Bean是否采用单例（Singleton）模式，如果设为“true”，则在
BeanFactory作用范围内，只维护此Java Bean的一个实例，代码通过BeanFactory
获得此Java Bean实例的引用。反之，如果设为“false”，则通过BeanFactory获取
此Java Bean实例时，BeanFactory每次都将创建一个新的实例返回。
⑷ init-method
初始化方法，此方法将在BeanFactory创建JavaBean实例之后，在向应用层返回引
用之前执行。一般用于一些资源的初始化工作。
⑸ destroy-method
销毁方法。此方法将在BeanFactory销毁的时候执行，一般用于资源释放。
⑹ depends-on
Bean依赖关系。一般情况下无需设定。Spring会根据情况组织各个依赖关系的构建工作（这里
示例中的depends-on属性非必须）。
只有某些特殊情况下，如JavaBean中的某些静态变量需要进行初始化（这是一种Bad
Smell，应该在设计上应该避免）。通过depends-on指定其依赖关系可保证在此Bean加
载之前，首先对depends-on所指定的资源进行加载。
⑺ <value>
通过<value/>节点可指定属性值。BeanFactory将自动根据Java Bean对应的属性
类型加以匹配。
下面的”desc”属性提供了一个null值的设定示例。注意<value></value>代表一
个空字符串，如果需要将属性值设定为null，必须使用<null/>节点。
⑻ <ref>
指定了属性对BeanFactory中其他Bean的引用关系。示例中，TheAction的dataSource属
性引用了id为dataSource的Bean。BeanFactory将在运行期创建dataSource bean实例，并将其
引用传入TheAction Bean的dataSource属性。
下面的代码演示了如何通过BeanFactory获取Bean实例：
InputStream is = new FileInputStream("bean.xml");
XmlBeanFactory factory = new XmlBeanFactory(is);
Action action = (Action) factory.getBean("TheAction");
此时我们获得的Action实例，由BeanFactory进行加载，并根据配置文件进行了初始化和属性设定。
联合上面关于BeanWrapper的内容，我们可以看到，BeanWrapper实现了针对单个Bean的属性设
定操作。而BeanFactory则是针对多个Bean的管理容器，根据给定的配置文件，BeanFactory从中读取
类名、属性名/值，然后通过Reflection机制进行Bean加载和属性设定。
 
 
ApplicationContext
BeanFactory提供了针对Java Bean的管理功能，而ApplicationContext提供了一__________个更为框架化的
实现（从上面的示例中可以看出，BeanFactory的使用方式更加类似一个API，而非Framework style）。
ApplicationContext覆盖了BeanFactory的所有功能，并提供了更多的特性。此外，
ApplicationContext为与现有应用框架相整合，提供了更为开放式的实现（如对于Web应用，我们可以在
web.xml中对ApplicationContext进行配置）。
相对BeanFactory而言，ApplicationContext提供了以下扩展功能：
1． 国际化支持
我们可以在Beans.xml文件中，对程序中的语言信息（如提示信息）进行定义，将程序中的提示
信息抽取到配置文件中加以定义，为我们进行应用的各语言版本转换提供了极大的灵活性。
2． 资源访问
支持对文件和URL的访问。
3． 事件传播
事件传播特性为系统中状态改变时的检测提供了良好支持。
4． 多实例加载
可以在同一个应用中加载多个Context实例。
下面我们就这些特性逐一进行介绍。
1) 国际化支持
国际化支持在实际开发中可能是最常用的特性。对于一个需要支持不同语言环境的应用而言，
我们所采取的最常用的策略一般是通过一个独立的资源文件（如一个properties文件）完成所
有语言信息（如界面上的提示信息）的配置，Spring对这种传统的方式进行了封装，并提供了
更加强大的功能，如信息的自动装配以及热部署功能（配置文件修改后自动读取，而无需重新
启动应用程序），下面是一个典型的示例：
<beans>
<description>Spring Quick Start</description>
<bean id="messageSource"
class="org.springframework.context.support.ResourceB
undleMessageSource">
<property name="basenames">
<list>
<value>messages</value>
</list>
</property>
</bean>
</beans>
这里声明了一个名为messageSource的Bean（注意对于Message定义，Bean ID必须为
messageSource，这是目前Spring的编码规约），对应类为ResourceBundleMessageSource，
目前Spring中提供了两个MessageSource接口的实现，即
ResourceBundleMessageSource和ReloadableResourceBundleMessageSource，后
者提供了无需重启即可重新加载配置信息的特性。
在配置节点中，我们指定了一个配置名“messages”。Spring会自动在CLASSPATH根路
径中按照如下顺序搜寻配置文件并进行加载（以Locale为zh_CN为例）:
messages_zh_CN.properties
messages_zh.properties
messages.properties
messages_zh_CN.class
messages_zh.class
messages.class
（Spring实际上调用了JDK的ResourceBundle读取配置文件，相关内容请参见JDK文档）
示例中包含了两个配置文件，内容如下：
messages_zh_CN.properties：
userinfo=当前登录用户: [{0}] 登录时间:[{1}]
messages_en_US.properties：
userinfo=Current Login user: [{0}] Login time:[{1}]
我们可以通过下面的语句进行测试：
ApplicationContext ctx=new
FileSystemXmlApplicationContext("bean.xml");
Object[] arg = new Object[]{
"Erica",
Calendar.getInstance().getTime()
};
//以系统默认Locale加载信息(对于中文WinXP而言，默认为zh_CN)
String msg = ctx.getMessage("userinfo", arg);
System.out.println("Message is ===> "+msg);
代码中，我们将一个Object数组arg作为参数传递给ApplicationContext.getMessage方法，这个
参数中包含了出现在最终文字信息中的可变内容，ApplicationContext将根据参数中的Locale信息对其进
行处理（如针对不同Locale设定日期输出格式），并用其替换配置文件中的{n}标识（n代表参数数组中的
索引，从1开始）。
运行上面的代码，得到以下输出的内容：
Message is ===> |獭à?°|ì???¨®??〃¬: [Erica] |ì???¨o〃¤??:[04-7-17 上
午3:27]
乱码？回忆在传统方式下，针对ResourceBundle的编码过程中发生的问题。这是由于转码过程中产
生的编码问题引发的。比较简单的解决办法是通过JDK提供的转码工具native2ascii.exe进行转换。
执行：
native2ascii messages_zh_CN.properties msg.txt
再用msg.txt文件替换Messages_zh_CN.properties文件。我们可以看到现在的
Messages_zh_CN.properties变成了如下形式：
userinfo=\u5f53\u524d\u767b\u5f55\u7528\u6237: [{0}]
\u767b\u5f55\u65f6\u95f4:[{1}]
（通过在native2ascii命令后追加-reverse参数，可以将文件转回本地格式）
再次运行示例代码，得到正确输出：
Message is ===> 当前登录用户: [Erica] 登录时间:[04-7-17 上午3:34]
可见，根据当前默认Locale“zh_CN”，getMessage方法自动加载了messages_zh_CN.properties
文件。
每次必须运行native2ascii方法比较繁琐，实际开发中，我们可以通过Apache Ant的Native2Ascii
任务进行批量转码。如：
<native2ascii encoding="GBK" src="${src}" dest="${build}"/>
尝试在代码中指定不同的Locale参数：
String msg = ctx.getMessage("userinfo", arg, Locale.US);
再次运行，可以看到：
Message is ===> Current Login user: [Erica] Login time::[7/17/04 3:35
AM]
这里，getMessage方法根据指定编码“en_US”加载了messages_en_US.properties文件。同
时请注意登录时间部分的变化（Locale不同，时间的输出格式也随之改变）。
getMessage方法还有一个无需Locale参数的版本，JVM会根据当前系统的Locale设定进行相应处
理。可以通过在JVM启动参数中追加“-Duser.language=en”来设定当前JVM语_________7{言类型，通过JVM级的
设定，结合国际化支持功能，我们可以较为简单的实现多国语言系统的自动部署切换。
2) 资源访问
ApplicationContext.getResource方法提供了对资源文件访问支持，如：
Resource rs = ctx.getResource("classpath:config.properties");
File file = rs.getFile();
上例从CLASSPATH根路径中查找config.properties文件并获取其文件句柄。
getResource方法的参数为一个资源访问地址，如：
file:C:/config.properties/config.propertiesclasspath:config.properties
注意getResource返回的Resource并不一定实际存在，可以通过Resource.exists()方法对
其进行判断。
3) 事件传播
ApplicationContext基于Observer模式（java.util包中有对应实现），提供了针对Bean的事件传
播功能。通过Application. publishEvent方法，我们可以将事件通知系统内所有的
ApplicationListener。
事件传播的一个典型应用是，当Bean中的操作发生异常（如数据库连接失败），则通过事件传播
机制通知异常监听器进行处理。在笔者的一个项目中，就曾经借助事件机制，较好的实现了当系统
异常时在监视终端上报警，同时发送报警SMS至管理员手机的功能。
在目前版本的Spring中，事件传播部分的设计还有待改进。同时，如果能进一步支持异步事件处理
机制，无疑会更具吸引力。
下面是一个简单的示例，当LoginAction执行的时候，激发一个自定义消息“ActionEvent”，此
ActionEvent将由ActionListener捕获，并将事件内容打印到控制台。
LoginActoin.java:
public class LoginAction implements ApplicationContextAware {
private ApplicationContext applicationContext;
public void setApplicationContext(
ApplicationContext applicationContext
)
throws BeansException {
this.applicationContext = applicationContext;
}
public int login(String username,String password) {
ActionEvent event = new ActionEvent(username);
this.applicationContext.publishEvent(event);
return 0;
}}
ActionEvent.java:
public class ActionEvent extends ApplicationEvent {
public ActionEvent(Object source) {
super(source);
}}
ActionListener.java:
public class ActionListener implements ApplicationListener {
public void onApplicationEvent(ApplicationEvent event) {
if (event instanceof ActionEvent) {
System.out.println(event.toString());
}}}
配置非常简单：
<bean id="loginaction" class="net.xiaxin.beans.LoginAction"/>
<bean id="listener" class="net.xiaxin.beans.ActionListener"/>
运行测试代码：
ApplicationContext ctx=new
FileSystemXmlApplicationContext("bean.xml");
LoginAction action = (LoginAction)ctx.getBean("action");
action.login("Erica","mypass");
可以看到控制台输出：
net.xiaxin.beans.LoginEvent[source=Erica]
org.springframework.context.event.ApplicationEventMulticasterImpl实现了事件传播机
制，目前还相对简陋。在运行期，ApplicationContext会自动在当前的所有Bean中寻找ApplicationListener接口的实现，并将其作为事件接收对象。当Application. publishEvent方法调用时，所有的ApplicationListener接口实现都会被激发，每个ApplicationListener可根据事件的类型判断是否是自己需要处理的事件，如上面的ActionListener只处理ActionEvent事件。
Web Context
上面的示例中，ApplicationContext均通过编码加载。对于Web应用，Spring提供了可配置的ApplicationContext加载机制。加载器目前有两种选择：ContextLoaderListener和ContextLoaderServlet。这两者在功能上完全等同，只是一个是基于Servlet2.3版本中新引入的Listener接口实现，而另一个基于Servlet接口实现。开发中可根据目标Web容器的实际情况进行选择。配置非常简单，在web.xml中增加：
<listener>
<listener-class>
org.springframework.web.context.ContextLoaderListener
</listener-class>
</listener>
或：
<servlet>
<servlet-name>context</servlet-name>
<servlet-class>
org.springframework.web.context.ContextLoaderServlet
</servlet-class>
<load-on-startup>1</load-on-startup>
</servlet>
通过以上配置，Web容器会自动加载/WEB-INF/applicationContext.xml初始化
ApplicationContext实例，如果需要指定配置文件位置，可通过context-param加以指定：
<context-param>
<param-name>contextConfigLocation</param-name>
<param-value>/WEB-INF/myApplicationContext.xml</param-value>
</context-param>
配置完成之后，即可通过
WebApplicationContextUtils.getWebApplicationContext
方法在Web应用中获取ApplicationContext引用。
Spring 高级特性
Web 应用与MVC
目前，基于Web的MVC1框架在J2EE的世界内空前繁荣。TTS网站上几乎每隔一两个星期
就会有新的MVC框架发布。
目前比较好的MVC,老牌的有Struts、Webwork。新兴的MVC 框架有Spring MVC、
Tapestry、JSF等。这些大多是著名团队的作品，另外还有一些边缘团队的作品，也相当出色，
如Dinamica、VRaptor等。
这些框架都提供了较好的层次分隔能力。在实现良好的MVC 分隔的基础上，通过提供一些
现成的辅助类库，同时也促进了生产效率的提高。
如何选择一个合适的框架？什么是考量一个框架设计是否优秀的标准？很难定夺的问题。
旁观各大论坛中铺天盖地的论战，往往在这一点上更加迷茫。
从实际Web产品研发的角度而言（而非纯粹设计上，扩展性上，以及支持特性上的比较），
目前Struts 也许是第一选择。作为一个老牌MVC Framework，Struts 拥有成熟的设计，
同时，也拥有最丰富的信息资源和开发群体。换句实在点的话，产品基于Struts 构建，如果
公司发生人事变动，那么，找个熟悉Struts的替代程序员成本最低。
从较偏向设计的角度出发，WebWork2 的设计理念更加先进，其代码与Servlet API 相
分离，这使得单元测试更加便利，同时系统从BS结构转向CS接口也较为简单。另外，对于基
于模板的表现层技术（Velocity、Freemarker和XSLT）的支持，也为程序员提供了除JSP
之外的更多的选择（Struts也支持基于模板的表现层技术，只是实际中不太常用）。
而对于Spring而言，首先，它提供了一个相当灵活和可扩展的MVC实现，与WebWork2
相比，它在依赖注入方面、AOP 等方面更加优秀，但在MVC 框架与底层构架的分离上又与
Webworks 存在着一定差距（Spring 的MVC 与Servlet API 相耦合，难于脱离Servlet
容器独立运行，在这点的扩展性上，比Webwork2稍逊一筹）。
我们还要注意到，Spring对于Web应用开发的支持，并非只限于框架中的MVC部分。即
使不使用其中的MVC实现，我们也可以从其他组件，如事务控制、ORM模板中得益。同时，Spring
也为其他框架提供了良好的支持，如我们很容易就可以将Struts 与Spring 甚至WebWork
与Spring 搭配使用（与WebWork 的搭配可能有些尴尬，因为两者相互覆盖的内容较多，如
WebWork中的依赖注入机制、AOP机制等与Spring中的实现相重叠）。因此，对于Spring
在Web应用中的作用，应该从一个更全面的角度出发。
下面我们就将针对Spring MVC，以及Spring+Struts、Spring+Webwork2 的Web
应用模式进行介绍，通过这几种模式的比较，大家也可以作出自己的判断，寻找更加适合自己
的方案组合。
1 MVC即Model-View-Control 的缩写，为架构模式的一种，具体描述可通过Google获取
Spring MVC
上面谈到了Struts、Webwork 这些现有的MVC 框架的特色。而Spring MVC 在这些框
架之中，处于怎样一个位置？在我们开始探讨这个新的MVC Framework 之前，这是个值得思
考的问题。
下面，先让我们来看看Spring MVC在具体应用中的表现，再有针对性的进行比较，以免
形而上学的空谈。
Spring MVC指南
对于现有较成熟的Model-View-Control(MVC)框架而言，其解决的主要问题无外乎下
面几部分：
1．将Web页面中的输入元素封装为一个（请求）数据对象。
2．根据请求的不同，调度相应的逻辑处理单元，并将（请求）数据对象作为参数传入。
3．逻辑处理单元完成运算后，返回一个结果数据对象。
4．将结果数据对象中的数据与预先设计的表现层相融合并展现给用户。
各个MVC 实现固然存在差异，但其中的关键流程大致如上。结合一个实例，我们来看看这
几个关键______流程在Spring MVC框架中的处理手法。
下面的实例，实现了一个常见的用户登录逻辑，即用户通过用户名和密码登录，系统对用
户名和密码进行检测，如果正确，则在页面上显示几条通知信息。如果登录失败，则返回失败
界面。
(示例中，表示层以JSP2.0实现。)
出于简洁考虑，这里的“用户名/密码”检测以及通知信息的生成均在代码中以硬编码实现。
首先来看登录界面：
对应的index.html:
<html>
<body>
<form method="POST" action="/login.do">
<p align="center">登录</p>
<br>
用户名:
<input type="text" name="username" >
<br>
密 码 :
<input type="password" name="password" >
<br>
<p>
<input type="submit" value="提交" name="B1">
<input type="reset" value="重置" name="B2">
</p>
</form>
</body>
</html>
很简单的一个登录界面，其中包含了一个用以输入用户名密码的form，针对此form的提
交将被发送到"/login.do"
MVC 关键流程的第一步，即收集页面输入参数，并转换为请求数据对象。这个静态页面提
供了一个基本的输入界面，下面这些输入的数据将被发送至何处，将如何被转换为请求数据对
象？
现在来看接下来发发生的事情：
当用户输入用户名密码提交之后，此请求被递交给Web 服务器处理，上面我们设定form
提交目标为"/login.do"，那么Web服务器将如何处理这个请求？
显然，标准Http 协议中，并没有以.do 为后缀的服务资源，这是我们自己定义的一种请
求匹配模式。此模式在web.xml中设定：
<?xml version="1.0" encoding="ISO-8859-1"?>
<web-app xmlns="http://java.sun.com/xml/ns/j2ee"
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
xsi:schemaLocation="http://java.sun.com/xml/ns/j2ee
http://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd"
version="2.4">
<servlet> ⑴
<servlet-name>Dispatcher</servlet-name>
<servlet-class>
org.springframework.web.servlet.DispatcherServlet
</servlet-class>
<init-param>
<param-name>contextConfigLocation</param-name>
<param-value>/WEB-INF/Config.xml</param-value>
</init-param>
</servlet>
<servlet-mapping> ⑵
<servlet-name>Dispatcher</servlet-name>
<url-pattern>*.do</url-pattern>
</servlet-mapping>
</web-app>
⑴ Servlet定义
这里我们定义了请求分发Servlet，即：
org.springframework.web.servlet.DispatcherServlet
DispatcherServlet 是Spring MVC 中负责请求调度的核心引擎，所有的请求将
由此Servlet 根据配置分发至各个逻辑处理单元。其内部同时也维护了一个
ApplicationContext实例。
我们在<init-param>节点中配置了名为“contextConfigLocation”的
Servlet参数，此参数指定了Spring配置文件的位置“/WEB-INF/Config.xml”。
如果忽略此设定，则默认为“/WEB-INF/<servlet name>-servlet.xml”，其
中<servlet name>以Servlet 名替换（在当前环境下，默认值也就是
“/WEB-INF/Dispatcher-servlet.xml）。
⑵ 请求映射
我们将所有以.do结尾的请求交给Spring MVC进行处理。当然，也可以设为其他值，
如.action、.action等。
通过以上设定，Web 服务器将把登录界面提交的请求转交给Dispatcher 处理，
Dispatcher将提取请求（HttpServletRequest）中的输入数据，分发给对应的处理单元，
各单元处理完毕后，将输出页面返回给Web服务器，再由Web服务器返回给用户浏览器。
Dispatcher 根据什么分发这些请求？显然，我们还需要一个配置文件加以设定。这也就
是上面提及的Config.xml，此文件包含了所有的“请求/处理单元”关系映射设定，以及返回
时表现层的一些属性设置。
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE beans PUBLIC "-//SPRING//DTD BEAN//EN"
"http://www.springframework.org/dtd/spring-beans.dtd">
<beans>
<!--Definition of View Resolver -->
<bean id="viewResolver" ⑴
class="org.springframework.web.servlet.view.InternalResourceViewResolver">
<property name="viewClass"> ⑵
<value>
org.springframework.web.servlet.view.JstlView
</value>
</property>
<property name="prefix"> ⑶
<value>
/WEB-INF/view/
</value>
</property>
<property name="suffix"> ⑷
<value>.jsp</value>
</property>
</bean>
<!--Request Mapping -->
<bean id="urlMapping" ⑸
class="org.springframework.web.servlet.handler.SimpleUrlHandlerMapping">
<property name="mappings">
<props>
<prop key="/login.do">LoginAction</prop>
</props>
</property>
</bean>
<!---Action Definition-->
<bean id="LoginAction" ⑹
class="net.xiaxin.action.LoginAction">
<property name="commandClass"> ⑺
<value>net.xiaxin.action.LoginInfo</value>
</property>
<property name="fail_view"> ⑻
<value>loginfail</value>
</property>
<property name="success_view">
<value>main</value>
</property>
</bean>
</beans>
⑴ Resolver设定
Resolver将把输出结果与输出界面相融合，为表现层提供呈现资源。
⑵ View Resolver的viewClass参数
这里我们使用JSP页面作为输出，因此，设定为：
org.springframework.web.servlet.view.JstlView
其余可选的viewClass还有:
org.springframework.web.servlet.view.freemarker.FreeMarker
View（用于基于FreeMarker模板的表现层实现）
org.springframework.web.servlet.view.velocity.VelocityView
（用于基于velocity模板的表现层实现）
等。
⑶⑷View Resolver的prefix和suffix参数
指定了表现层资源的前缀和后缀，运行时，Spring 将为指定的表现层资源自动追加
前缀和后缀，以形成一个完整的资源路径。另参见⑻
⑸ “请求/处理单元”关系映射
可以看到，这里我们将“/login.do”请求映射到处理单元LoginAction。
<props>节点下可以有多个映射关系存在，目前我们只定义了一个。
⑹ LoginAction定义
这里定义了逻辑处理单元LoginAction 的具体实现，这里，LoginAction 的实现
类为net.xiaxin.action.LoginAction。
⑺ LoginAction的请求数据对象
commandClass 参数源于LoginAction 的基类BaseCommandController，
BaseCommandControlle 包含了请求数据封装和验证方法
（ BaseCommandController.bindAndValidate ） ， 它将根据传入的
HttpServletRequest构造请求数据对象。
这里我们指定commandClass 为net.xiaxin.action.LoginInfo，这是一个非
常简单的Java Bean，它封装了登录请求所需的数据内容：
public class LoginInfo {
private String username;
private String password;
public String getPassword() {
return password;
}
public void setPassword(String password) {
this.password = password;
}
public String getUsername() {
return username;
}
public void setUsername(String username) {
this.username = username;
}
}
Spring会根据LoginAction的commandClass定义自动加载对应的LoginInfo
实例。
之后，对Http 请求中的参数进行遍历，并查找LoginInfo 对象中是否存在与之同
名的属性，如果找到，则将此参数值复制到LoginInfo对象的同名属性中.
请求数据转换完成之后，我们得到了一个封装了所有请求参数的Java 对象，并将此
对象作为输入参数传递给LoginAction。
⑻ 返回视图定义
对于这里的LoginAction 而言，有两种返回结果，即登录失败时返回错误界面，登
录成功时进入系统主界面。
对应我们配置了fail_view、success_view两个自定义参数。
参数值将由Resolver进行处理，为其加上前缀后缀，如对于fail_view而言，实
际的视图路径为/WEB-INF/view/loginfail.jsp。
之后，Resolver 会将LoginAction的返回数据与视图相融合，返回最终的显示界
面。
业务逻辑处理单元:
LoginAction.java：
public class LoginAction extends SimpleFormController {
private String fail_view;
private String success_view;
protected ModelAndView onSubmit(Object cmd,BindException ex)throws Exception {
LoginInfo loginInfo = (LoginInfo) cmd;
if (login(loginInfo) == 0) {
HashMap result_map = new HashMap();
result_map.put("logininfo", loginInfo);
List msgList = new LinkedList();
msgList.add("msg1");
msgList.add("msg2");
msgList.add("msg3");
result_map.put("messages", msgList);
return new
ModelAndView(this.getSuccess_view(), result_map);
} else {
return new ModelAndView(this.getFail_view());
}
}
private int login(LoginInfo loginInfo) {
if ("Erica".equalsIgnoreCase(loginInfo.getUsername())
&& "mypass".equals(loginInfo.getPassword())) {
return 0;
}
return 1;
}
public String getFail_view() {
return fail_view;
}
public String getSuccess_view() {
return success_view;
}
public void setFail_view(String string) {
fail_view = string;
}
public void setSuccess_view(String string) {
success_view = string;
}
}
其中：
⑴ onSubmit方法我们在子类中覆盖了父类的onSubmit方法；而onSubmit方法用于处理业务请求。负责数据封装和请求分发的Dispatcher，将对传入的HttpServletRequest进行封装，形成请求数据对象，之后根据配置文件，调用对应业务逻辑类的入口方法（这里就是LoginAction）的onSubmit()方法，并将请求数据对象及其他相关资源引用传入。
protected ModelAndView onSubmit(
Object cmd,
BindException ex
)
onSubmit方法包含了两个参数：Object cmd和BindException ex。前面曾经多次提到请求数据对象，这个名为cmd的Object型参数，正是传入的请求数据对象的引用。BindException ex参数则提供了数据绑定错误的跟踪机制。它作为错误描述工具，用于向上层反馈错误信息。在Spring MVC中，BindException将被向上层表现层反馈，以便在表现层统一处理异常情况（如显示对应的错误提示），这一机制稍后在“输入参数合法性校验”部分再具体探讨。onSubmit还有另外一个签名版本：
protected ModelAndView onSubmit(
HttpServletRequest request,
HttpServletResponse response,
Object cmd,
BindException ex
)
可以看到，类似Servlet的doGet/doPost方法，此版本的onSubmit方法签名中包含了Servlet规范中的HttpServletRequest、HttpServletResponse以提供与Web服务器的交互功能（如Session的访问）。此参数类型的onSubmit方法的调用优先级较高。也就是说，如果我们在子类中同时覆盖了这两个不同参数的onSubmit方法，那么只有此版本的方法被执行，另一个将被忽略。
⑵ 将输入的请求数据对象强制转型为预定义的请求对象类型。
⑶ 返回处理结果ModelAndView类包含了逻辑单元返回的结果数据集和表现层信息。ModelAndView本身起到关系保存的作用。它将被传递给Dispatcher，由Dispatcher 根据其中保存的结果数据集和表现层设定合成最后的界面。这里我们用到了两种签名版本的ModelAndView构造方法：
public ModelAndView(String viewname)
返回界面无需通过结果数据集进行填充。
public ModelAndView(String viewname, Map model)返回界面由指定的结果数据集加以填充。可以看到，结果数据集采用了Map接口实现的数据类型。其中包含了返回结果中的各个数据单元。关于结果数据集在界面中的填充操作，可参见下面关于返回界面的描述。上面这两个版本的构造子中，通过viewname指定了表示层资源。另外，我们也可以通过传递View对象指定表示层资源。
public ModelAndView(View view)
public ModelAndView(View view, Map model)
我们可以结合RedirectView完成转向功能，如：
return new ModelAndView(new RedirectView(“/redirected.jsp”));
当然，我们也可以在带有HttpServletRequest参数的onSubmit方法实现中，通过HttpServletRequest/HttpServletResponse完成forward/redirect功能，这两种途径可以达到同样的效果。
最后，来看返回界面：
错误返回界面loginfail.jsp只是个纯html文件（为了与View Resolver中设定的后缀相匹配，因此以.jsp作为文件后缀），这里就不再浪费篇幅。再看成功登录后的页面main.jsp:界面显示效果如下：
<%@ taglib prefix="c" uri="http://java.sun.com/jstl/core_rt" %>
<html>
<body>
<p>Login Success!!!</p>
<p>Current User:
<c:out value="${logininfo.username}"/><br>
</p>
<p>Your current messages:</p>
<c:forEach items="${messages}"
var="item"
begin="0"
end="9"
step="1"
varStatus="var">
<c:if test="${var.index % 2 == 0}">
*
</c:if>
${item}<br>
</c:forEach>
</body>
</html>
页面逻辑非常简单，首先显示当前登录用户的用户名。然后循环显示当前用户的通知消息“messages”。如果当前循环索引为奇数，则在消息前追加一个“*”号（这个小特性在这里似乎有些多余，但却为不熟悉JSTL 的读者提供了如何使用JSTL Core taglib 进行循环和逻辑判断的样例）。实际上这只是个普通JSTL/JSP页面，并没有任何特殊之处，如果说有些值得研究的技术，也就是其中引用的JSTL Core Taglib
<%@ taglib prefix="c" uri="http://java.sun.com/jstl/core_rt" %>
上面这句话申明了页面中所引用的taglib，指定其前缀为“c”，也就是说，在页面中，所有以“c”为前缀，形同<c:xxxx>的节点都表明是此taglib的引用，在这里，也就是对JSTLCore Lib的引用。
这里需要注意的是，笔者所采用的Web 容器为Tomcat 5(支持Servlet 2.4/JSP2.0
规范)以ì及Apache JSTL 2.0(http://jakarta.apache.org/taglibs/index.html)。
<c:out value="${logininfo.username}"/>
<c:out>将value 中的内容输出到当前位置，这里也就是把logininfo 对象的
username属性值输出到页面当前位置。
${……}是JSP2.0 中的Expression Language（EL）的语法。它定义了一个表达式，
其中的表达式可以是一个常量（如上），也可以是一个具体的表达语句（如forEach循环体中
的情况）。典型案例如下：
${logininfo.username}这表明引用logininfo 对象的username 属性。我们可以通过“.”操作符引用对象的属性，也可以用“[]”引用对象属性，如${logininfo[username]}与${logininfo.username}达到了同样的效果。“[]”引用方式的意义在于，如果属性名中出现了特殊字符，如“.”或者“-”，此时就必须使用“[]”获取属性值以避免语法上的冲突（系统开发时应尽量避免这一现象的出现）。与之等同的JSP Script大致如下：
LoginInfo logininfo =(LoginInfo)session.getAttribute(“logininfo”);
String username = logininfo.getUsername();
可以看到，EL大大节省了编码量。这里引出的另外一个问题就是，EL 将从哪里找到logininfo 对象，对于${logininfo.username}这样的表达式而言，首先会从当前页面中寻找之前是否定义了变量logininfo，如果没有找到则依次到Request、Session、Application 范围内寻找，直到找到为止。如果直到最后依然没有找到匹配的变量，则返回null.如果我们需要指定变量的寻找范围，可以在EL表达式中指定搜寻范围：
${pageScope.logininfo.username}
${requestScope.logininfo.username}
${sessionScope.logininfo.username}
${applicationScope.logininfo.username}
在 Spring 中，所有逻辑处理单元返回的结果数据，都将作为Attribute 被放置到HttpServletRequest 对象中返回（具体实现可参见Spring 源码中org.springframework.web.servlet.view.InternalResourceView.exposeModelAsRequestAttributes方法的实现代码），也就是说SpringMVC 中，结果数据对象默认都是requestScope。因此，在Spring MVC 中，以下寻址方法应慎用：
${sessionScope.logininfo.username}
${applicationScope.logininfo.username}
${1＋2}结果为表达式计算结果，即整数值3。
${i>1}如果变量值i>1的话，将返回bool类型true。与上例比较，可以发现EL会自动根据表达式计算结果返回不同的数据类型。表达式的写法与java代码中的表达式编写方式大致相同。
<c:forEach items="${messages}"
var="item"
begin="0"
end="9"
step="1"
varStatus="var">
……
</c:forEach>
上面这段代码的意思是针对messages 对象进行循环，循环中的每个循环项的引用变量为item，循环范围是从0到9，每次步长为1。而varStatus则定义了一个循环状态变量var，循环状态变量中保存了循环______进行时的状态信息，包括以下几个属性：
属性类型 说明
index int 当前循环索引号
count int 成员总数
first boolean 当前成员是否首位成员
last boolean 当前成员是否末尾成员
再看：
<c:if test="${var.index % 2 == 0}">
*
</c:if>
这段代码演示了判定Tag <c:if>的使用方法。可以看到，其test属性指明了判定条件，
判定条件一般为一个EL表达式。
<c:if>并没有提供else子句，使用的时候可能有些不便，此时我们可以通过<c:choose>
tag来达到类似的目的：
<c:choose>
<c:when test="${var.index % 2 == 0}">
*
</c:when>
<c:otherwise>
!
</c:otherwise>
</c:choose>
类似Java 中的switch 语句，<c:choose>提供了复杂判定条件下的简化处理手法。其
中<c:when>子句类似case子句，可以出现多次。上面的代码，在奇数行时输出“*”号，
而偶数行时输出“!”。
通过<c:choose>改造后的输出页面：
至此，一个典型的请求/响应过程结束。通过这个过程，我们也了解了Spring MVC 的核
心实现机制。对其进行总结，得到以下UML序列图：
基于模板的Web 表示层技术
传统的JSP技术为Web表现层技术提供了灵活、丰富的功能支持。然而，站在工程的角度
而言，过于凌乱的JSP Script也成为系统维护的头号大敌。
JSP 代码几乎等同于Java 代码，在提供了最丰富的特性支持的同时，也为系统的开发带
来一些隐患，程序员往往天马行空，不为羁束，在JSP 中将业务逻辑、数据逻辑、表现逻辑代
码相混杂，代码重用性、系统可维护性极低。特别是在参与开发人员众多，技术水平良莠不齐
的情况下，纵使技术经理一再强调设计规范的约束，但人本的约束总是难以控制，随着开发过
程进展和产品上线压力的增大，规范约束逐渐薄弱，于是难以避免的造成代码的混乱，可维护
性的下降。
面对这个问题，众多组织和厂商开始研发自己的表现层框架，试图通过一个隔离的表现层
框架，强行将表现层和逻辑层相剥离。时间似乎退回到了最初Web 端只支持Servlet 技术的
时代（那时候或多或少各个公司都有自己的模板实现）。不过，现在的模板技术经过长时间的
发展，已经将表现层的能力发挥得淋漓尽致，不失为JSP技术之外的一个明智选择。
模板技术相对传统JSP技术有以下三个主要优势：
1．在技术层面，将表现逻辑与业务逻辑相分离。
2．为人员之间的分工提供了一个良好的分界点。页面美工只需专著关心模板的设计，而程
序员则专注于业务逻辑的实现。二者重合点明显减少。
3．如果需要，模板引擎可脱离Web 容器单独运行，这为系统可能的移植需求提供了更多
的弹性空间（这一特性在应用中也许并不会有太大的实际意义，只是提供了一种附加选
择）。
目前Spring支持一下几种模板技术：
1．XSLT
XSLT是基于XML的表现层模板技术，伴随着XML的大量使用。XSLT也日渐成熟，并
迅速成为主流表现层技术之一。XSLT作为一个通用表现层框架，拥有最好的平台适应性，
几乎所有的主流程序设计语言都提供了XLST支持，现有的XLST模板可以简单的移植到不
同的语言平台，如将J2EE应用中的XSLT移植到.net平台，这样的可移植性是其他专用
模板技术，如Velocity和Freemarker难以达到的。
笔者在2001年在一个原型项目中采用了XSLT作为表现层实现，由于当时XSLT尚不
成熟，XSLT解析器效率低下，因此在正式产品开发中使用其他技术作为替代。在2003年
中，经过技术探讨，决定再次在项目实施中引入XSLT 技术，相对两年前，此时的XSLT
技术已经相当成熟，解析器的效率也大大改善。经过半年时间的项目研发，产品上线，并
取得了令人满意的表现。不过，在之后的项目回顾过程中，笔者认为，目前在项目中大量
采用XSLT技术尚不可取，上述项目开发过程中，XSLT技术提供了极佳的扩展性和重用性，
也保证了业务逻辑和表示逻辑的清晰划分，然而，最大的问题是，XSLT缺乏强有力的编辑
器支持。虽然通过XML/XSLT 技术成全了设计上近乎完美的表现，但却为界面开发带来了
极大难度，以至后期复杂界面的修改都需要消耗极大的人力，得不偿失。
笔者在项目开发中所用的XSLT 编辑器为StylusStudio 和XmlSpy，目前这两款编
辑器可以算是XSLT开发的首选，提供了丰富的特性和可视化编辑功能。但即便如此，XLST
繁杂苛刻的语法和调试上的难度也为开发工作带来了极大的障碍。
此外，也许是最重要的一点，xslt在性能上的表现尚不尽如人意。经过多年的发展，
XSLT解析/合成器的性能相对最初已经大为改观，但依然与其他模板技术存在着较大差距。
据实地测试，FreeMarker和Velocity对于同等复杂度的表现层逻辑，平均处理速度是
XSLT 的10 倍以上，这是一个不得不正视的性能沟壑。同时，XSLT 的内存占用也是
FreeMarker 和Velocity 的数倍有余（XSLT 中，每个节点都是一个Java 对象，大量
对象的存储对内存占用极大，同时大量对象的频繁创建和销毁也对JVM 垃圾收集产生了较
大负面影响）。在上述项目中，由于硬件上的充分冗余（8G RAM, 4CPU），才使得这些
性能上的影响相对微弱。
因此，目前在项目中大量引入XSLT技术尚需仔细考量。
2．Velocity
Velocity是Apache Jakarta项目中的一个子项目，它提供了丰富强大的模板功能。
作为目前最为成熟的模板支持实现，Velocity 在诸多项目中得到了广泛应用，不仅
限于Web 开发，在众多代码生成系统中，我们也可以看到Velocity 的身影（如
Hibernate中的代码生成工具）。
3．FreeMarker
FreeMarker是Velocity之外的另一个模板组件。
与 Velocity 相比，FreeMarker 对表现逻辑和业务逻辑的划分更为严格，
Freemarker在模板中不允许对Servlet API进行直接操作（而Velocity可以），
如FreeMarker 中禁止对HttpServletRequest 对象直接访问（但可以访问
HttpServletRequest对象中的Attribute）。通过更加严格的隔离机制，牵涉逻
辑处理的操作被强制转移到逻辑层。从而完全保证了层次之间的清晰性。
另外一个Velocity无法实现的特性，也是最具备实际意义的特性：FreeMarker对
JSP Tag提供了良好支持。这一点可能存在一点争议，JSP技术的最大问题就是容易
在页面中混入逻辑代码。而FreeMarker 对JSP Tag 的支持似乎为这个问题又打开
了大门。这一点上，我们可以将FreeMarker看作是仅允许使用TAG的JSP页面（实
际上，FreeMarker的表达式语法与EL语法也非常类似）。
从开发角度而言，只允许使用TAG的JSP页面，已经在很大______程度上保证了页面表现逻
辑与业务逻辑的分离。程序员在JSP Script中混杂逻辑代码的原因，大部分是出于
慵懒，只要无法在页面模板中直接编写Java代码，相信程序员也不会去专门编写一个
JSP TAG来刻意违反层次划分原则。
对 JSP TAG 的支持为FreeMarker 带来了极大的活力，目前开源社区中已经有了为
数众多的成熟Taglib，如DisplayTag、Struts Menu等，这些功能丰富，成熟可
靠的Taglib，将为产品开发提供极大的便利。另一方面，这也为代码重用提供了另一
个可选途径，避免了大部分模板实现在这一点上的不足。
就笔者的经验，对于Web开发而言，FreeMarker在生产效率和学习成本上更具优势，
而Velocity 的相对优势在于更多第三方工具的支持和更广泛的开发和用户团体（然
而对于一个轻量级模板类库而言，这样的优势并不是十分明显）。
如果没有Velocity的技术储备，而又需要通过技术上的限定解决视图/模型的划分问
题，这里推荐采用FreeMarker作为Spring MVC中的表现层实现。以获得最好的（学
习、开发）成本受益。
下面，我们将对之前的JSP DEMO进行改造，以展示基于FreeMarker的Spring MVC
应用技术。至于XSLT和Velocity，Spring官方文档中已经有了很全面的介绍，这里暂
且掠过，如果有兴趣，可以自行参阅Spring Reference。（笔者完成此文时Spring版
本为1.0.2，在Spring 1.1之后，官方文档中也增添了FreeMarker的相关介绍）
对于上面例子中的几个文件，需要进行改编的是Config.xml 和登录后的主页面
（main.jsp，改编后为main.ftl，后缀名ftl是freemarker模板的习惯命名方式）。
改编后的Config.xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE beans PUBLIC "-//SPRING//DTD BEAN//EN"
"http://www.springframework.org/dtd/spring-beans.dtd">
<beans>
<bean id="viewResolver" ⑴
class="org.springframework.web.servlet.view.freemarker.
FreeMarkerViewResolver">
<property name="viewClass">
<value>
org.springframework.web.servlet.view.freemarker.FreeMar
kerView
</value>
</property>
<property name="cache"><value>false</value></property>
<property name="suffix"><value>.ftl</value></property>
</bean>
<bean id="freemarkerConfig" ⑵
class="org.springframework.web.servlet.view.freemarker.
FreeMarkerConfigurer">
<property name="templateLoaderPath">
<value>WEB-INF/view/</value>
</property>
</bean>
<!---Action Definition-->
<bean id="LoginAction" class="net.xiaxin.action.LoginAction">
<property name="commandClass">
<value>net.xiaxin.action.LoginInfo</value>
</property>
<property name="fail_view">
<value>loginfail</value></property>
<property name="success_view">
<value>main</value>
</property>
</bean>
<!--Request Mapping -->
<bean id="urlMapping"
class="org.springframework.web.servlet.handler.SimpleUr
lHandlerMapping">
<property name="mappings">
<props>
<prop key="/login.do">LoginAction</prop>
</props>
</property>
</bean>
</beans>
可以看到，配置文件进行了局部修改：
⑴ 由于我们采用FreeMarker作为表现层技术。原有的viewResolver的定义发
生了变化。
viewResolver class被修改为:
org.springframework……FreeMarkerConfigurer
view属性被修改为：
org.springframework……FreeMarkerView
suffix属性被修改为FreeMarker模板文件默认后缀“.ftl”。
prefix属性被取消，因为下面的freemarkerConfig中已经定义了模板路径。
⑵ 增加了freemarkerConfig定义，并通过templateLoaderPath属性设定了
模板文件的存放路径（相对Web Application根目录）。
模板文件main.ftl:
<html>
<head>
<title>Welcome!</title>
</head>
<body>
<h1>Current User: ${logininfo.username}</h1> ⑴
<#list messages as msg> ⑵
<#if msg_index % 2=0> ⑶
*
<#else>
!
</#if>
${msg}<br>
</#list>
</body>
</html>
⑴ 对数据对象logininfo的username属性的引用。
⑵ 针对Collection型数据messages的循环，并通过as子句指定迭代变量msg，msg引
用了messages中的当前循环项目。
⑶ if else语句
这里的msg_index为当前循环索引号。“_index”是FreeMarker中对于循环索引
变量的命名约定。通过“迭代变量名_index”即可访问当前循环索引。
类似的循环状态访问约定还有“迭代变量名_has_next”，可通过这个循环状态属性
判断是否还有后继循环。
此模板文件最终运行效果与之前的main.jsp页面大致相同：
Web应用中模板技术与JSP技术的对比
通过上面的例子可以看到，FreeMarker模板文件与之前使用JSTL Core Taglib实
现的JSP页面非常相似。
实际上，仅采用JSTL Core Taglib/EL 的JSP页面，也可以理解为基于JSP技术的
模板实现，甚至在可视化编辑器中，仅采用JSTL Core Taglib/EL 的JSP页面的可视化
编辑效果更好。下面是main.ftl和main.jsp在DreamWeaver可视化编辑环境中的表现：
main.ftl:
main.jsp:
可以看到，main.jsp的可视化编辑效果明显更接近于实际运行效果。这对于表现层的设计
而言显得别具意义。
由此,再重申一点，模板技术最大的功用在于强制开发人员将Java代码排除在表现层之外
（同时也将页面美工和程序员的工作范围清晰划分），而对于具体表现层设计的帮助倒未
必突出。
如果项目参与人员具备良好的技术素养和协同精神，并且在技术上允许（目前很多Web容器
还不支持JSP2.0及其EL语法），笔者建议还是采用以JSTL Core为基础，以及有限的、
与业务逻辑无关的自定义Tag（或第三方Taglib）的JSP页面作为表现层解决方案。毕竟
我们的目标是最低的学习/开发成本，最高的生产率。
输入验证与数据绑定
Spring Framework提供了强大的输入验证和数据绑定功能。结合输入验证器和
<spring:bind>tag，传统繁杂混乱的输入校验功能将变得更加清晰简单。
同样，下面先结合一个实例来看Spring输入验证和数据绑定机制的具体验证。
实例目标：实现用户注册功能。
流程：
1． 提供一个界面供用户输入注册信息，下面是一个简化的注册界面，仅提供了用
户名和密码的设置
2． 如果用户注册信息有误，显示错误界面，要求用户检查输入后重新注册。
3． 注册成功，显示操作成功提示。
实例内容
a) 配置文件
在这个实例中，我们选用JSTLView作为我们的表现层实现。对应的配置文件如下。
Config.xml:
<beans>
<bean id="viewResolver"
class="org.springframework.web.servlet.view.InternalRes
ourceViewResolver">
<property name="viewClass">
<value>
org.springframework.web.servlet.view.JstlView
</value>
</property>
<property name="prefix">
<value>/WEB-INF/view/</value>
</property>
<property name="suffix">
<value>.jsp</value>
</property>
</bean>
<bean id="RegisterValidator" ⑴
class="net.xiaxin.validator.RegisterValidator"/>
<bean id="RegisterAction"
class="net.xiaxin.action.RegisterAction">
<property name="commandClass">
<value>net.xiaxin.reqbean.RegisterInfo</value>
</property>
<property name="validator"> ⑵
<ref local="RegisterValidator"/>
</property>
<property name="formView"> ⑶
<value>register</value>
</property>
<property name="successView"> ⑷
<value>RegisterSuccess</value>
</property>
</bean>
<!--Request Mapping -->
<bean id="urlMapping"
class="org.springframework.web.servlet.handler.SimpleUr
lHandlerMapping">
<property name="mappings">
<props>
<prop key="/register.do">RegisterAction</prop>
</props>
</property>
</bean>
</beans>
这个配置文件与篇首MVC介绍中所用实例大同小异。不同之处在于我们在这里引入了数
据验证配置节点：
⑴ 配置了一个数据验证Bean: RegisterValidator
net.xiaxin.validator.RegisterValidator
⑵ 为逻辑处理单元RegisterAction定义输入数据校验Bean
这里通过一个Bean引用，将RegisterValidator配置为本Action的数据校验
类。
⑶ 指定本处理单元的显示界面。
formView是RegisterAction的父类SimpleFormController中定义的属
性，指定了本处理单元的显示界面。
这里即用户访问register.do时将显示的注册界面。
要注意的是，完成此界面后，我们必须通过“…/register.do”访问注册界面，
而不是“…/register.jsp”，因为我们必须首先借助Spring完成一系列初始
化工作（如创建对应的状态对象并与之关联）之后，register.jsp才能顺利执
行，否则我们会得到一个应用服务器内部错误。
⑷ 指定成功返回界面。
successView同样是RegisterAction的父类SimpleFormController中定
义的属性，它指向成功返回界面。
b) 数据验证类
在Spring中，所有的数据验证类都必须实现接口:
org.springframework.validation.Validator
Validator接口定义了两个方法：
boolean supports(Class clazz);
用于检查当前输入的数据类型是否符合本类的检验范围。Spring调用
Validator实现类时，首先会通过这个方法检查数据类型是否与此Validator
相匹配。
void validate(Object obj, Errors errors);
数据校验方法。Validator实现类通过实现这个方法，完成具体的数据校验逻辑。
RegisterValidator.java：
public class RegisterValidator implements Validator {
public boolean supports(Class clazz) {
return RegisterInfo.class.isAssignableFrom(clazz); ⑴
}
public void validate(Object obj, Errors errors) {
RegisterInfo regInfo = (RegisterInfo) obj; ⑵
//检查注册用户名是否合法
if (regInfo.getUsername().length() < 4) {
errors.rejectValue("username", ⑶
"less4chars",
null,
"用户名长度必须大于等于4个字母！");
}
/*检查用户名是否已经存在
if (UserDAO.getUser(regInfo.getUsername()) != null) {
errors.rejectValue("username",
"existed",
null,
"用户已存在！");
}
*/
if (regInfo.getPassword1().length() < 6) {
errors.rejectValue("password1",
"less6chars",
null,
"密码长度必须大于等于6个字母");
}
if (!regInfo.getPassword2().equals(regInfo.getPassword1()))
{
errors.rejectValue("password2",
"notsame",
null,
"两次输入的密码不一致！");
}}}
⑴ RegisterInfo.class.isAssignableFrom方法用于判定参数类别，当传入
Class对象与当前类类别相同，或是当前类的父类（或当前类实现的接口）时返回真。这
里我们将其用于对校验对象的数据类型进行判定（这里的判定条件为：校验对象必须是
RegisterInfo类的实例）。
⑵ RegisterInfo regInfo = (RegisterInfo) obj;
将输入的数据对象转换为我们预定的数据类型。
⑶ 通过rejectValue方法将错误信息加入Error列表，此错误信息将被页面捕获并
显示在错误提示界面上。
rejectVlaue方法有4个参数：
1．Error Code
显示错误时，将根据错误代码识别错误信息类型。
2．Message Key
上 面关于ApplicationContext 的国际化支持时， 我们曾经谈及
MessageSource的使用，这里我们可以通过引入MessageSource实现提示信息
的参数化，此时，本参数将用作.properties文件中的消息索引。
3．Error Argument
如果提示信息中需要包含动态信息，则可通过此参数传递需要的动态信息对象。具
体参见ApplicationContext中关于国际化实现的描述。
4．Default Message
如果在当前MessageSource中没有发现Message Key对应的信息数据，则以此
默认值返回。
这里我们暂时尚未考虑国际化支持，所有的信息都将通过Default Message返
回。关于国际化支持请参见稍后章节。
另外rejectValue还有另外几个简化版本，可根据情况选用。
c) 注册界面
register.jsp提供了注册操作界面。它同时提供了最初的注册界面，当输入参数非
法时，同时也会显示错误信息，提示用户检查输入。
register.jsp:
<!-- 页面中使用了JSTL Core taglib 和Spring lib-->
<%@ taglib prefix="c" uri="http://java.sun.com/jstl/core_rt" %>
<%@ taglib prefix="spring" uri="http://www.springframework.org/tags" %>
<!-- 设定页面编译时采用gb2312编码，同时指定浏览器显示时采取gb2312解码-->
<%@ page pageEncoding="gb2312"
contentType="text/html;charset=gb2312"%>
<html>
<head>
<title>用户注册</title>
</head>
<body style="text-align: center">
<form method="POST" action="/register.do">
<spring:bind path="command.*">
<font color="#FF0000">
<c:forEach
items="${status.errorMessages}"
var="error">
错误: <c:out value="${error}"/><br>
</c:forEach>
</font>
</spring:bind>
<table border="0" width="450" height="101"
cellspacing="0" cellpadding="0" >
<tr>
<td height="27" width="408" colspan="2">
<p align="center"><b>用户注册</b></td>
</tr>
<tr>
<td height="23" width="104">用户名：</td>
<td height="23" width="450">
<spring:bind path="command.username">
<input
type="text"
value="<c:out value="${status.value}"/>"
name="<c:out value="${status.expression}"/>"
> 
（必须大于等于4个字符）
<br>
<c:if test="${status.error}">
<font color="#FF0000">
错误:
<c:forEach
items="${status.errorMessages}"
var="error">
<c:out value="${error}"/>
</c:forEach>
</font>
</c:if>
</spring:bind>
</td>
</td>
</tr>
<tr>
<td height="23" width="104">密码：</td>
<td height="23" width="450">
<spring:bind path="command.password1">
<input
type="password"
value="<c:out value="${status.value}"/>"
name="<c:out value="${status.expression}"/>"
> 
（必须大于等于6个字符）
<br>
<c:if test="${status.error}">
<font color="#FF0000">
错误:
<c:forEach
items="${status.errorMessages}"
var="error">
<c:out value="${error}"/>
</c:forEach>
</font>
</c:if>
</spring:bind>
</td>
</tr>
<tr>
<td height="23" width="104">重复密码：</td>
<td height="23" width="450">
<spring:bind path="command.password2">
<input type="password"
value="<c:out value="${status.value}"/>"
name="<c:out value="${status.expression}"/>"
> 
<br>
<c:if test="${status.error}">
<font color="#FF0000">
错误:
<c:forEach
items="${status.errorMessages}"
var="error">
<c:out value="${error}"/>
</c:forEach>
</font>
</c:if>
</spring:bind>
</td>
</tr>
</table>
<p>
<input type="submit" value="提交" name="B1">
<input type="reset" value="重置" name="B2">
</p>
</form>
</body>
</html>
页面起始部分指定了页面中引入的taglib和页面编码方式，实际开发时应该将其独立到一个单
独的jsp文件中，并在各个jsp文件中include便于统一维护。
页面中关键所在，也就是<spring:bind> 标记的使用:
<spring:bind path="command.*">
<font color="#FF0000">
<c:forEach
items="${status.errorMessages}"
var="error">
错误: <c:out value="${error}"/><br>
</c:forEach>
</font>
</spring:bind>
spring.bind标记通过path参数与CommandClass对象相绑定。之后我们就可以对绑定的
CommandClass对象的状态信息进行访问。上面的片断中，我们通过通配符“*”将当前
spring.bind语义与command对象的所有属性相绑定，用于集中的错误信息显示，对应最终提
示界面中的（蓝框标注部分）：
而在下面每个输入框下方，我们也提供了对应的错误提示，此时我们绑定到了特定的command
属性，如"command.username"。
这里的"command"是Spring中的默认CommandClass名称，用于引用当前页面对应的
CommandClass实例（当前语境下，也就是net.xiaxin.reqbean.RegisterInfo）。我们
也可以配置CommandClass引用名称，在Config.xml中RegisterAction配置中增加
CommandName配置，如下：
<bean id="RegisterAction"
class="net.xiaxin.action.RegisterAction">
<property name="commandName">
<value>RegisterInfo</value>
</property>
………
</bean>
之后我们就可以在页面中使用“RegisterInfo”替代现在的“command”对数据对象进
行引用。
（为了保持前后一致，下面我们仍旧以“command”为例）
绑定到username属性的<spring:bind>标记：
<spring:bind path="command.username">
<input
type="text"
value="<c:out value="${status.value}"/>"
name="<c:out value="${status.expression}"/>"
> 
（必须大于等于4个字符）
<br>
<c:if test="${status.error}">
<font color="#FF0000">
错误:
<c:forEach
items="${status.errorMessages}"
var="error">
<c:out value="${error}"/>
</c:forEach>
</font>
</c:if>
</spring:bind>
可以看到，<spring:bind>语义内，可以通过${status.*}访问对应的状态属性。
${status.*} 对应的实际是类
org.springframework.web.servlet.support.BindStatus
BindStatus类提供了与当前CommandClass对象绑定的状态信息，如：
${status.errorMessages}对应绑定对象属性的错误信息。
${status.expression}对应绑定对象属性的名称。
${status.value}对应绑定对象属性当前值。
具体描述可参见BindStatus类的Java Doc 文档。
下面是RegisterAction.java和成功返回界面RegisterSuccess.jsp，出于演示目的，这
两个文件都非常简单：
RegisterAction.java:
public class RegisterAction extends SimpleFormController {
protected ModelAndView onSubmit(Object cmd, BindException ex)
throws Exception {
Map rsMap = new HashMap();
rsMap.put("logininfo",cmd);
return new ModelAndView(this.getSuccessView(),rsMap);
}
}
RegisterSuccess.jsp:
<%@ taglib prefix="c" uri="http://java.sun.com/jstl/core_rt" %>
<%@ page pageEncoding="gb2312"
contentType="text/html;charset=gb2312"%>
<html>
<body>
<p align="center">
<c:out value="${logininfo.username}"/> 注册成功！
</p>
</body>
</html>
可以看到，结合JSTL Core Taglib和Spring Taglib，我们实现了一个拥有数据校验
功能的注册界面。界面显示、数据校验、逻辑处理三大模块被清晰隔离互不干扰，相对传统的
jsp解决方案。系统的可维护性得到了大大提升。
不过，我们还必须注意到，spring:bind标记对界面代码的侵入性较大，可以看到页面中
混杂了大量的Tag调用，这将对界面的修改和维护带来一定的困难。相对WebWork2而言，
Spring在这方面还是显得有些繁琐。
异常处理
Web应用中对于异常的处理方式与其他形式的应用并没有太大的不同――通过try/catch
语句针对不同的异常进行相应处理。
但是在具体实现中，由于异常层次、种类繁杂，我们往往很难在Servlet、JSP层妥善的处
理好所有异常情况，代码中大量的try/catch代码显得尤为凌乱。
我们通常面对下面两个主要问题：
1． 对异常实现集中式处理
典型情况：对数据库异常记录错误日志。一般处理方法无外两种，一是在各处数据库
访问代码的异常处理中，加上日志记录语句。二是将在数据访问代码中将异常向上抛
出，并在上层结构中进行集中的日志记录处理。
第一种处理方法失之繁琐、并且导致系统难以维护，假设后继需求为“对于数据库异
常，需记录日志，并发送通知消息告知系统管理员”。我们不得不对分散在系统中的各
处代码进行整改，工作量庞大。
第二种处理______方法实现了统一的异常处理，但如果缺乏设计，往往使得上层异常处理过
于复杂。
这里，我们需要的是一个设计清晰、成熟可靠的集中式异常处理方案。
2． 对未捕获异常的处理
对于Unchecked Exception而言，由于代码不强制捕获，往往被程序员所忽略，如果
运行期产生了Unchecked Exception，而代码中又没有进行相应的捕获和处理，则我
们可能不得不面对尴尬的500服务器内部错误提示页面。
这里，我们需要一个全面而有效的异常处理机制。
上面这两个问题，从技术角度上而言并算不上什么大的难点。套用一些短平快的设计模式，
我们也能进行处理并获得不错的效果。同时，目前大多数服务器也都支持在Web.xml中通过
<error-page>（Websphere/Weblogic）或者<error-code>(Tomcat)节点配置特定异常情
况的显示页面。
Spring MVC中提供了一个通用的异常处理机制，它提供了一个成熟的，简洁清晰的异常处
理方案。如果基于Spring MVC开发Web应用，那么利用这套现成的机制进行异常处理也更加自
然和有效。
Spring MVC中的异常处理：
以前面的注册系统为例，首先，在Dispatcher配置文件Config.xml中增加id为
“exceptionResolver”的bean定义：
<bean id="exceptionResolver"
class="org.springframework.web.servlet.handler.SimpleMappingEx
ceptionResolver">
<property name="defaultErrorView">
<value>failure</value>
</property>
<property name="exceptionMappings">
<props>
<prop key="java.sql.SQLException">showDBError</prop>
<prop key="java.lang.RuntimeException">showError</prop>
</props>
</property>
</bean>
通过SimpleMappingExceptionResolver我们可以将不同的异常映射到不同的jsp页
面（通过exceptionMappings属性的配置），同时我们也可以为所有的异常指定一个默认的异
常提示页面（通过defaultErrorView属性的配置），如果所抛出的异常在exceptionMappings
中没有对应的映射，则Spring将用此默认配置显示异常信息（注意这里配置的异常显示界面均
仅包括主文件名，至于文件路径和后缀已经在viewResolver中指定）。
一个典型的异常显示页面如下：
<html>
<head><title>Exception!</title></head>
<body>
<% Exception ex = (Exception)request.getAttribute("Exception"); %>
<H2>Exception: <% ex.getMessage();%></H2>
<P/>
<% ex.printStackTrace(new java.io.PrintWriter(out)); %>
</body>
</html>
如果SimpleMappingExceptionResolver无法满足异常处理的需要，我们可以针对
HandlerExceptionResolver接口实现自己异常处理类，这同样非常简单（只需要实现一个
resolveException方法）。
国际化支持
回忆之前章节中关于ApplicationContext 国际化支持的讨论，可以发现，如果在我们的Web
应用中结合ApplicationContext的国际化支持功能，就可以轻松实现Web应用在不同语言环境中
的切换，这对项目的可移植性（特别对于涉外项目）带来了极大的提升。
得益于Spring良好的整体规划，在Web应用中实现国际化支持非常简单。下面我们就围绕这
个专题进行一些探讨。
首先，在配置文件Config.xml中增加如下节点：
<bean id="messageSource"
class="org.springframework.context.support.ResourceBundleMessageSo
urce">
<property name="basename"><value>messages</value></property>
</bean>
非常简单，上面我们设定了一个messageSource资源，并指定资源文件基名为“messages”。
关于messageSource的介绍，请参见前面ApplicationContext国际化支持中的内容。
在/WEB-INF/classes/目录下，新建两个properties文件：
1) messages_zh_CN.properties
2) messages_en_US.properties
内容如下：
messages_zh_CN.properties
less4chars=用户名长度必须大于4个字符！
less6chars=密码长度必须大于6个字符!
notsame=两次密码输入不一致！
register_title=用户注册
username_label=用户名
password_label=密码
rep_pass_label=重复密码
error_msg=错误：
（注意messages_zh_CN.properties文件在部署时候须使用JDK工具native2ascii转码，
具体请参见ApplicationContext章节中国际化支持部分内容）
messages_en_US.properties:
less4chars=User name length must greater than 4 chars！
less6chars=Password length must greater than 6 chars!
notsame=Tow passwords are not consistent！
register_title=User Register
username_label=Username
password_label=Password
rep_pass_label=Repeat password
error_msg=Error：
经过以上配置， “用户注册”实例的输入数据验证类RegisterValidator就可以自动使用
message_*.properties中的配置数据，如：
errors.rejectValue("username",
"less4chars",
null,
"用户名长度必须大于等于4个字母！");
会自动从当前的messageSource中寻找"less4chars"对应的键值。如果当前Locale为
“en_US”2，则界面上的错误信息将显示为“User name length must greater than 4
chars！”。（rejectValue方法总是先从当前messageSource配置中寻找符合目前Locale
配置的信息，如果找不到，才会返回参数中的默认描述信息。具体请参见“输入验证与数据绑定”
一节中的描述）
错误信息已经完成了国际化，那么，界面上的提示信息如何处理？
我们需要对原本的register.jsp文件进行一些改造，通过<spring:message>标记将其中硬编
码的提示信息替换为动态Tag。如对于页面上方的“用户注册”标题，我们可做如下修改：
……
<tr>
<td height="27" width="408" colspan="2">
<p align="center">
<!--用户注册-->
<spring:message code="register_title"/>
</td>
</tr>
……
<spring:message>标记会自动从当前messageSource中根据code读取符合目前Locale
设置的配置数据。此时如果当前Locale为“en_US”，则原界面上方标题“用户注册”将显
示为messages_en_US.properties中配置的“User Register”。
Locale的切换
实际操作中，针对不同语言要求进行切换的方式大多有以下几种：
1． 根据语言种类，部署时手动替换*.properties文件
2． 根据当前系统Locale设置，自动匹配（如上例）
3． 根据客户浏览器语言设定，自动切换界面语种。
前两种部署方式依赖于部署时的设定和系统环境。第三种无疑最为灵活，这意味着系统一旦
部署，无需更改即可自动根据客户浏览器的语言设定自动切换语言种类。
Spring中目前提供了以下几种语言自动切换机制的实现（均实现了LocaleResolver接口）：
AcceptHeaderLocaleResolver
根据浏览器Http Header中的accept-language域判定(accept-language域中
一般包含了当前操作系统的语言设定，可通过HttpServletRequest.getLocale方法
获得此域的内容)。
SessionLocaleResolver
2Windows可以通过控制面板中的“区域和语言选项”快速切换系统Locale设定,Linux可通
过export LANG=zh_CN; LC_ALL=zh_CN.GBK 命令修改当前Locale。
根据用户本次会话过程中的语言设定决定语言种类（如：用户登录时选择语言种
类，则此次登录周期内统一使用此语言设定）。
CookieLocaleResolver
根据Cookie判定用户的语言设定（Cookie中保存着用户前一次的语言设定参
数）。
使用也非常简单，对于AcceptHeaderLocaleResolver而言，只需在配置文件
(Config.xml）中增加如下节点：
<bean id="localeResolver"
class="org.springframework.web.servlet.i18n.AcceptHeaderLocale
Resolver">
</bean>
之后，Spring就会根据客户端浏览器的Locale设定决定返回界面所采用的语言种类。可通
过AcceptHeaderLocaleResolver.resolveLocale方法获得当前语言设定。
resolveLocale和setLocale方法是LocaleResolver接口定义的方法，用于提供对
Locale信息的存取功能。而对于AcceptHeaderLocaleResolver，由于客户机操作系统的
Locale为只读，所以仅提供了resolveLocale方法。
SessionLocaleResolver的配置类似与上例类似：
<bean id="localeResolver"
class="org.springframework.web.servlet.i18n.SessionLocaleResol
ver">
</bean>
SessionLocaleResolver会自动在Session中维护一个名为
“org.springframework.web.servlet.i18n.SessionLocaleResolver.LOCALE”的
属性，其中保存了当前会话所用的语言设定信息，同时对外提供了resolveLocale和
setLocale两个方法用于当前Locale信息的存取操作。
CookieLocaleResolver配置则包含了三个属性，cookieName、cookiePath 和
cookieMaxAge，分别指定了用于保存Locale设定的Cookie的名称、路径和最大保存时间。
<bean id="localeResolver"
class="org.springframework.web.servlet.i18n.CookieLocaleResolver"
> 
<property name="cookieName">
<value>browserLocale</value>
</property>
<property name="cookiePath">
<value>mypath</value>
</property>
<property name="cookieMaxAge">
<value>999999</value>
</property>
</bean>
这几个属性并非必须配置，其默认值为分别为：
cookieName
org.springframework.web.servlet.i18n.CookieLocaleResolver.LOCALE
cookiePath
/
cookieMaxAge
Integer.MAX_VALUE [2147483647]
之后，我们即可通过：CookieLocaleResolver.setLocale (HttpServletRequest
request, HttpServletResponse response, Locale locale)方法保存Locale设定，
setLocale方法会自动根据设定在客户端浏览器创建Cookie并保存Locale信息。这样，下次
客户机浏览器登录的时候，系统就可以自动利用Cookie中保存的Locale信息为用户提供特定
语种的操作界面。
另外，Spring还提供了对语言切换事件的捕获机制（LocaleChangeInterceptor），由于
实际开发中使用较少，就不多做介绍，具体可参见Spring-Reference。
数据持久层
――在数据持久层的杰出贡献，可能是Spring最为闪亮的优点。
事务管理
对于J2EE 应用程序而言，事务的处理一般有两种模式：
1． 依赖特定事务资源的事务处理
这是应用开发中最常见的模式，即通过特定资源提供的事务机制进行事务管理。
如通过JDBC、JTA 的rollback、commit方法；Hibernate Transaction 的
rollback、commit方法等。这种方法大家已经相当熟悉。
2． 依赖容器的参数化事务管理
通过容器提供的集约式参数化事务机制，实现事务的外部管理，如EJB 中的事
务管理模式。
如，下面的EJB事务定义中，将SessionBean MySession的doService方
法定义为Required。
也就是说，当MySession.doServer 方法被某个线程调用时，容器将此线程
纳入事务管理容器，方法调用过程中如果发生异常，当前事务将被容器自动回
滚，如果方法正常结束，则容器将自动提交当前事务。
<container-transaction >
<method >
<ejb-name>MySession</ejb-name>
<method-intf>Remote</method-intf>
<method-name>doService</method-name>
<method-params>
<method-param>java.lang.String</method-param>
</method-params>
</method>
<trans-attribute>Required</trans-attribute>
</container-transaction>
容器管理的参数化事务为程序开发提供了相当的灵活性，同时因为将事务委
托给容器进行管理，应用逻辑中无需再编写事务代码，大大节省了代码量（特
别是针对需要同时操作多个事务资源的应用），从而提高了生产率。
然而，使用EJB 事务管理的代价相当高昂，撇开EJB 容器不菲的价格，EJB
的学习成本，部署、迁移、维护难度，以及容器本身带来的性能开销（这往往
意味着需要更高的硬件配置）都给我们带来了相当的困惑。此时事务管理所带
来的优势往往还不___________能抵消上面这些负面影响。
Spring事务管理能给我们带来什么?
对于传统的基于特定事务资源的事务处理而言（如基于JDBC 的数据库访问），
Spring并不会对其产生什么影响，我们照样可以成功编写并运行这样的代码。同时，
Spring还提供了一些辅助类可供我们选择使用，这些辅助类简化了传统的数据库操作
流程，在一定程度上节省了工作量，提高了编码效率。
对于依赖容器的参数化事务管理而言，Spring 则表现出了极大的价值。Spring
本身也是一个容器，只是相对EJB容器而言，Spring显得更为轻便小巧。我们无需付
出其他方面的代价，即可通过Spring实现基于容器的事务管理（本质上来讲，Spring
的事务管理是基于动态AOP）。
下面这段xml配置片断展示了Spring中的事务设定方式：
<beans>
<bean id="dataSource"
class="org.apache.commons.dbcp.BasicDataSource"
destroy-method="close">
<property name="driverClassName">
<value>org.gjt.mm.mysql.Driver</value>
</property>
<property name="url">
<value>jdbc:mysql://localhost/sample</value>
</property>
<property name="username">
<value>user</value>
</property>
<property name="password">
<value>mypass</value>
</property>
</bean>
<bean id="transactionManager"
class="org.springframework.jdbc.datasource.DataSourceTr
ansactionManager">
<property name="dataSource">
<ref local="dataSource" />
</property>
</bean>
<bean id="userDAO" class="net.xiaxin.dao.UserDAO">
<property name="dataSource">
<ref local="dataSource" />
</property>
</bean>
<bean id="userDAOProxy"
class="org.springframework.transaction.interceptor.Tran
sactionProxyFactoryBean">
<property name="transactionManager">
<ref bean="transactionManager" />
</property>
<property name="target">
<ref local="userDAO" />
</property>
<property name="transactionAttributes">
<props>
<prop key="insert*">PROPAGATION_REQUIRED</prop>
<prop key="get*">
PROPAGATION_REQUIRED,readOnly
</prop>
</props>
</property>
</bean>
</beans>
配置中包含了dataSource，transactionManager 等资源定义。这些资源都为
一个名为userDAOProxy 的TransactionProxyFactoryBean 服务， 而
userDAOProxy 则对包含实际数据逻辑的userDAO进行了事务性封装。
可以看到，在userDAOProxy 的"transactionAttributes"属性中，我们定义了
针对userDAO 的事务策略，即将所有名称以insert 开始的方法（如
UserDAO.insertUser方法）纳入事务管理范围。如果此方法中抛出异常，则Spring
将当前事务回滚，如果方法正常结束，则提交事务。
而对所有名称以get 开始的方法（如UserDAO.getUser 方法）则以只读的事务
处理机制进行处理。（设为只读型事务，可以使持久层尝试对数据操作进行优化，如对
于只读事务Hibernate将不执行flush操作，而某些数据库连接池和JDBC 驱动也对
只___________读型操作进行了特别优化。）
结合上面这段申明带来的感性认知，看看Spring 的事务管理机制与EJB 中事务
管理有何不同，或者有何优势。这里自然有许多方面可以比较，不过，笔者认为其中
最为关键的两点是：
1． Spring可以将任意Java Class 纳入事务管理
这里的UserDAO只是我们编写的一个普通Java Class，其中包含了一些
基本的数据应用逻辑。通过Spring，我们即可简单的实现事务的可配置
化。也就是说，我们可以随意为某个类的某个方法指定事务管理机制。
与之对比，如果使用EJB容器提供的事务管理功能，我们不得不按照EJB
规范编将UserDAO 进行改造，将其转换为一个标准的EJB。
2． Spring事务管理并不依赖特定的事务资源。
EJB 容器必须依赖于JTA 提供事务支持。而Spring 的事务管理则支持
JDBC、JTA 等多种事务资源。这为我们提供了更多的选择，从而也使得
我们的系统部署更加灵活。
对Spring事务管理机制进行简单分析之后，我们将结合持久层封装的具体事务应用机
制，对Spring中的事务管理进行更具实效的探讨。
持久层封装
JDBC
Spring对JDBC进行了良好的封装，通过提供相应的模板和辅助类，在相当程度上降低
了JDBC操作的复杂性。并且得益于Spring良好的隔离设计，JDBC封装类库可以脱离
Spring Context独立使用，也就是说，即使系统并没有采用Spring作为结构性框架，我们
也可以单独使用Spring的JDBC部分（spring-dao.jar）来改善我们的代码。
作为对比，首先让我们来看一段传统的JDBC代码：
Connection conn =null;
Statement stmt = null;
try {
conn = dataSource.getConnection();
stmt = con.createStatement();
stmt.executeUpdate("UPDATE user SET age = 18 WHERE id = 'erica'");
} finally {
if (stmt != null) {
try {
stmt.close();
} catch (SQLException ex) {
logger.warn("Exception in closing JDBC Statement", ex);
}
}
if (conn != null) {
try {
conn.close();
} catch (SQLException ex) {
logger.warn("Exception in closing JDBC Connection", ex);
}
}
}
类似上面的代码非常常见。为了执行一个SQL语句，我们必须编写22行代码，而其中
21行与应用逻辑并无关联，并且，这样的代码还会在系统其他地方（也许是每个需要数据
库访问的地方）重复出现。
于是，大___________家开始寻找一些设计模式以改进如此的设计，Template模式的应用是其中一
种典型的改进方案。
Spring的JDBC封装，很大一部分就是借助Template模式实现，它提供了一个优秀的
JDBC模板库，借助这个工具，我们可以简单有效的对传统的JDBC编码方式加以改进。
下面是借助Spring JDBC Template修改过的代码，这段代码完成了与上面代码相同
的功能。
JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource);
jdbcTemplate.update("UPDATE user SET age = 10 WHERE id = 'erica'");
可以看到，两行代码完成了上面需要19行代码实现的功能。所有冗余的代码都通过合理
的抽象汇集到了JdbcTemplate中。
无需感叹，借助Template模式，我们大致也能实现这样一个模板，不过，Spring的设计
者已经提前完成了这一步骤。org.springframework.jdbc.core.JdbcTemplate中包含了
这个模板实现的代码，经过Spring设计小组精心设计，这个实现可以算的上是模板应用的
典范。特别是回调（CallBack）的使用，使得整个模板结构清晰高效。值得一读。
Tips:实际开发中，可以将代码中硬编码的SQL语句作为Bean的一个String类型属性，借
助DI机制在配置文件中定义，从而实现SQL的参数化配置。
再对上面的例子进行一些改进，通过PrepareStatement执行update操作以避免SQL
Injection 漏洞3：
JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource);
jdbcTemplate
.update(
"UPDATE user SET age = ? WHERE id = ?",
new PreparedStatementSetter() {
public void setValues(PreparedStatementSetter ps)
throws SQLException {
ps.setInt(1, 18);
ps.setString(2, "erica");
}});
可以看到，上面引用了update方法的另一个版本，传入的参数有两个，第一个用于创建
PreparedStatement的SQL。第二个参数是为PreparedStatement设定参数的
PreparedStatementSetter。
第二个参数的使用方法比较独到，我们动态新建了一个PreparedStatementSetter类，
并实现了这个抽象类的setValues方法。之后将这个类的引用作为参数传递给update。
update接受参数之后，即可调用第二个参数提供的方法完成PreparedStatement的初始
化。
Spring JDBC Template中大量使用了这样的Callback机制，这带来了极强的灵活性和
扩展性。
上面演示了update方法的使用（同样的操作适用于update、insert、delete）。下面是
一个查询的示例。
final List userList = new ArrayList();
JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource);
jdbcTemplate
.query(
3 SQL Injection： SQL语句中直接引入参数值而导致的系统漏洞，具体请参见以下论文：
http://www.governmentsecurity.org/articles/SQLInjectionModesofAttackDefenceandWhyItMatters.php
"SELECT name, sex, address FROM user WHERE age > 18",
new RowCallbackHandler() {
public void processRow(ResultSet rs) throws SQLException {
User user = new User();
user.setId(rs.getString("name"));
user.setSex(rs.getString("sex"));
user.setAddress(rs.getString("address"));
userList.add(product);
}});
这里传入query方法的有两个参数，第一个是Select查询语句，第二个是一个
RowCallbackHandler实例，我们通过RowCallbackHandler对Select语句得到的每行记
录进行解析，并为其创建一个User数据对象。实现了手动的OR映射。
此外，我们还可以通过JdbcTemplate.call方法调用存储过程。
query、update方法还有其他很多不同参数版本的实现，具体调用方法请参见Spring
JavaDoc。
JdbcTemplate与事务
上例中的JdbcTemplate操作采用的是JDBC默认的AutoCommit模式，也就是说我们还
无法保证数据操作的原子性（要么全部生效，要么全部无效），如：
JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource);
jdbcTemplate.update("UPDATE user SET age = 10 WHERE id = 'erica'");
jdbcTemplate.update("UPDATE user SET age = age+1 WHERE id = 'erica'");
由于采用了AutoCommit模式，第一个update操作完成之后被自动提交，数据库
中”erica”对应的记录已经被更新，如果第二个操作失败，我们无法使得整个事务回滚到最
初状态。对于这个例子也许无关紧要，但是对于一个金融帐务系统而言，这样的问题将导致
致命错误。
为了实现数据操作的原子性，我们需要在程序中引入事务逻辑，在JdbcTemplate中引入
事务机制，在Spring中有两种方式：
1． 代码控制的事务管理
2． 参数化配置的事务管理
下面就这两种方式进行介绍。
代码控制的事务管理
首先，进行以下配置，假设配置文件为（Application-Context.xml）：
<beans>
<bean id="dataSource"
class="org.apache.commons.dbcp.BasicDataSource"
destroy-method="close">
<property name="driverClassName">
<value>net.sourceforge.jtds.jdbc.Driver</value>
</property>
<property name="url">
<value>jdbc:jtds:sqlserver://127.0.0.1:1433/Sample</value>
</property>
<property name="username">
<value>test</value>
</property>
<property name="password">
<value>changeit</value>
</property>
</bean>
<bean id="transactionManager"
class="org.springframework.jdbc.datasource.DataSourceTransac
tionManager">
<property name="dataSource">
<ref local="dataSource" />
</property>
</bean>
<bean id="userDAO" class="net.xiaxin.dao.UserDAO">
<property name="dataSource">
<ref local="dataSource" />
</property>
<property name="transactionManager">
<ref local="transactionManager" />
</property>
</bean>
</beans>
配置中包含了三个节点:
dataSource
这里我们采用了apache dhcp组件提供的DataSource实现，并为其配置了
JDBC驱动、数据库URL、用户名和密码等参数。
transactionManager
针对JDBC DataSource类型的数据源，我们选用了
DataSourceTransactionManager
作为事务管理组件。
如果需要___________使用基于容器的数据源（JNDI），我们可以采用如下配置：
<bean id="dataSource"
class="org.springframework.jndi.JndiObjectFactoryBean">
<property name="jndiName">
<value>jdbc/sample</value>
</property>
</bean>
<bean id="transactionManager"
class="org.springframework.transaction.jta.JtaTrans
actionManager"
/>
userDAO
申明了一个UserDAO Bean，并为其指定了dataSource和
transactionManger资源。
测试库表非常简单：
UserDAO对应的代码如下：
public class UserDAO {
private DataSource dataSource;
private PlatformTransactionManager transactionManager;
public PlatformTransactionManager getTransactionManager() {
return transactionManager;
}
public void setTransactionManager(PlatformTransactionManager
transactionManager) {
this.transactionManager = transactionManager;
}
public DataSource getDataSource() {
return dataSource;
}
public void setDataSource(DataSource dataSource) {
this.dataSource = dataSource;
}
public void insertUser() {
TransactionTemplate tt =
new TransactionTemplate(getTransactionManager());
tt.execute(new TransactionCallback() {
public Object doInTransaction(TransactionStatus status) {
JdbcTemplate jt = new JdbcTemplate(getDataSource());
jt.update(
"insert into users (username) values ('xiaxin');");
jt.update(
"insert into users (id,username) values(2,
'erica');");
return null;
}
});
}
}
可以看到，在insertUser方法中，我们引入了一个新的模板类：
org.springframework.transaction.support.TransactionTemplate。
TransactionTemplate封装了事务管理的功能，包括异常时的事务回滚，以及操作成
功后的事务提交。和JdbcTemplate一样，它使得我们无需在琐碎的try/catch/finally代码
中徘徊。
在doInTransaction中进行的操作，如果抛出未捕获异常将被自动回滚，如果成功执行，
则将被自动提交。
这里我们故意制造了一些异常来观察数据库操作是否回滚（通过在第二条语句中更新自
增ID字段故意触发一个异常）：
编写一个简单的TestCase来观察实际效果：
InputStream is = new FileInputStream("Application-Context.xml");
XmlBeanFactory factory = new XmlBeanFactory(is);
UserDAO userDAO = (UserDAO) factory.getBean("userDAO");
userDAO.insertUser();
相信大家多少觉得上面的代码有点凌乱，Callback类的编写似乎也有悖于日常的编程
习惯（虽然笔者觉得这一方法比较有趣，因为它巧妙的解决了笔者在早期自行开发数据访问
模板中曾经遇到的问题）。
如何进一步避免上面这些问题？Spring 的容器事务管理机制在这里即体现出其强大
的能量。
参数化配置的事务管理
在上面的Application-Context.xml增加一个事务代理（UserDAOProxy）配置，同时，
由于事务由容器管理，UserDAO不再需要TransactionManager设定，将其移除：
<bean id="UserDAOProxy"
class="org.springframework.transaction.interceptor.Transac
tionProxyFactoryBean">
<property name="transactionManager">
<ref bean="transactionManager" />
</property>
<property name="target">
<ref local="userDAO" />
</property>
<property name="transactionAttributes">
<props>
<prop key="insert*">PROPAGATION_REQUIRED</prop>
<prop key="*">PROPAGATION_REQUIRED,readOnly</prop>
</props>
</property>
</bean>
<bean id="userDAO" class="net.xiaxin.dao.UserDAO">
<property name="dataSource">
<ref local="dataSource" />
</property>
</bean>
上面的配置中，UserDAOProxy节点配置了一个针对userDAO bean的事务代理（由
target属性指定）。
通过transactionAttributes属性，我们指定了事务的管理策略，即对所有以insert
开头的方法进行事务管理，如果被管理方法抛出异常，则自动回滚方法中的事务，如果成功
执行，则在方法完成之后进行事务提交。另一方面，对于其他方法（通过通配符*表示），
则进行只读事务管理，以获得更好的性能。
与之对应，UserDAO.insertUser的代码修改如下：
public void insertUser(RegisterInfo regInfo) {
JdbcTemplate jt = new JdbcTemplate(getDataSource());
jt.update("insert into users (username) values ('xiaxin');");
jt.update("insert into users (id,username) values (2,'erica');");
}
测试代码修改如下：
InputStream is = new FileInputStream("Application-Context.xml");
XmlBeanFactory factory = new XmlBeanFactory(is);
//注意这里须通过代理Bean"userDAOProxy"获得引用，而不是直接getBean(“userDAO”)
//此外这里还存在一个有关强制转型的潜在问题，请参见Hibernate in Spring一节后
//关于强制转型的补充描述。
UserDAO userDAO = (UserDAO) factory.getBean("userDAOProxy");
userDAO.insertUser();
可以看到，insertUser变得非常简洁。数据逻辑清晰可见，对比前面代码控制的事务
管理，以及传统的JDBC操作，相信大家会有一些霍然开朗的感觉。
细心的读者会说，这只不过将代码转移到了配置文件，并没有减少太多的工作量。这点
区别也许并不重要，从应用维护的角度而言，配置化的事务管理显然更具优势。何况，实际
开发中，如果前期设计细致，方法的事务特性确定之后一般不会发生大的变动，之后频繁的
维护过程中，我们只需面对代码中的数据逻辑即可。
上面我们结合JdbcTemplate介绍了Spring中的模板操作以及事务管理机制。Spring
作为一个开放式的应用开发平台。同时也针对其他组件提供了良好的支持。在持久层，
Spring提供面向了Hibernate、ibatis和JDO的模板实现，同样，这些实现也为我们的开发
提供了强有力的支持。
下面我们就hibernate、ibatis这两种主流持久层框架在Spring中的使用进行介绍。至
于JDO，由于实际开发中使用并不广泛（实际上笔者觉得JDO前景堪忧），这里也就不重点
介绍，有兴趣的读者可参见Spring-Reference中的相关章节。
Hibernate in Spring
Hibernate在开源的持久层框架中无疑是近期最为鲜亮的角色，其作者甚至被邀请加入
新版EJB设计工作之中，足见Hibernate设计的精彩贴切。关于Hibernate的使用，在笔者
的另外一篇文档中进行了探讨：
《Hibernate开发指南》http://www.xiaxin.net/Hibernate_DEV_GUIDE.rar。
下面主要就Hibernate在Spring中的应用加以介绍，关于Hibernate本身就不多加描
述。
另外考虑到Spring对容器事务的良好支持，笔者建议在基于Spring Framework的应
用开发中，尽量使用容器管理事务，以获得数据逻辑代码的最佳可读性。下面的介绍中，将
略过代码控制的事务管理部分，而将重点放在参数化的容器事务管理应用。代码级事务管理
实现原理与上面JdbcTemplate中基本一致，感兴趣的读者可以参见Spring-Reference中
的相关内容。
出于简洁，我们还是沿用上面的示例。首先，针对Hibernate，我们需要进行如下配置：
Hibernate-Context.xml:
<beans>
<bean id="dataSource"
class="org.apache.commons.dbcp.BasicDataSource"
destroy-method="close">
<property name="driverClassName">
<value>net.sourceforge.jtds.jdbc.Driver</value>
</property>
<property name="url">
<value>jdbc:jtds:sqlserver://127.0.0.1:1433/Sample</value>
</property>
<property name="username">
<value>test</value>
</property>
<property name="password">
<value>changeit</value>
</property>
</bean>
<bean id="sessionFactory"
class="org.springframework.orm.hibernate.LocalSessionFactoryBean"
> 
<property name="dataSource">
<ref local="dataSource" />
</property>
<property name="mappingResources">
<list>
<value>net/xiaxin/dao/entity/User.hbm.xml</value>
</list>
</property>
<property name="hibernateProperties">
<props>
<prop key="hibernate.dialect">
net.sf.hibernate.dialect.SQLServerDialect
</prop>
<prop key="hibernate.show_sql">
true
</prop>
</props>
</property>
</bean>
<bean id="transactionManager"
class="org.springframework.orm.hibernate.HibernateTransactionMana
ger">
<property name="sessionFactory">
<ref local="sessionFactory" />
</property>
</bean>
<bean id="userDAO" class="net.xiaxin.dao.UserDAO">
<property name="sessionFactory">
<ref local="sessionFactory" />
</property>
</bean>
<bean id="userDAOProxy"
class="org.springframework.transaction.interceptor.TransactionPro
xyFactoryBean">
<property name="transactionManager">
<ref bean="transactionManager" />
</property>
<property name="target">
<ref local="userDAO" />
</property>
<property name="transactionAttributes">
<props>
<prop key="insert*">PROPAGATION_REQUIRED</prop>
<prop key="get*">PROPAGATION_REQUIRED,readOnly</prop>
</props>
</property>
</bean>
</beans>
与上面JDBC中的配置相对比，区别主要在于：
1． SessionFactory的引入
Hibernate中通过SessionFactory创建和维护Session。Spring对
SessionFactory的配置也进行了整合，无需再通过Hibernate.cfg.xml对
SessionFactory进行设定。
SessionFactory节点的mappingResources属性包含了映射文件的路径，list
节点下可配置多个映射文件。
hibernateProperties节点则容纳了所有的属性配置。
可以对应传统的Hibernate.cfg.xml文件结构对这里的SessionFactory配置
进行解读。
2． 采用面向Hibernate的TransactionManager实现：
org.springframework.orm.hibernate.HibernateTransactionManag
er
可以看到，对于事务管理配置，基本与上一章节中相同。
对应刚才的Users表，建立如下映射类：
User.java:
/**
* @hibernate.class table="users"
*/
public class User {
public Integer id;
public String username;
public String password;
/**
* @hibernate.id
* column="id"
* type="java.lang.Integer"
* generator-class="native"
*/
public Integer getId() {
return id;
 
 
}
public void setId(Integer id) {
this.id = id;
}
/**
* @hibernate.property column="password" length="50"
*/
public String getPassword() {
return password;
}
public void setPassword(String password) {
this.password = password;
}
/**
* @hibernate.property column="username" length="50"
*/
public String getUsername() {
return username;
}
public void setUsername(String username) {
this.username = username;
}
}
上面的代码中，通过xdoclet指定了类/表；属性/字段的映射关系，通过xdoclet ant
task 我们可以根据代码生成对应的user.hbm.xml文件。具体细节请参见《hibernate开
发指南》一文。
下面是生成的user.hbm.xml：
<hibernate-mapping>
<class
name="net.xiaxin.dao.entity.User"
table="users"
dynamic-update="false"
dynamic-insert="false"
> 
<id
name="id"
column="id"
type="java.lang.Integer"
> 
<generator class="native">
</generator>
</id>
<property
name="password"
type="java.lang.String"
update="true"
insert="true"
access="property"
column="password"
length="50"
/>
<property
name="username"
type="java.lang.String"
update="true"
insert="true"
access="property"
column="username"
length="50"
/>
</class>
</hibernate-mapping>
UserDAO.java:
public class UserDAO extends HibernateDaoSupport implements IUserDAO
{
public void insertUser(User user) {
getHibernateTemplate().saveOrUpdate(user);
}
}
看到这段代码想必会有点诧异，似乎太简单了一点……，不过这已经足够。短短一行
代码我们已经实现了与上一章中示例相同的功能，这也正体现了Spring+Hibernate
的威力所在。
上面的UserDAO实现了自定义的IUserDAO接口（这里的IUserDAO接口仅包含
insertUser方法的定义，不过除此之外，它还有另一层含义，见下面的代码测试部分），
并扩展了抽象类：
HibernateDaoSupport
HibernateSupport实现了HibernateTemplate和SessionFactory实例的关联。
与JdbcTemplate类似，HibernateTemplate对Hibernate Session操作进行了封
装，而HibernateTemplate.execute方法则是一封装机制的核心，感兴趣的读者可以
研究一下其实现机制。
借助HibernateTemplate我们可以脱离每次数据操作必须首先获得Session实例、启
动事务、提交/回滚事务以及烦杂的try/catch/finally的繁琐操作。从而获得以上代码
中精干集中的逻辑呈现效果。
对比下面这段实现了同样功能的Hibernate原生代码，想必更有体会：
Session session
try {
Configuration config = new Configuration().configure();
SessionFactory sessionFactory =
config.buildSessionFactory();
session = sessionFactory.openSession();
Transaction tx = session.beginTransaction();
User user = new User();
user.setName("erica");
user.setPassword("mypass");
session.save(user);
tx.commit();
} catch (HibernateException e) {
e.printStackTrace();
tx.rollback();
}finally{
session.close();
}
测试代码：
InputStream is = new FileInputStream("Hibernate-Context.xml");
XmlBeanFactory factory = new XmlBeanFactory(is);
IUserDAO userDAO = (IUserDAO)factory.getBean("userDAOProxy");
User user = new User();
user.setUsername("erica");
user.setPassword("mypass");
userDAO.insertUser(user);
这段代码似乎并没有什么特殊，但有一个细微之处：
IUserDAO userDAO = (IUserDAO)factory.getBean("userDAOProxy");
这里并没有直接用UserDAO对获得的Bean实例进行强制转型。这与上面
JdbcTemplate的测试代码不同。并非完全出自设计上的考虑，这里情况有些特殊，我们可
以尝试一下用UserDAO类对bean实例进行强制转型，不过将得到一个ClassCastException，程序异常中止。
为什么会___________出现这样的问题？是不是只有在使用Hibernate才会出现这样的问题？事实并非如此，如果对上面基于JdbcTempate的UserDAO进行改造，使之实现IUserDAO接口，
同样的问题也将会出现。IUserDAO接口本身非常简单（仅包含一个insertUser方法的定
义），显然也不是导致异常的原因所在。
原因在于Spring的AOP实现机制，前面曾经提及，Spring中的事务管理实际上是基于
动态AOP机制实现，为了实现动态AOP，Spring在默认情况下会使用Java Dynamic
Proxy，但是，Dynamic Proxy要求其代理的对象必须实现一个接口，该接口定义了准备
进行代理的方法。而对于没有实现任何接口的Java Class，需要采用其他方式，Spring通
过CGLib4实现这一功能。
当UserDAO没有实现任何接口时（如JdbcTemplate示例中）。Spring通过CGLib对
UserDAO进行代理，此时getBean返回的仍然是一个UserDAO实例，可以通过UserDAO
对其强制转型。而当UserDAO实现了IUserDAO接口之后，Spring将通过Java Dynamic
Proxy机制实现代理功能，此时返回的Bean，是通过
java.lang.reflect.Proxy.newProxyInstance方法创建的经过动态代理的Bean实例，这
个实例的类结构已经不同于原始的UserDAO类，因此无法通过UserDAO强制转型。
由于此问题牵涉到较为底层的代理机制实现原理，下面的AOP章节中我们再进行详细
探讨。
实际开发中，应该面向接口编程，通过接口来调用Bean提供的服务。
4 CGLib可以在运行期对Class行为进行修改。由于其功能强大，性能出众，常常被作为Java Dynamic Proxy
之外的动态Proxy模式的实现基础。在Spring、Hibernate中都用到了CGLib类库。
ibatis in Spring
与Hibernate类似，ibatis也是一个ORM解决方案，不同的是两者各有侧重。
Hibernate提供了Java对象到数据库表之间的直接映射，开发者无需直接涉及数据库
操作的实现细节，实现了一站式的ORM解决方案。
而ibatis则采取了另一种方式，即提供Java对象到SQL（面向参数和结果集）的映射实
现，实际的数据库操作需要通过手动编写SQL实现。
在Java ORM世界中，很幸运，我们拥有了这两个互补的解决方案，从而使得开发过程
更加轻松自如。
与Hibernate in Spring一节类似，这里我们重点探讨Spring框架下的ibatis应用，特
别是在容器事务管理模式下的ibatis应用开发。
针对ibatis，Spring配置文件如下：
Ibatis-Context.xml:
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE beans PUBLIC "-//SPRING//DTD BEAN//EN"
"http://www.springframework.org/dtd/spring-beans.dtd">
<beans>
<bean id="dataSource"
class="org.apache.commons.dbcp.BasicDataSource"
destroy-method="close">
<property name="driverClassName">
<value>net.sourceforge.jtds.jdbc.Driver</value>
</property>
<property name="url">
<value>jdbc:jtds:sqlserver://127.0.0.1:1433/Sample</value>
</property>
<property name="username">
<value>test</value>
</property>
<property name="password">
<value>changeit</value>
</property>
</bean>
<bean id="sqlMapClient"
class="org.springframework.orm.ibatis.SqlMapClientFactoryBean">
 
 
<property name="configLocation">
<value>SqlMapConfig.xml</value>
</property>
</bean>
<bean id="transactionManager"
class="org.springframework.jdbc.datasource.DataSourceTransactio
nManager">
<property name="dataSource"><ref
local="dataSource"/></property>
</bean>
<bean id="userDAO" class="net.xiaxin.dao.UserDAO">
<property name="dataSource">
<ref local="dataSource" />
</property>
<property name="sqlMapClient">
<ref local="sqlMapClient" />
</property>
</bean>
<bean id="userDAOProxy"
class="org.springframework.transaction.interceptor.TransactionPro
xyFactoryBean">
<property name="transactionManager">
<ref bean="transactionManager" />
</property>
<property name="target">
<ref local="userDAO" />
</property>
<property name="transactionAttributes">
<props>
<prop key="insert*">PROPAGATION_REQUIRED</prop>
<prop key="get*">PROPAGATION_REQUIRED,readOnly</prop>
</props>
</property>
</bean>
</beans>
对比之前的JDBC和Hibernate配置，可以看到：
1． sqlMapClient节点类似SessionFactory之与Hibernate，这里我们引入了针对ibatis SqlMap的SqlMapClientFactoryBean配置。SqlMapClient对于ibatis的意义类似于Session与Hibernate以及Connection与JDBC，这里的sqlMapClient节点实际上配置了一个sqlMapClient的创建工厂类。configLocation属性配置了ibatis映射文件的名称。
2． transactionManager节点这里我们的transactionManager配置与之前JDBC示例中相同，都采用了DataSourceTransactionManager，这与Hibernate有些差异。
3． userDAO节点对应的，UserDAO需要配置两个属性，sqlMapClient和DataSource，
sqlMapClient将从指定的DataSource中获取数据库连接。其他配置基本上与JDBC示例中相同，这里就不加赘述。本例中Ibatis映射文件非常简单：sqlMapConfig.xml:
<sqlMapConfig>
<sqlMap resource="net/xiaxin/dao/entity/user.xml"/>
</sqlMapConfig>
net/xiaxin/dao/entity/user.xml
<sqlMap namespace="User">
<typeAlias alias="user" type="net.xiaxin.dao.entity.User" />
<insert id="insertUser" parameterClass="user">
INSERT INTO users ( username, password) VALUES ( #username#,
#password# )
</insert>
</sqlMap>
与Hibernate示例中类似，UserDAO.java同样简洁：
public class UserDAO extends SqlMapClientDaoSupport implements
IUserDAO {
public void insertUser(User user) {
getSqlMapClientTemplate().update("insertUser", user);
}
}
SqlMapClientDaoSupport（如果使用ibatis 1.x版本，对应支持类是
SqlMapDaoSupport）是Spring中面向ibatis的辅助类，它负责调度DataSource、
 
 
SqlMapClientTemplate（对应ibatis 1.x版本是SqlMapTemplate）完成ibatis操作，
而DAO则通过对此类进行扩展获得上述功能。上面配置文件中针对UserDAO的属性设
置部分，其中的属性也是继承自于这个基类。
SqlMapClientTemplate对传统SqlMapClient调用模式进行了封装，简化了上层访问
代码。
User.java沿用之前Hibernate示例中的代码。
测试代码也几乎相同：
InputStream is = new FileInputStream("Ibatis-Context.xml");
XmlBeanFactory factory = new XmlBeanFactory(is);
IUserDAO userdao = (IUserDAO)factory.getBean("userDAOProxy");
User user = new User();
user.setUsername("Sofia");
user.setPassword("mypass");
userdao.insertUser(user);
 Copyright ©2011 lyt. All Rights Reserved.
 
 
 
 
java核心技术学习
自定义属性编辑器

//日期必须使用自定义的属性编辑器，否则会出问题
        <property name="dateValue">
            <value>2009/11/30</value>
        </property>
/**
 * java.util.date属性编辑器
 *
 */
//继承PropertyEditorSupport：java.beans.PropertyEditorSupport;
 
public class UtilDatePropertyEditor extends PropertyEditorSupport {
  //日期的格式，提供一个setter方法，在spring中注入，这样这个属性也可以变化
       private String format = "yyyy-MM-dd";
    //覆写setAsText
       public void setAsText(String text) throws IllegalArgumentException {
              System.out
                            .println("--------UtilDatePropertyEditor.setAsText()---text---="
                                          + text);
              SimpleDateFormat sFormat = new SimpleDateFormat(format);
              try {
                     Date date = sFormat.parse(text);
                     this.setValue(date);
              } catch (ParseException e) {
                     e.printStackTrace();
              }
       }
   
       public void setFormat(String format) {
              this.format = format;
       }
}
<!-- 定义属性编辑器 -->
//id是任意定义的值,class必须写，而且是固定的，把我们的自已定义的编辑器注册给customEditors
// customEditors是CustomEditorConfigurer类的一个map属性
    <bean id="customEditorConfigurer" class="org.springframework.beans.factory.config.CustomEditorConfigurer">
        <property name="customEditors">
            <map>
                <entry key="java.util.Date">
                    //使用内置bean的方式注册，不用配id属性
                    <bean class="com.bjsxt.spring.UtilDatePropertyEditor">
                        //注入format属性
                        <property name="format" value="yyyy/MM/dd"/>
                    </bean>
                </entry>
            </map>
        </property>
    </bean>
 Copyright ©2011 lyt. All Rights Reserved.
 
 
 
java核心技术学习
压缩包结构2.0


1. Spring压缩包目录说明 

aspectj目录下是在Spring框架下使用aspectj的源代码和测试程序文件。 
Aspectj是java最早的提供AOP的应用框架。 
dist 目录下是Spring 的发布包，关于发布包下面会详细进行说明。 
docs 目录下是相关的文档，包括有Spring api 的javadoc、reference 参考指南,Spring的标签库使用文件及Spring MVC 的MVC-step-by-step 讲解与示例。。 
lib 目录下是Spring 所依赖的第三方开源包。 
mock 目录下是Spring 辅助应用测试的Mock 源程序。 
samples 目录下是Spring 的示例源程序及简单的webapp 示例框架的示例配置，值得好好学习的有jpetstore 及petclinic，当然其它的countries、imagedb、tiles-example 也可以好好参考一下。 
src 目录下是Spring 的源程序。 
test 目录下Spring 的单元测试源程序。 
tiger 目录下是针对在Spring框架中使用java 1.5的源程序及测试程序。Tiger是jdk 1.5版本的开发代号。 
根目录的其他文件为编译和说明文件。 
2.Spring 包结构说明 
spring.jar 是包含有完整发布模块的单个jar 包。但是不包括mock.jar, aspects.jar, spring-portlet.jar, and spring-hibernate2.jar。 
spring-src.zip就是所有的源代码压缩包。 
除了spring.jar 文件，Spring 还包括有其它21 个独立的jar 包，各自包含着对应的Spring组件，用户可以根据自己的需要来选择组合自己的jar 包，而不必引入整个spring.jar 的所有类文件。 
spring-core.jar 
这个jar 文件包含Spring 框架基本的核心工具类。Spring 其它组件要都要使用到这个包里的类，是其它组件的基本核心，当然你也可以在自己的应用系统中使用这些工具类。 
外部依赖Commons Logging， (Log4J)。 
spring-beans.jar 
这个jar 文件是所有应用都要用到的，它包含访问配置文件、创建和管理bean 以及进行Inversion of Control / Dependency Injection（IoC/DI）操作相关的所有类。如果应用只需基本的IoC/DI 支持，引入spring-core.jar 及spring-beans.jar 文件就可以了。 
外部依赖spring-core，(CGLIB)。 
spring-aop.jar 
这个jar 文件包含在应用中使用Spring 的AOP 特性时所需的类和源码级元数据支持。使用基于AOP 的Spring特性，如声明型事务管理（Declarative Transaction Management），也要在应用里包含这个jar包。 
外部依赖spring-core， (spring-beans，AOP Alliance， CGLIB，Commons Attributes)。 
spring-context.jar 
这个jar 文件为Spring 核心提供了大量扩展。可以找到使用Spring ApplicationContext特性时所需的全部类，JDNI 所需的全部类，instrumentation组件以及校验Validation 方面的相关类。外部依赖spring-beans, (spring-aop)。 
spring-dao.jar 
这个jar 文件包含Spring DAO、Spring Transaction 进行数据访问的所有类。为了使用声明型事务支持，还需在自己的应用里包含spring-aop.jar。 
外部依赖spring-core，(spring-aop， spring-context， JTA API)。 
spring-jdbc.jar 
这个jar 文件包含对Spring 对JDBC 数据访问进行封装的所有类。 
外部依赖spring-beans，spring-dao。 
spring-support.jar 
这个jar 文件包含支持UI模版（Velocity，FreeMarker，JasperReports），邮件服务，脚本服务(JRuby)，缓存Cache（EHCache），任务计划Scheduling（uartz）方面的类。 
外部依赖spring-context, (spring-jdbc, Velocity, FreeMarker, JasperReports, BSH, Groovy, JRuby, Quartz, EHCache) 
spring-web.jar 
这个jar 文件包含Web 应用开发时，用到Spring 框架时所需的核心类，包括自动载入Web Application Context 特性的类、Struts 与JSF 集成类、文件上传的支持类、Filter 类和大量工具辅助类。外部依赖spring-context, Servlet API, (JSP API, JSTL, Commons FileUpload, COS)。 
spring-webmvc.jar 
这个jar 文件包含Spring MVC 框架相关的所有类。包括框架的Servlets，Web MVC框架，控制器和视图支持。当然，如果你的应用使用了独立的MVC 框架，则无需这个JAR 文件里的任何类。外部依赖spring-web, (spring-support，Tiles，iText，POI)。 
spring-portlet.jar 
spring自己实现的一个类似Spring MVC的框架。包括一个MVC框架和控制器。 
外部依赖spring-web， Portlet API，(spring-webmvc)。 
spring-struts.jar 
Struts框架支持，可以更方便更容易的集成Struts框架。外部依赖spring-web，Struts。 
spring-remoting.jar 
这个jar 文件包含支持EJB、远程调用Remoting（RMI、Hessian、Burlap、Http Invoker、JAX-RPC）方面的类。外部依赖spring-aop， (spring-context，spring-web，Hessian，Burlap，JAX-RPC，EJB API)。 
spring-jmx.jar 
这个jar包提供了对JMX 1.0/1.2的支持类。外部依赖spring-beans，spring-aop， JMX API。 
spring-jms.jar 
这个jar包提供了对JMS 1.0.2/1.1的支持类。外部依赖spring-beans，spring-dao，JMS API。 
spring-jca.jar 
对JCA 1.0的支持。外部依赖spring-beans，spring-dao， JCA API。 
spring-jdo.jar 
对JDO 1.0/2.0的支持。外部依赖spring-jdbc， JDO API， (spring-web)。 
spring-jpa.jar对JPA 1.0的支持。外部依赖spring-jdbc， JPA API， (spring-web)。 
spring-hibernate2.jar 
对Hibernate 2.1的支持，已经不建议使用。外部依赖spring-jdbc，Hibernate2，(spring-web)。 
spring-hibernate3.jar 
对Hibernate 3.0/3.1/3.2的支持。外部依赖spring-jdbc，Hibernate3，(spring-web)。 
spring-toplink.jar对TopLink框架的支持。外部依赖spring-jdbc，TopLink。 
spring-ibatis.jar 
对iBATIS SQL Maps的支持。外部依赖spring-jdbc，iBATIS SQL Maps。 
另外的两个包。 
spring-mock.jar 
这个jar 文件包含Spring 一整套mock 类来辅助应用的测试。Spring 测试套件使用了其中大量mock 类，这样测试就更加简单。模拟HttpServletRequest 和HttpServletResponse 类在Web 应用单元测试是很方便的。并且提供了对JUnit的支持。外部依赖spring-core。 
spring-aspects.jar 
提供对AspectJ的支持，以便可以方便的将面向方面的功能集成进IDE中，比如Eclipse AJDT。 
3．外部依赖。WEAVER JARS (dist/weavers)说明 
spring-agent.jar 
Spring的InstrumentationSavingAgent (为InstrumentationLoadTimeWeaver)，一个设备代理包，可以参考JDK1.5的Instrumentation功能获得更 多信息。外部依赖none (for use at JVM startup: "-javaagent:spring-agent.jar")。 
spring-tomcat-weaver.jar 
扩展Tomcat的ClassLoader，使其可以使用instrumentation（设备）类。外部依赖none (for deployment into Tomcat's "server/lib" directory)。
 Copyright ©2011 lyt. All Rights Reserved.
 
 
 
 
java核心技术学习
压缩包结构3.0

spring.jar是包含有完整发布的单个jar包，spring.jar中包含除了spring-mock.jar里所包含的内容外其它所有jar包的内容，因为只有在开发环境下才会用到spring-mock.jar来进行辅助测试，正式应用系统中是用不得这些类的。
 
　　除了spring.jar文件，Spring还包括有其它13个独立的jar包，各自包含着对应的Spring组件，用户可以根据自己的需要来选择组合自己的jar包，而不必引入整个spring.jar的所有类文件。
 
(1)   spring-core.jar
 
  这个jar文件包含Spring框架基本的核心工具类，Spring其它组件要都要使用到这个包里的类，是其它组件的基本核心，当然你也可以在自己的应用系统中使用这些工具类。
 
(2) spring-beans.jar
     
        这个jar文件是所有应用都要用到的，它包含访问配置文件、创建和管理bean以及进行Inversion of Control / Dependency Injection（IoC/DI）操作相关的所有类。如果应用只需基本的IoC/DI支持，引入spring-core.jar及spring- beans.jar文件就可以了。
 
(3) spring-aop.jar
     
        这个jar文件包含在应用中使用Spring的AOP特性时所需的类。使用基于AOP的Spring特性，如声明型事务管理（Declarative Transaction Management），也要在应用里包含这个jar包。
 
(4) spring-context.jar
 
这个jar文件为Spring核心提供了大量扩展。可以找到使用Spring ApplicationContext特性时所需的全部类，JDNI所需的全部类，UI方面的用来与模板（Templating）引擎如 Velocity、FreeMarker、JasperReports集成的类，以及校验Validation方面的相关类。
 
(5) spring-dao.jar
 
　　这个jar文件包含Spring DAO、Spring Transaction进行数据访问的所有类。为了使用声明型事务支持，还需在自己的应用里包含spring-aop.jar。
 
(6) spring-hibernate.jar
 
　　这个jar文件包含Spring对Hibernate 2及Hibernate 3进行封装的所有类。
 
(7) spring-jdbc.jar
 
　　这个jar文件包含对Spring对JDBC数据访问进行封装的所有类。
 
(8) spring-orm.jar
 
这个jar文件包含Spring对DAO特性集进行了扩展，使其支持 iBATIS、JDO、OJB、TopLink，因为Hibernate已经独立成包了，现在不包含在这个包里了。这个jar文件里大部分的类都要依赖 spring-dao.jar里的类，用这个包时你需要同时包含spring-dao.jar包。
 
(9) spring-remoting.jar
 
　　这个jar文件包含支持EJB、JMS、远程调用Remoting（RMI、Hessian、Burlap、Http Invoker、JAX-RPC）方面的类。
 
(10) spring-support.jar
 
　　这个jar文件包含支持缓存Cache（ehcache）、JCA、JMX、邮件服务（Java Mail、COS Mail）、任务计划Scheduling（Timer、Quartz）方面的类。
 
(11) spring-web.jar
 
　　这个jar文件包含Web应用开发时，用到Spring框架时所需的核心类，包括自动载入WebApplicationContext特性的类、Struts与JSF集成类、文件上传的支持类、Filter类和大量工具辅助类。
 
(12) spring-webmvc.jar
 
这个jar文件包含Spring MVC框架相关的所有类。包含国际化、标签、Theme、视图展现的FreeMarker、JasperReports、Tiles、Velocity、 XSLT相关类。当然，如果你的应用使用了独立的MVC框架，则无需这个JAR文件里的任何类。
 
(13) spring-mock.jar
 
　　这个jar文件包含Spring一整套mock类来辅助应用的测试。Spring测试套件使用了其中大量mock类，这样测试就更加简单。模拟HttpServletRequest和HttpServletResponse类在Web应用单元测试是很方便的。
 
如何选择这些发布包，决定选用哪些发布包其实相当简单。如果你正在构建Web应用并将全程使用Spring，那么最好就使用单个全部的 spring.jar文件；如果你的应用仅仅用到简单的Inversion of Control / Dependency Injection（IoC/DI）容器，那么只需spring-core.jar与spring-beans.jar即可；如果你对发布的大小要求很高，那么就得精挑细选了，只取包含自己所需特性的jar文件了。采用独立的发布包你可以避免包含自己的应用不需要的全部类。当然你可以采用其它的一些工具来设法令整个应用包变小，节省空间的重点在于准确地找出自己所需的Spring依赖类，然后合并所需的类与包就可以了。Eclispe有个插件叫 ClassPath Helper可以帮你找找所依赖的类。
 
Spring包依赖说明:
1)      spring-core.jar需commons-collections.jar，spring-core.jar是以下其它各个的基本。
2)      spring-beans.jar需spring-core.jar，cglib-nodep-2.1_3.jar
3)      spring-aop.jar需spring-core.jar，spring-beans.jar，cglib-nodep-2.1_3.jar，aopalliance.jar
4)      spring-context.jar需spring-core.jar，spring-beans.jar，spring-aop.jar，commons-collections.jar，aopalliance.jar
5)      spring-dao.jar需spring-core.jar，spring-beans.jar，spring-aop.jar，spring-context.jar
6)      spring-jdbc.jar需spring-core.jar，spring-beans.jar，spring-dao.jar
7)      spring-web.jar需spring-core.jar，spring-beans.jar，spring-context.jar
8)      spring-webmvc.jar需spring-core.jar/spring-beans.jar/spring-context.jar/spring-web.jar
9)      spring -hibernate.jar需spring-core.jar，spring-beans.jar，spring-aop.jar，spring- dao.jar，spring-jdbc.jar，spring-orm.jar，spring-web.jar，spring-webmvc.jar
10) spring-orm.jar需spring-core.jar，spring-beans.jar，spring-aop.jar，spring-dao.jar，spring-jdbc.jar，spring-web.jar，spring-webmvc.jar
11) spring -remoting.jar需spring-core.jar，spring-beans.jar，spring-aop.jar，spring- dao.jar，spring-context.jar，spring-web.jar，spring-webmvc.jar
12) spring-support.jar需spring-core.jar，spring-beans.jar，spring-aop.jar，spring-dao.jar，spring-context.jar，spring-jdbc.jar
13) spring-mock.jar需spring-core.jar，spring-beans.jar，spring-dao.jar，spring-context.jar，spring-jdbc.jar
 Copyright ©2011 lyt. All Rights Reserved.
 
 
 
 
java核心技术学习
方式1

public class Person {
 private final String name = "handson";
 private String showAge(String name) {
  return name + " 50";
 }
} 
public interface PersonDao {
 public void add();
} 
public class PersonDaoImp implements PersonDao {
 public void add() {
  System.out.println("add person");
 }
} 
public class PersonDaoProxy implements PersonDao {
 PersonDaoImp personDao;
 public void add() {
  if (personDao == null) {
   personDao = new PersonDaoImp();
  }
  start();
  personDao.add();
  end();
 }
 public void start() {
  System.out.println("开始事务");
 }
 public void end() {
  System.out.println("关闭事务");
 }
}
public class Test {
 public static void main(String[] args) {
  com.pojo.PersonDao pd = new com.pojo.PersonDaoProxy();
  pd.add();
 }
}
 Copyright ©2011 lyt. All Rights Reserved.
 
 
 
java核心技术学习
方式2

public class ProxyHandler implements InvocationHandler {
 PersonDao target;
 public void setTarget(PersonDao target) {
  this.target = target;
 }
 public Object invoke(Object arg0, Method arg1, Object[] arg2) throws Throwable {
  System.out.println("开始事务");
  Object obj = arg1.invoke(target, arg2);
  System.out.println("关闭事务");
  return obj;
 }
}
public class ProxyFactory {
 public static Object getPoxy(PersonDao p) {
  ProxyHandler handler = new ProxyHandler();
  handler.setTarget(p);
  return java.lang.reflect.Proxy.newProxyInstance(p.getClass()
    .getClassLoader(), p.getClass().getInterfaces(), handler);
 }
}
public interface PersonDao {
 public void add();
}

public class PersonDaoImp implements PersonDao {
 public void add() {
  System.out.println("add person");
 }
}
public class Test {
 public static void main(String[] args) {
  PersonDao pd = (PersonDao) ProxyFactory.getPoxy(new PersonDaoImp());
  pd.add();
 }
}
 Copyright ©2011 lyt. All Rights Reserved.
 
 
 
 
java核心技术学习
方式3

所需jar包：spring-aop.jar    spring-beans.jar spring-core.jar spring-context.jar aopaplliance.jar commons-logging.jar
 public class BeforeProxy implements MethodBeforeAdvice {
 public void before(Method arg0, Object[] arg1, Object arg2)
   throws Throwable {
  System.out.println(arg0.getName());
  System.out.println(arg1);
  System.out.println(arg2);
 }
}
 public class AfterProxy implements AfterReturningAdvice {
 public void afterReturning(Object arg0, Method arg1, Object[] arg2,
   Object arg3) throws Throwable {
  System.out.println(arg1.getName());
  System.out.println(arg2);
  System.out.println(arg3);
  System.out.println(arg0);
 }
}
 public class ArundProxy implements MethodInterceptor {
 public Object invoke(MethodInvocation arg0) throws Throwable {
  System.out.println("开始事务");
  Object obj = arg0.proceed();
  System.out.println("关闭事务");
  return obj;
 }
}
 public interface PersonDao {
 public void add();
}

public class PersonDaoImp implements PersonDao {
 public void add() {
  System.out.println("add person");
 }
}
public class Test {
 public static void main(String[] args) {
  org.springframework.context.ApplicationContext context = new org.springframework.context.support.ClassPathXmlApplicationContext(
    "applicationContext.xml");
  PersonDao pd = (PersonDao) context.getBean("aroundProxy");
  pd.add();
 }
}
src下application.xml文件
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
 xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
 xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.0.xsd">
 <bean id="personimp" class="com.spring.aop.PersonDaoImp"></bean>
 <bean id="around" class="com.spring.aop.ArundProxy" />
 <bean id="before" class="com.spring.aop.BeforeProxy" />
 <bean id="after" class="com.spring.aop.AfterProxy" />
 <bean id="aroundProxy"
  class="org.springframework.aop.framework.ProxyFactoryBean">
  <property name="target">
   <ref local="personimp" />
  </property>
  <property name="interfaces">
   <list>
    <value>com.spring.aop.PersonDao</value>
   </list>
  </property>
  <property name="interceptorNames">
   <list>
    <value>around</value>
   </list>
  </property>
 </bean>

 <bean id="afterProxy"
  class="org.springframework.aop.framework.ProxyFactoryBean">
  <property name="target">
   <ref local="personimp" />
  </property>
  <property name="interfaces">
   <list>
    <value>com.spring.aop.PersonDao</value>
   </list>
  </property>
  <property name="interceptorNames">
   <list>
    <value>after</value>
   </list>
  </property>
 </bean>

</beans>
 Copyright ©2011 lyt. All Rights Reserved.
 
 
java核心技术学习
AOP实例

《例1》
<beans>
 <bean id="bookBizTarget" class="y2ssh.sg.chp8.aop.BookBizImpl" />
 <bean id="logAdvice" class="y2ssh.sg.chp8.aop.LogAdvice" />
 <bean id="bookBiz"
 class="org.springframework.aop.framework.ProxyFactoryBean">
  <property name="proxyInterfaces">
   <value>y2ssh.sg.chp8.aop.BookBiz</value>
  </property>
  <property name="interceptorNames">
   <list><value>logAdvice</value></list>
  </property>
  <property name="target" ref="bookBizTarget" />
 </bean>
</beans>
 public class LogAdvice implements MethodBeforeAdvice {
 private static DateFormat sdf = new SimpleDateFormat("yyyy年MM月dd日 hh时mm分ss秒");
 public void before(Method m, Object[] args, Object target)
  throws Throwable {
  System.out.println("\n[系统日志][" + sdf.format(new Date()) + "]" 
    + m.getName() 
    + "("+ Arrays.toString(args) + ")");
 } 
}
 《例2》
 <beans>
 <bean id="colorInk" class="y2ssh.sg.chp8.di.ink.ColorInk" />
 <bean id="greyInk" class="y2ssh.sg.chp8.di.ink.GreyInk" />
 <bean id="a4Paper" class="y2ssh.sg.chp8.di.paper.TextPaper">
  <property name="charPerLine" value="10" />
  <property name="linePerPage" value="8" />
 </bean>
 <bean id="b5Paper" class="y2ssh.sg.chp8.di.paper.TextPaper">
  <property name="charPerLine" value="6" />
  <property name="linePerPage" value="5" />
 </bean>
 <bean id="printer" class="y2ssh.sg.chp8.di.Printer">
  <property name="ink" ref="colorInk"/>
  <property name="paper" ref="b5Paper"/>
 </bean>
</beans>
 Copyright ©2011 lyt. All Rights Reserved.
 
 
 
java核心技术学习
bean.xml

<beans>
<description>Spring Quick Start</description>
<bean id="TheAction"
class="net.xiaxin.spring.qs.UpperAction">
<property name="message">
<value>HeLLo</value>
</property>
</bean>
</beans>
（请确保配置bean.xml位于工作路径之下，注意工作路径并不等同于CLASSPATH ，eclipse
的默认工作路径为项目根路径，也就是.project文件所在的目录，而默认输出目录/bin是项目
CLASSPATH的一部分，并非工作路径。）
 Copyright ©2011 lyt. All Rights Reserved.
 
 
 
java核心技术学习
配置带参数的构造器

<bean id="simple" class="com.JavaBean">
   <constructor-arg index="0">
        <value>lllllll</value>
     </constructor-arg>
   <constructor-arg index="1" value="ads">
         </constructor-arg>
</bean>
<!-声明bean,id是必须的属性-à
    <bean id="userDaoMySqlImpl" class="com.bjsxt.spring.dao.UserDaoMySqlImpl"/>
    <bean id="userDaoOracleImpl" class="com.bjsxt.spring.dao.UserDaoOracleImpl"/>
   
    <bean id="userManager" class="com.bjsxt.spring.manager.UserManagerImpl">
        <!--构造方法注入,当UserManagerImpl使用构造函数来加载userDao时使用的配置
        <constructor-arg ref="userDaoOracleImpl"/>
 -->
        <!-- userDao是UserManagerImpl中的变量名称,主要还是set后面的名称 -->
<!—下面是UserManagerImpl使用setter方法来加载userDao时使用的配置，ref代表引用，说明在当前的文件中会有以userDaoMySqlImpl作为id的一个bean存在 -->
        <property name="userDao" ref="userDaoMySqlImpl"/>
    </bean>
</beans>
 Copyright ©2011 lyt. All Rights Reserved.
 
 
 
 
java核心技术学习
抽象bean

 //把相同的部分抽取出来，配置成一个抽象bean,抽象bean不用配置class属性，id任意起名
    <bean id="parent" abstract="true">
        <property name="id" value="1000"/>
        <property name="name" value="Jack"/>
    </bean>
    //子bean，要配置parent属性，那么就说明子bean具有父亲的属性，如果想改变属性，可以自己覆写
    <bean id="bean3" class="com.bjsxt.spring.Bean3" parent="parent">
        <property name="name" value="Tom"/>//覆写name属性
        <property name="password" value="123"/>
    </bean>
   
    <bean id="bean4" class="com.bjsxt.spring.Bean4" parent="parent"/>
 Copyright ©2011 lyt. All Rights Reserved.
 
 
 
java核心技术学习
bean的作用域


scope可以取值：
    * singleton:每次调用getBean的时候返回相同的实例
    * prototype:每次调用getBean的时候返回不同的实例
<!--  单实例
    <bean id="bean1" class="com.bjsxt.spring.Bean1" scope="singleton"/>
-->
//每次调用一个实例
    <bean id="bean1" class="com.bjsxt.spring.Bean1" scope="prototype"/>
 Copyright ©2011 lyt. All Rights Reserved.
 
 
 
java核心技术学习
不同数据类型bean配置

在 applicationContext.xml配置文件中
bean代表一个类
<bean id="chin" class="com.spring.ioc.Chinese"></bean>
1.   int String 类型  <property name="age">   <value>10</value>  </property>
2.一个接口 在这个类中  Axe axe;  <property name="axe">   <ref local="saxe" />  </property><bean id="saxe" class="com.spring.ioc.StoneAxe"></bean>当访问这个接口（Axe）中的方法时，调用具体实例化出来的实现这个接口的类中的方法。
3.List
  <property name="list">
   <list>
    <value>小学</value>
    <value>中学</value>
    <value>大学</value>
   </list>
  </property>
4.Map  
<property name="map">
   <map>
    <entry key="身高">
     <value>正常</value>
    </entry>
    <entry key="体重">
     <value>190</value>
    </entry>
   </map>
  </property>5.properties（和Map差不多，但里面只能存字符串类型）  <property name="pros">
   <props>
    <prop key="语文">90</prop>
    <prop key="数学">100</prop>
   </props>
  </property>
6.Set
  <property name="set">
   <set>
    <value>handson</value>
    <value>小学</value>
    <ref local="laxe" />
   </set>
  </property>==========================================
7.当访问另一个bean里面的属性值的时候（id里面的值为：要使用的另一个bean的id值然后加“.”加上要使用的另一个bean的属性值）
  <property name="name">
   <bean id="chin.name"  
      class="org.springframework.beans.factory.config.PropertyPathFactoryBean">
   </bean>
  </property>
8.调用另一个类里面的静态常量另一个类为：package com.spring.ioc;public class Contant { public static final String age = "50";}
配置文件：  <property name="age">
   <bean id="com.spring.ioc.Contant.age"
    class="org.springframework.beans.factory.config.FieldRetrievingFactoryBean">
   </bean>
  </property>
9.访问某个类中的某个方法
  <property name="axe">
   <bean
    class="org.springframework.beans.factory.config.MethodInvokingFactoryBean">
    <property name="targetObject">
     <ref local="chin" />
    </property>
    <property name="targetMethod">
     <value>showSex</value>
    </property>
   </bean>
  </property>
某个类中的方法
 public String showSex() {
  return "男";
 }
 Copyright ©2011 lyt. All Rights Reserved.
 
 
 
 
java核心技术学习
BeanFactory

public interface BeanFactory {
//这里是对FactoryBean的转义定义，因为如果使用bean的名字检索FactoryBean得到的对象是工厂生成的对象，
//如果需要得到工厂本身，需要转义
String FACTORY_BEAN_PREFIX = "&";
//这里根据bean的名字，在IOC容器中得到bean实例，这个IOC容器就是一个大的抽象工厂。
Object getBean(String name) throws BeansException;
//这里根据bean的名字和Class类型来得到bean实例，和上面的方法不同在于它会抛出异常：如果根据名字取得的bean实例的Class类型和需要的Object getBean(String name, Class requiredType) throws BeansException;
//这里提供对bean的检索，看看是否在IOC容器有这个名字的bean
boolean containsBean(String name);
//这里根据bean名字得到bean实例，并同时判断这个bean是不是单件
boolean isSingleton(String name) throws NoSuchBeanDefinitionException;
//这里对得到bean实例的Class类型
Class getType(String name) throws NoSuchBeanDefinitionException;
//这里得到bean的别名，如果根据别名检索，那么其原名也会被检索出来
String[] getAliases(String name);
}
 Copyright ©2011 lyt. All Rights Reserved.
 