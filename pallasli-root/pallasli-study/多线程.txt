
study
线程基本方法


setPriority(10)//设置线程优先级，效果不明显
 setDaemon(true)//设置后台线程，不争抢资源，效果不明显
yield()//
 sleep(10)//
  
 Copyright ©2011 lyt. All Rights Reserved.
 
 
 
 
 
study
创建线程

 // 1、必须有线程类
  ThreadTest tt = new ThreadTest();
  // Thread代表线程2.Thread封装线程类
  Thread t = new Thread(tt);
  // 启动线程，通过start方法自动调用run方法
  t.start();
  Thread th = new Thread(tt);
  th.start();
 Copyright ©2011 lyt. All Rights Reserved.
 
 
 
study
线程类

1.继承Thread
class TestThread extends Thread{
    @Override
   public void run(){
       for(int i=0;i<30;i++){
           System.out.println(Thread.currentThread().getName()+i);
       }
   }
}
 2.实现Runnable
 class ThreadTest implements Runnable {
 public void run() {
  for (int i = 0; i < 30; i++) {
   System.out.println("NO-----" + i);
  }
 }
}
 Copyright ©2011 lyt. All Rights Reserved.
 
 
 
study
自定义中断

class MyThread1 extends Thread{
  boolean flag=true;
     int i=0;
  public void run(){
  while(flag){
   System.out.println(i);
   i++;
  }
 }
  public void shutdown(){
   this.flag=false;
  }
}
 Copyright ©2011 lyt. All Rights Reserved.
 
 
 
 
 
 
study
线程独立、共享

//线程独立
  new TestThread1().start();
  new TestThread1().start();
  new TestThread1().start(); 
//线程共享  TestThread2 tt = new TestThread2();
  new Thread(tt).start();
  new Thread(tt).start();
  new Thread(tt).start();
  new Thread(tt).start();
// 线程共享同步监视 public static void main(String[] args)
 {
  TestThread3 tt = new TestThread3();
  new Thread(tt).start();
  new Thread(tt).start();
  new Thread(tt).start();
  new Thread(tt).start();
  System.out.println("Hello World!");
 }
class TestThread3 implements Runnable
{
 private int tickets = 100;
 private Object obj = new Object();//用来做同步的对象，这个对象必须得是成员变量，否则无法共享。
 public void run()
 {
  while(true)
  {
   synchronized(obj){//当有线程进入时，obj进入锁状态，这样别的线程就进不来，直到进入的线程解锁。
    if(tickets > 0)
    {
     try{
      Thread.sleep(10);
     }
     catch(InterruptedException e)
     {
      System.out.println(e.getMessage());
     }
     System.out.println(Thread.currentThread().getName() + ",tickets :" + tickets--);
    }
    else
     break;
   }
  }
 }
}
 Copyright ©2011 lyt. All Rights Reserved.
 
 
 
 
 
 
 
study
线程池

最近在学习线程池的东西，前面有篇文章《线程池的设计原则》，当然大多都是参考别人的思想。然后发现自己多线程真的写的太少了。现在来补充基础知识咯。。。 
wait导致当前的线程等待，直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法。当前的线程必须拥有此对象监视器。该线程发布对此监视器的所有权并等待，直到其他线程通过调用 notify 方法，或 notifyAll 方法通知在此对象的监视器上等待的线程醒来。然后该线程将等到重新获得对监视器的所有权后才能继续执行.
以上是jdk api的说明,对照说明写个测试：

<!--<br /><br />Code highlighting produced by Actipro CodeHighlighter (freeware)<br />http://www.CodeHighlighter.com/<br /><br />-->public class Test extends Thread {

    @Override
    public void run() {
        System.out.println("before wait!");
        try {
            synchronized (this) {
                this.wait();
            }
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try {
            Thread.sleep(20000);
        } catch (Exception e) {
            System.out.println("interrupted!");
        }
        System.out.println("after wait!");
    }

    public synchronized void weakup() {
        this.notify();
    }
}

public class Main {

    public static void main(String[] args) {
        Test test = new Test();
        test.start();
        System.out.println("shit");
        try {
            Thread.sleep(2000);
        } catch (Exception e) {
        }
        test.weakup();
        try {
            Thread.sleep(2000);
        } catch (Exception e) {
        }
        test.interrupt();
        System.out.println("shit");
    }

wait和notify针对的是对象，而不是线程。因为这两个方法都是Object的方法。与线程无关。
所有的线程结束之后，程序才会结束。此处如果不sleep的话，有可能weakup会早于wait先调用。
执行interrupt()时,并不需要获取Thread实例的锁定.任何线程在任何时刻,都可以调用其他线程interrupt().当sleep中的线程被调用interrupt()时,就会放弃暂停的状态.并抛出InterruptedException.
interrupt()不会中断一个正在运行的线程。这一方法实际上完成的是，在线程受到阻塞时抛出一个中断信号，这样线程就得以退出阻塞的状态。更确切的说，如果线程被Object.wait, Thread.join和Thread.sleep三种方法之一阻塞，那么，它将接收到一个中断异常（InterruptedException），从而提早地终结被阻塞状态。 
如果线程没有被阻塞，这时调用interrupt()将不起作用；否则，线程就将得到异常（该线程必须事先预备好处理此状况），接着逃离阻塞状态。 
线程A在执行sleep,wait,join时,线程B调用A的interrupt方法,的确这一个时候A会有InterruptedException异常抛出来.但这其实是在sleep,wait,join这些方法内部会不断检查中断状态的值,而自己抛出的InterruptedException。 
如果线程A正在执行一些指定的操作时如赋值,for,while,if,调用方法等,都不会去检查中断状态,所以线程A不会抛出InterruptedException,而会一直执行着自己的操作.当线程A终于执行到wait(),sleep(),join()时,才马上会抛出InterruptedException. 
若没有调用sleep(),wait(),join()这些方法,或是没有在线程里自己检查中断状态自己抛出InterruptedException的话,那
InterruptedException是不会被抛出来的. 
下面再看tomcat的线程池就比较清楚了：

<!--<br /><br />Code highlighting produced by Actipro CodeHighlighter (freeware)<br />http://www.CodeHighlighter.com/<br /><br />-->class ControlRunnable implements Runnable {
        ThreadPool p;
        Thread t;
        ThreadPoolRunnable toRun;
        boolean shouldTerminate;
        boolean shouldRun;
        boolean noThData;
        Object thData[] = null;

        ControlRunnable(ThreadPool p) {
            toRun = null;
            shouldTerminate = false;
            shouldRun = false;
            this.p = p;
            t = new Thread(this);
            t.start();
            noThData = true;
            thData = null;
        }

        public void run() {
            while (true) {
                try {
                    synchronized (this) {
                        if (!shouldRun && !shouldTerminate) {
                            this.wait();
                        }
                    }
                    if (shouldTerminate) {
                        break;
                    }
                    try {
                        if (noThData) {
                            thData = toRun.getInitData();
                            noThData = false;
                        }
                        if (shouldRun) {
                            toRun.runIt(thData);
                        }
                    } catch (Throwable t) {
                        System.err.println("ControlRunnable Throwable: ");
                        t.printStackTrace();
                        shouldTerminate = true;
                        shouldRun = false;
                        p.notifyThreadEnd();
                    } finally {
                        if (shouldRun) {
                            shouldRun = false;
                            p.returnController(this);
                        }
                    }
                    if (shouldTerminate) {
                        break;
                    }
                } catch (InterruptedException ie) {
                }
            }
        }

        public synchronized void runIt(ThreadPoolRunnable toRun) {
            if (toRun == null) {
                throw new NullPointerException("No Runnable");
            }
            this.toRun = toRun;
            shouldRun = true;
            this.notify();
        }

        public synchronized void terminate() {
            shouldTerminate = true;
            this.notify();
        }

ControlRunnable线程类是线程池中的具体线程，线程构造函数中调用线程的start开始线程，到run方法里得到自己的锁然后wait，等待具体的动作调用：runIt，动作调用就可以notify线程了。里边将线程要做的具体工作委托给了ThreadPoolRunnable接口，用户要使用线程池，只用将自己的任务实现此接口即可。ThreadPoolRunnable的代码如下：
<!--<br /><br />Code highlighting produced by Actipro CodeHighlighter (freeware)<br />http://www.CodeHighlighter.com/<br /><br />-->public interface ThreadPoolRunnable {
    public Object[] getInitData();
    
        public void runIt(Object thData[]);
}
另外，ThreadPool本身还运行了一个MonitorRunnable的线程，用来管理线程池。当(currentThreadCount - currentThreadsBusy) > maxSpareThreads，就会调用ControlRunnable类的terminate方法删除空闲线程，准备删除的线程是否空闲是通过shouldTerminate参数来判断。线程池采用Vector来存储当前空闲的线程。
 
接下来回去研究java nio包。网络编程也是自己一直都想去系统的学习的东西。而且，在java nio中有很多和多线程相通的地方。比如非阻塞和多线程，当然，他们不是一个意思。
Java线程池的瑕疵,For java util concurrent threadpool Since jdk1.5
    java.util.concurrent的作者是Doug Lea : 世界上对Java影响力最大的个人,在jdk1.5之前大家一定熟悉他的backport-util-concurrent.jar."这个鼻梁挂着眼镜，留着德王威廉二世的胡子，脸上永远挂着谦逊腼腆笑容，服务于纽约州立大学Oswego分校计算器科学系的老大爷。",他可是并发编程的大师级人物哦!
    Since jdk1.5,在java.util.concurrent包下的线程池模型是基于queue的,threadpool只有一个,而queue却有多个LinkedBlockingQueue,SynchronousQueue,ScheduledThreadPoolExecutor.DelayedWorkQueue等可参见java.util.concurrent.Executors.注意:我下面的问题是针对LinkedBlockingQueue的,参考的src为jdk1.6.
    Threadpool通过以下的3个属性来标志池中的线程数:
corePoolSize(类似minimumPoolSize),poolSize(当前池中的线程数),maximumPoolSize(最大的线程数).
这3个属性表达的意思是每次新创建或结束一个线程poolSize++/--,在最忙的情况下threadpool创建的线程数不能超过maximumPoolSize,
当空闲的情况下poolSize应该降到corePoolSize,当然threadpool如果从创建时它就从来没有处理过一次请求的话,那么poolSize当然为0.
    通过以上2段的说明下面我要引出我所要讲的问题:
我们来看一下java.util.concurrent.ThreadPoolExecutor的execute方法:
public void execute(Runnable command) {
        if (command == null)
            throw new NullPointerException();
        if (poolSize >= corePoolSize || !addIfUnderCorePoolSize(command)) {
            if (runState == RUNNING && workQueue.offer(command)) {
                if (runState != RUNNING || poolSize == 0)
                    ensureQueuedTaskHandled(command);
            }
            else if (!addIfUnderMaximumPoolSize(command))
                reject(command); // is shutdown or saturated
        }
}
它表达的主体意思是:如果当前的poolSize<corePoolSize,那么就增加线程直到poolSize==corePoolSize.
如果poolSize已经到达corePoolSize,那么就把command(task) put to workQueue,如果workQueue为LinkedBlockingQueue的话,
那么只有当workQueue offer commands达到workQueue.capacity后,threadpool才会继续增加线程直到maximumPoolSize.
1.*****如果LinkedBlockingQueue.capacity被设置为Integer.MAX_VALUE,那么池中的线程几乎不可能到达maximumPoolSize.*****
所以你如果使用了Executors.newFixedThreadPool的话,那么maximumPoolSize和corePoolSize是一样的并且LinkedBlockingQueue.capacity==Integer.MAX_VALUE,或者如果这样new ThreadPoolExecutor(corePoolSize,maximumPoolSize,keepAliveTime,timeUnit,new LinkedBlockingQueue<Runnable>(/*Integer.MAX_VALUE*/))的话,
上述的使用都将导致maximumPoolSize是无效的,也就是说线程池中的线程数不会超出corePoolSize.
这个也让那些tomcat6的开发人员可能也郁闷了,他们不得不改写LinkedBlockingQueue,以tomcat-6.0.20-src为例:
org.apache.tomcat.util.net.NioEndpoint.TaskQueue extends LinkedBlockingQueue<Runnable> override offer method: 
 public void setParent(ThreadPoolExecutor tp, NioEndpoint ep) {
            parent = tp;
            this.endpoint = ep;
        }
        
        public boolean offer(Runnable o) {
            //we can't do any checks
            if (parent==null) return super.offer(o);
            //we are maxed out on threads, simply queue the object
            if (parent.getPoolSize() == parent.getMaximumPoolSize()) return super.offer(o);
            //we have idle threads, just add it to the queue
            //this is an approximation, so it could use some tuning
            if (endpoint.activeSocketProcessors.get()<(parent.getPoolSize())) return super.offer(o);
            //if we have less threads than maximum force creation of a new thread
            if (parent.getPoolSize()<parent.getMaximumPoolSize()) return false;
            //if we reached here, we need to add it to the queue
            return super.offer(o);
        } 
org.apache.tomcat.util.net.NioEndpoint.start()-->
   TaskQueue taskqueue = new TaskQueue();/***queue.capacity==Integer.MAX_VALUE***/
                     TaskThreadFactory tf = new TaskThreadFactory(getName() + "-exec-");
                     executor = new ThreadPoolExecutor(getMinSpareThreads(), getMaxThreads(), 60,TimeUnit.SECONDS,taskqueue, tf);
                     taskqueue.setParent( (ThreadPoolExecutor) executor, this);
2.*****如果把LinkedBlockingQueue.capacity设置为一个适当的值远小于Integer.MAX_VALUE,那么只有put到queue的任务数到达LinkedBlockingQueue的capacity后,才会继续增加池中的线程,使得poolSize超出corePoolSize但不超过maximumPoolSize,这个时候来增加线程数是不是有点晚了呢??????*****.
这样一来reject(command)也可能随之而来了,LinkedBlockingQueue.capacity设置为何值又是个头疼的问题.
所以ThreadPoolExecutor+LinkedBlockingQueue表达的意思是首先会增加线程数到corePoolSize,但只有queue的任务容量到达最大capacity后,才会继续在corePoolSize的基数上增加线程来处理任务,直到maximumPoolSize.
    但为什么我们不能这样呢:将LinkedBlockingQueue.capacity设置为Integer.MAX_VALUE,让task尽可能的得到处理,同时在忙的情况下,增加池中的线程充到maximumPoolSize来尽快的处理这些任务.即便是把LinkedBlockingQueue.capacity设置为一个适当的值<<<远小于Integer.MAX_VALUE,也不一定非得在任务数到达LinkedBlockingQueue的capacity之后才去增加线程使poolSize超出corePoolSize趋向maximumPoolSize.
    所以java util concurrent中的ThreadPoolExecutor+LinkedBlockingQueue组合的缺点也就出来了:如果我们想让线程池尽可能多的处理大量的任务的话,我们会把LinkedBlockingQueue.capacity设置为Integer.MAX_VALUE,但是如果这样的话池中的线程数量就不能充到最大maximumPoolSize,也就不能充分发挥线程池的最大处理能力.如果我们把LinkedBlockingQueue.capacity设置为一个较小的值,那么线程池中的线程数量会充到最大maximumPoolSize,但是如果池中的线程都忙的话,线程池又会reject请求的任务,因为队列已满.
    如果我们把LinkedBlockingQueue.capacity设置为一个较大的值但不是Integer.MAX_VALUE,那么等到线程池的线程数量准备开始超出corePoolSize时,也就是任务队列满了,这个时候才去增加线程的话,请求任务的执行会有一定的延时,也就是没有得到及时的处理.
    其实也就是说ThreadPoolExecutor缺乏灵敏的线程调度机制,没有根据当前任务的执行情况,是忙,还是闲,以及队列中的待处理任务的数量级进行动态的调配线程数,使得它的处理效率受到影响.
那么什么是忙的情况的判断呢?  
busy[1]:如果poolSize==corePoolSize,并且现在忙着执行任务的线程数(currentBusyWorkers)等于poolSize.[而不管现在put到queue的任务数是否到达queue.capacity]
busy[2].1:如果poolSize==corePoolSize,并且put到queue的任务数已到达queue.capacity.[queue.capacity是针对有任务队列极限限制的情况]
busy[2].2:线程池的基本目标是尽可能的快速处理大量的请求任务,那么就不一定非得在put到queue的任务数到达queue的capacity之后才判断为忙的情况,只要queue中现有的任务数(task_counter)与poolSize或者maximumPoolSize存在一定的比例时就可以判断为忙情,比如task_counter>=poolSize或者maximumPoolSize的(NumberOfProcessor+1)倍,这样queue.capacity这个限制可以取消了.
在上述busy[1],busy[2]这2种情况下都应增加线程数,直至maximumPoolSize,使请求的任务得到最快的处理.
前面讲的是忙的时候ThreadPoolExecutor+LinkedBlockingQueue在处理上的瑕疵,那么空闲的时候又要如何呢?
如果corePoolSize<poolSize<maximumPoolSize,那么线程等待keepAliveTime之后应该降为corePoolSize,嘿嘿,这个就真的成了bug了哦,一个很难发现的bug,poolSize是被降下来了,可是很可能降过了头<corePoolSize,甚至降为0也有可能.
ThreadPoolExecutor.Worker.run()-->ThreadPoolExecutor.getTask():
Runnable getTask() {
        for (;;) {
            try {
                int state = runState;
                if (state > SHUTDOWN)
                    return null;
                Runnable r;
                if (state == SHUTDOWN)  // Help drain queue
                    r = workQueue.poll();
                else if (poolSize > corePoolSize || allowCoreThreadTimeOut)
      /*queue is empty,这里timeout之后,return null,之后call workerCanExit() return true.*/
                    r = workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS);
                else
                    r = workQueue.take();
                if (r != null)
                    return r;
                if (workerCanExit()) {
                    if (runState >= SHUTDOWN) // Wake up others
                        interruptIdleWorkers();
                    return null;
                }
                // Else retry
            } catch (InterruptedException ie) {
                // On interruption, re-check runState
            }
        }
}//end getTask.
private boolean workerCanExit() {
        final ReentrantLock mainLock = this.mainLock;
        mainLock.lock();
        boolean canExit;
        try {
            canExit = runState >= STOP ||
                workQueue.isEmpty() ||
                (allowCoreThreadTimeOut &&
                 poolSize > Math.max(1, corePoolSize));
        } finally {
            mainLock.unlock();
        }
        return canExit;
}//end workerCanExit.
在workerCanExit() return true之后,poolSize仍然大于corePoolSize,pooSize的值没有变化,
ThreadPoolExecutor.Worker.run()将结束-->ThreadPoolExecutor.Worker.workerDone-->这个时候才将poolSize--,可惜晚了,在多线程的环境下,poolSize的值将变为小于corePoolSize,而不是等于corePoolSize!!!!!!
例如:如果poolSize(6)大于corePoolSize(5),那么同时timeout的就不一定是一条线程,而是多条,它们都有可能退出run,使得poolSize--减过了corePoolSize.
    提一下java.util.concurrent.ThreadPoolExecutor的allowCoreThreadTimeOut方法, @since 1.6 public void allowCoreThreadTimeOut(boolean value);
它表达的意思是在空闲的时候让线程等待keepAliveTime,timeout后使得poolSize能够降为0.[其实我是希望它降为minimumPoolSize,特别是在服务器的环境下,我们需要线程池保持一定数量的线程来及时处理"零零碎碎的,断断续续的,一股一波的,不是很有压力的"请求],当然你可以把corePoolSize当作minimumPoolSize,而不调用该方法.
    针对上述java util concurrent线程池的瑕疵,我对java util concurrent线程池模型进行了修正,特别是在"忙"(busy[1],busy[2])的情况下的任务处理进行了优化,使得线程池尽可能快的处理尽可能多的任务.
 Copyright ©2011 lyt. All Rights Reserved.
 
 
 
 
 
 
study
java线程

什么是线程？
几乎每种操作系统都支持进程的概念—— 进程就是在某种程度上相互隔离的、独立运行的程序。
线程化是允许多个活动共存于一个进程中的工具。大多数现代的操作系统都支持线程，而且线程的
概念以各种形式已存在了好多年。Java 是第一个在语言本身中显式地包含线程的主流编程语言，它
没有把线程化看作是底层操作系统的工具。
有时候，线程也称作轻量级进程。就象进程一样，线程在程序中是独立的、并发的执行路径，每个
线程有它自己的堆栈、自己的程序计数器和自己的局部变量。但是，与分隔的进程相比，进程中的
线程之间的隔离程度要小。它们共享内存、文件句柄和其它每个进程应有的状态。
进程可以支持多个线程，它们看似同时执行，但互相之间并不同步。一个进程中的多个线程共享相
同的内存地址空间，这就意味着它们可以访问相同的变量和对象，而且它们从同一堆中分配对象。
尽管这让线程之间共享信息变得更容易，但您必须小心，确保它们不会妨碍同一进程里的其它线程。
Java 线程工具和 API 看似简单。但是，编写有效使用线程的复杂程序并不十分容易。因为有多个
线程共存在相同的内存空间中并共享相同的变量，所以您必须小心，确保您的线程不会互相干扰。
每个 Java 程序都使用线程
每个 Java 程序都至少有一个线程— 主线程。当一个 Java 程序启动时，JVM 会创建主线程，并
在该线程中调用程序的 main() 方法。
JVM 还创建了其它线程，您通常都看不到它们— 例如，与垃圾收集、对象终止和其它 JVM 内务处
理任务相关的线程。其它工具也创建线程，如 AWT（抽象窗口工具箱（Abstract Windowing Toolkit））
或 Swing UI 工具箱、servlet 容器、应用程序服务器和 RMI（远程方法调用（Remote Method
Invocation））。
为什么使用线程？
在 Java 程序中使用线程有许多原因。如果您使用 Swing、servlet、RMI 或 Enterprise JavaBeans
（EJB）技术，您也许没有意识到您已经在使用线程了。
使用线程的一些原因是它们可以帮助：
使 UI 响应更快
利用多处理器系统
简化建模
执行异步或后台处理
响应更快的UI
事件驱动的UI 工具箱（如 AWT 和 Swing）有一个事件线程，它处理 UI 事件，如击键或鼠标点击。
AWT 和 Swing 程序把事件侦听器与 UI 对象连接。当特定事件（如单击了某个按钮）发生时，这些
侦听器会得到通知。事件侦听器是在 AWT 事件线程中调用的。
如果事件侦听器要执行持续很久的任务，如检查一个大文档中的拼写，事件线程将忙于运行拼写检
查器，所以在完成事件侦听器之前，就不能处理额外的 UI 事件。这就会使程序看来似乎停滞了，
让用户不知所措。
要避免使 UI 延迟响应，事件侦听器应该把较长的任务放到另一个线程中，这样 AWT 线程在任务的
执行过程中就可以继续处理 UI 事件（包括取消正在执行的长时间运行任务的请求）。
利用多处理器系统
多处理器（MP）系统比过去更普及了。以前只能在大型数据中心和科学计算设施中才能找到它们。
现在许多低端服务器系统— 甚至是一些台式机系统— 都有多个处理器。
现代操作系统，包括Linux、Solaris 和 Windows NT/2000，都可以利用多个处理器并调度线程在
任何可用的处理器上执行。
Java线程
Java爱好者第 5 页http://www.javafan.net
调度的基本单位通常是线程；如果某个程序只有一个活动的线程，它一次只能在一个处理器上运行。
如果某个程序有多个活动线程，那么可以同时调度多个线程。在精心设计的程序中，使用多个线程
可以提高程序吞吐量和性能。
简化建模
在某些情况下，使用线程可以使程序编写和维护起来更简单。考虑一个仿真应用程序，您要在其中
模拟多个实体之间的交互作用。给每个实体一个自己的线程可以使许多仿真和对应用程序的建模大
大简化。
另一个适合使用单独线程来简化程序的示例是在一个应用程序有多个独立的事件驱动的组件的时
候。例如，一个应用程序可能有这样一个组件，该组件在某个事件之后用秒数倒计时，并更新屏幕
显示。与其让一个主循环定期检查时间并更新显示，不如让一个线程什么也不做，一直休眠，直到
某一段时间后，更新屏幕上的计数器，这样更简单，而且不容易出错。这样，主线程就根本无需担
心计时器。
异步或后台处理
服务器应用程序从远程来源（如套接字）获取输入。当读取套接字时，如果当前没有可用数据，那
么对 SocketInputStream.read() 的调用将会阻塞，直到有可用数据为止。
如果单线程程序要读取套接字，而套接字另一端的实体并未发送任何数据，那么该程序只会永远等
待，而不执行其它处理。相反，程序可以轮询套接字，查看是否有可用数据，但通常不会使用这种
做法，因为会影响性能。
但是，如果您创建了一个线程来读取套接字，那么当这个线程等待套接字中的输入时，主线程就可
以执行其它任务。您甚至可以创建多个线程，这样就可以同时读取多个套接字。这样，当有可用数
据时，您会迅速得到通知（因为正在等待的线程被唤醒），而不必经常轮询以检查是否有可用数据。
使用线程等待套接字的代码也比轮询更简单、更不易出错。
Java线程
Java爱好者第 6 页http://www.javafan.net
简单，但有时有风险
虽然 Java 线程工具非常易于使用，但当您创建多线程程序时，应该尽量避免一些风险。
当多个线程访问同一数据项（如静态字段、可全局访问对象的实例字段或共享集合）时，需要确保
它们协调了对数据的访问，这样它们都可以看到数据的一致视图，而且相互不会干扰另一方的更改。
为了实现这个目的，Java 语言提供了两个关键字：synchronized 和 volatile。我们将稍后在本教
程中研究这些关键字的用途和意义。
当从多个线程中访问变量时，必须确保对该访问正确地进行了同步。对于简单变量，将变量声明成
volatile 也许就足够了，但在大多数情况下，需要使用同步。
如果您将要使用同步来保护对共享变量的访问，那么必须确保在程序中所有访问该变量的地方都使
用同步。
不要做过头
虽然线程可以大大简化许多类型的应用程序，过度使用线程可能会危及程序的性能及其可维护性。
线程消耗了资源。因此，在不降低性能的情况下，可以创建的线程的数量是有限制的。
尤其在单处理器系统中，使用多个线程不会使主要消耗 CPU 资源的程序运行得更快。
示例：使用一个线程用于计时，并使用另一个线程完成工作
以下示例使用两个线程，一个用于计时，一个用于执行实际工作。主线程使用非常简单的算法计算
素数。
在它启动之前，它创建并启动一个计时器线程，这个线程会休眠十秒钟，然后设置一个主线程要检
查的标志。十秒钟之后，主线程将停止。请注意，共享标志被声明成 volatile。
/**
Java线程
Java爱好者第 7 页http://www.javafan.net
* CalculatePrimes -- calculate as many primes as we can in ten seconds
*/
public class CalculatePrimes extends Thread {
public static final int MAX_PRIMES = 1000000;
public static final int TEN_SECONDS = 10000;
public volatile boolean finished = false;
public void run() {
int[] primes = new int[MAX_PRIMES];
int count = 0;
for (int i=2; count<MAX_PRIMES; i++) {
// Check to see if the timer has expired
if (finished) {
break;
}
boolean prime = true;
for (int j=0; j<count; j++) {
if (i % primes[j] == 0) {
prime = false;
break;
}
}
if (prime) {
primes[count++] = i;
System.out.println("Found prime: " + i);
}
}
}
public static void main(String[] args) {
CalculatePrimes calculator = new CalculatePrimes();
calculator.start();
try {
Thread.sleep(TEN_SECONDS);
}
Java线程
Java爱好者第 8 页http://www.javafan.net
catch (InterruptedException e) {
// fall through
}
calculator.finished = true;
}
}
小结
Java 语言包含了内置在语言中的功能强大的线程工具。您可以将线程工具用于：
增加 GUI 应用程序的响应速度
利用多处理器系统
当程序有多个独立实体时，简化程序逻辑
在不阻塞整个程序的情况下，执行阻塞I/O
当使用多个线程时，必须谨慎，遵循在线程之间共享数据的规则，我们将在共享对数据的访问中讨
论这些规则。所有这些规则归结为一条基本原则：不要忘了同步。
第三章线程的生命
创建线程
在 Java 程序中创建线程有几种方法。每个 Java 程序至少包含一个线程：主线程。其它线程都是
通过 Thread 构造器或实例化继承类 Thread 的类来创建的。
Java 线程可以通过直接实例化 Thread 对象或实例化继承 Thread 的对象来创建其它线程。在线程
基础中的示例（其中，我们在十秒钟之内计算尽量多的素数）中，我们通过实例化 CalculatePrimes
类型的对象（它继承了 Thread），创建了一个线程。
当我们讨论Java 程序中的线程时，也许会提到两个相关实体：完成工作的实际线程或代表线程的
Thread 对象。正在运行的线程通常是由操作系统创建的；Thread 对象是由 Java VM 创建的，作为
控制相关线程的一种方式。
Java线程
Java爱好者第 9 页http://www.javafan.net
创建线程和启动线程并不相同
在一个线程对新线程的 Thread 对象调用 start() 方法之前，这个新线程并没有真正开始执行。
Thread 对象在其线程真正启动之前就已经存在了，而且其线程退出之后仍然存在。这可以让您控制
或获取关于已创建的线程的信息，即使线程还没有启动或已经完成了。
通常在构造器中通过start() 启动线程并不是好主意。这样做，会把部分构造的对象暴露给新的线
程。如果对象拥有一个线程，那么它应该提供一个启动该线程的start() 或 init() 方法，而不是
从构造器中启动它。（请参阅参考资料，获取提供此概念更详细说明的文章链接。）
结束线程
线程会以以下三种方式之一结束：
线程到达其run() 方法的末尾。
线程抛出一个未捕获到的 Exception 或 Error。
另一个线程调用一个弃用的 stop() 方法。弃用是指这些方法仍然存在，但是您不应该在新
代码中使用它们，并且应该尽量从现有代码中除去它们。
当 Java 程序中的所有线程都完成时，程序就退出了。
加入线程
Thread API 包含了等待另一个线程完成的方法：join() 方法。当调用 Thread.join() 时，调用线
程将阻塞，直到目标线程完成为止。
Thread.join() 通常由使用线程的程序使用，以将大问题划分成许多小问题，每个小问题分配一个
线程。本章结尾处的示例创建了十个线程，启动它们，然后使用 Thread.join() 等待它们全部完成。
Java线程
Java爱好者第 10 页http://www.javafan.net
调度
除了何时使用 Thread.join() 和 Object.wait() 外，线程调度和执行的计时是不确定的。如果两
个线程同时运行，而且都不等待，您必须假设在任何两个指令之间，其它线程都可以运行并修改程
序变量。如果线程要访问其它线程可以看见的变量，如从静态字段（全局变量）直接或间接引用的
数据，则必须使用同步以确保数据一致性。
在以下的简单示例中，我们将创建并启动两个线程，每个线程都打印两行到 System.out：
public class TwoThreads {
public static class Thread1 extends Thread {
public void run() {
System.out.println("A");
System.out.println("B");
}
}
public static class Thread2 extends Thread {
public void run() {
System.out.println("1");
System.out.println("2");
}
}
public static void main(String[] args) {
new Thread1().start();
new Thread2().start();
}
}
我们并不知道这些行按什么顺序执行，只知道“1”在“2”之前打印，以及“A”在“B”之前打印。
输出可能是以下结果中的任何一种：
Java线程
Java爱好者第 11 页http://www.javafan.net
1 2 A B
1 A 2 B
1 A B 2
A 1 2 B
A 1 B 2
A B 1 2
不仅不同机器之间的结果可能不同，而且在同一机器上多次运行同一程序也可能生成不同结果。永
远不要假设一个线程会在另一个线程之前执行某些操作，除非您已经使用了同步以强制一个特定的
执行顺序。
休眠
Thread API 包含了一个 sleep() 方法，它将使当前线程进入等待状态，直到过了一段指定时间，
或者直到另一个线程对当前线程的 Thread 对象调用了 Thread.interrupt()，从而中断了线程。当
过了指定时间后，线程又将变成可运行的，并且回到调度程序的可运行线程队列中。
如果线程是由对 Thread.interrupt() 的调用而中断的，那么休眠的线程会抛出
InterruptedException，这样线程就知道它是由中断唤醒的，就不必查看计时器是否过期。
Thread.yield() 方法就象 Thread.sleep() 一样，但它并不引起休眠，而只是暂停当前线程片刻，
这样其它线程就可以运行了。在大多数实现中，当较高优先级的线程调用Thread.yield() 时，较
低优先级的线程就不会运行。
CalculatePrimes 示例使用了一个后台线程计算素数，然后休眠十秒钟。当计时器过期后，它就会
设置一个标志，表示已经过了十秒。
守护程序线程
我们提到过当 Java 程序的所有线程都完成时，该程序就退出，但这并不完全正确。隐藏的系统线
程，如垃圾收集线程和由 JVM 创建的其它线程会怎么样？我们没有办法停止这些线程。如果那些线
程正在运行，那么 Java 程序怎么退出呢？
Java线程
Java爱好者第 12 页http://www.javafan.net
这些系统线程称作守护程序线程。Java 程序实际上是在它的所有非守护程序线程完成后退出的。
任何线程都可以变成守护程序线程。可以通过调用Thread.setDaemon() 方法来指明某个线程是守
护程序线程。您也许想要使用守护程序线程作为在程序中创建的后台线程，如计时器线程或其它延
迟的事件线程，只有当其它非守护程序线程正在运行时，这些线程才有用。
示例：用多个线程分解大任务
在这个示例中，TenThreads 显示了一个创建了十个线程的程序，每个线程都执行一部分工作。该程
序等待所有线程全部完成，然后收集结果。
/**
* Creates ten threads to search for the maximum value of a large matrix.
* Each thread searches one portion of the matrix.
*/
public class TenThreads {
private static class WorkerThread extends Thread {
int max = Integer.MIN_VALUE;
int[] ourArray;
public WorkerThread(int[] ourArray) {
this.ourArray = ourArray;
}
// Find the maximum value in our particular piece of the array
public void run() {
for (int i = 0; i < ourArray.length; i++)
max = Math.max(max, ourArray[i]);
}
public int getMax() {
return max;
}
}
public static void main(String[] args) {
WorkerThread[] threads = new WorkerThread[10];
int[][] bigMatrix = getBigHairyMatrix();
Java线程
Java爱好者第 13 页http://www.javafan.net
int max = Integer.MIN_VALUE;
// Give each thread a slice of the matrix to work with
for (int i=0; i < 10; i++) {
threads[i] = new WorkerThread(bigMatrix[i]);
threads[i].start();
}
// Wait for each thread to finish
try {
for (int i=0; i < 10; i++) {
threads[i].join();
max = Math.max(max, threads[i].getMax());
}
}
catch (InterruptedException e) {
// fall through
}
System.out.println("Maximum value was " + max);
}
}
小结
就象程序一样，线程有生命周期：它们启动、执行，然后完成。一个程序或进程也许包含多个线程，
而这些线程看来互相单独地执行。
线程是通过实例化 Thread 对象或实例化继承Thread 的对象来创建的，但在对新的 Thread 对象
调用 start() 方法之前，这个线程并没有开始执行。当线程运行到其 run() 方法的末尾或抛出未
经处理的异常时，它们就结束了。
sleep() 方法可以用于等待一段特定时间；而join() 方法可能用于等到另一个线程完成。
第四章无处不在的线程
谁创建线程？
即使您从未显式地创建一个新线程，您仍可能会发现自己在使用线程。线程被从各种来源中引入到
我们的程序中。
有许多工具可以为您创建线程，如果要使用这些工具，应该了解线程如何交互，以及如何防止线程
互相干扰。
AWT 和Swing
任何使用 AWT 或 Swing 的程序都必须处理线程。AWT 工具箱创建单个线程，用于处理 UI 事件，
任何由 AWT 事件调用的事件侦听器都在 AWT 事件线程中执行。
您不仅必须关心同步对事件侦听器和其它线程之间共享的数据项的访问，而且还必须找到一种方法，
让由事件侦听器触发的长时间运行任务（如在大文档中检查拼写或在文件系统中搜索一个文件）在
后台线程中运行，这样当该任务运行时，UI 就不会停滞了（这可能还会阻止用户取消操作）。这样
做的一个好的框架示例是 SwingWorker 类（请参阅参考资料）。
AWT 事件线程并不是守护程序线程；这就是通常使用System.exit() 结束AWT 和Swing 应用程序
的原因。
使用 TimerTask
JDK 1.3 中，TimerTask 工具被引入到Java 语言。这个便利的工具让您可以稍后在某个时间执行
任务（例如，即从现在起十秒后运行一次任务），或者定期执行任务（即，每隔十秒运行任务）。
实现 Timer 类非常简单：它创建一个计时器线程，并且构建一个按执行时间排序的等待事件队列。
TimerTask 线程被标记成守护程序线程，这样它就不会阻止程序退出。
Java线程
Java爱好者第 15 页http://www.javafan.net
因为计时器事件是在计时器线程中执行，所以必须确保正确同步了针对计时器任___________务中使用的任何数
据项的访问。
在 CalculatePrimes 示例中，并没有让主线程休眠，我们可以使用 TimerTask，方法如下：
public static void main(String[] args) {
Timer timer = new Timer();
final CalculatePrimes calculator = new CalculatePrimes();
calculator.start();
timer.schedule(
new TimerTask() {
public void run()
{
calculator.finished = true;
}
}, TEN_SECONDS);
}
servlet 和JavaServer Pages 技术
servlet 容器创建多个线程，在这些线程中执行 servlet 请求。作为 servlet 编写者，您不知道
（也不应该知道）您的请求会在什么线程中执行；如果同时有多个对相同URL 的请求入站，那么同
一个 servlet 可能会同时在多个线程中是活动的。
当编写 servlet 或JavaServer Pages (JSP) 文件时，必须始终假设可以在多个线程中并发地执行
同一个 servlet 或JSP 文件。必须适当同步servlet 或 JSP 文件访问的任何共享数据；这包括
servlet 对象本身的字段。
实现 RMI 对象
Java线程
Java爱好者第 16 页http://www.javafan.net
RMI 工具可以让您调用对在其它 JVM 中运行的对象进行的操作。当调用远程方法时，RMI 编译器创
建的 RMI 存根会打包方法参数，并通过网络将它们发送到远程系统，然后远程系统会将它们解包并
调用远程方法。
假设您创建了一个 RMI 对象，并将它注册到RMI 注册表或者 Java 命名和目录接口（Java Naming
and Directory Interface (JNDI)）名称空间。当远程客户机调用其中的一个方法时，该方法会在
什么线程中执行呢？
实现 RMI 对象的常用方法是继承 UnicastRemoteObject。在构造 UnicastRemoteObject 时，会初
始化用于分派远程方法调用的基础结构。这包括用于接收远程调用请求的套接字侦听器，和一个或
多个执行远程请求的线程。
所以，当接收到执行RMI 方法的请求时，这些方法将在 RMI 管理的线程中执行。
小结
线程通过几种机制进入 Java 程序。除了用 Thread 构造器中显式创建线程之外，还可以用许多其
它机制创建线程：
AWT 和 Swing
RMI
java.util.TimerTask 工具
servlet 和JSP 技术
第五章共享对数据的访问
共享变量
要使多个线程在一个程序中有用，它们必须有某种方法可以互相通信或共享它们的结果。
让线程共享其结果的最简单方法是使用共享变量。它们还应该使用同步来确保值从一个线程正确传
播到另一个线程，以及防止当一个线程正在更新一些相关数据项时，另一个线程看到不一致的中间
结果。
线程基础中计算素数的示例使用了一个共享布尔变量，用于表示指定的时间段已经过去了。这说明
了在线程间共享数据最简单的形式是：轮询共享变量以查看另一个线程是否已经完成执行某项任务。
存在于同一个内存空间中的所有线程
正如前面讨论过的，线程与进程有许多共同点，不同的是线程与同一进程中的其它线程共享相同的
进程上下文，包括内存。这非常便利，但也有重大责任。只要访问共享变量（静态或实例字段），
线程就可以方便地互相交换数据，但线程还必须确保它们以受控的方式访问共享变量，以免它们互
相干扰对方的更改。
任何线程可以访问所有其作用域内的变量，就象主线程可以访问该变量一样。素数示例使用了一个
公用实例字段，叫做 finished，用于表示已经过了指定的时间。当计时器过期时，一个线程会写这
个字段；另一个线程会定期读取这个字段，以检查它是否应该停止。注：这个字段被声明成 volatile，
这对于这个程序的正确运行非常重要。在本章的后面，我们将看到原因。
受控访问的同步
为了确保可以在线程之间以受控方式共享数据，Java 语言提供了两个关键字：synchronized 和
volatile。
Java线程
Java爱好者第 18 页http://www.javafan.net
Synchronized 有两个重要含义：它确保了一次只有一个线程可以执行代码的受保护部分（互斥，
mutual exclusion 或者说 mutex），而且它确保了一个线程更改的数据对于其它线程是可见的（更
改的可见性）。
如果没有同步，数据很容易就处于不一致状态。例如，如果一个线程正在更新两个相关值（比如，
粒子的位置和速率），而另一个线程正在读取这两个值，有可能在第一个线程只写了一个值，还没
有写另一个值的时候，调度第二个线程运行，这样它就会看到一个旧值和一个新值。同步让我们可
以定义必须原子地运行的代码块，这样对于其他线程而言，它们要么都执行，要么都不执行。
同步的原子执行或互斥方面类似于其它操作环境中的临界段的概念。
确保共享数据更改的可见性
同步可以让我们确保线程看到一致的内存视图。
处理器可以使用高速缓存加速对内存的访问（或者编译器可以将值存储到寄存器中以便进行更快的
访问）。在一些多处理器体系结构上，如果在一个处理器的高速缓存中修改了内存位置，没有必要
让其它处理器看到这一修改，直到刷新了写入器的高速缓存并且使读取器的高速缓存无效。
这表示在这样的系统上，对于同一变量，在两个不同处理器上执行的两个线程可能会看到两个不同
的值！这听起来很吓人，但它却很常见。它只是表示在访问其它线程使用或修改的数据时，必须遵
循某些规则。
Volatile 比同步更简单，只适合于控制对基本变量（整数、布尔变量等）的单个实例的访问。当一
个变量被声明成 volatile，任何对该变量的写操作都会绕过高速缓存，直接写入主内存，而任何对
该变量的读取也都绕过高速缓存，直接取自主内存。这表示所有线程在任何时候看到的 volatile 变
量值都相同。
如果没有正确的同步，线程可能会看到旧的变量值，或者引起其它形式的数据损坏。
用锁保护的原子代码块
Volatile 对于确保每个线程看到最新的变量值非常有用，但有时我们需要保护比较大的代码片段，
如涉及更新多个变量的片段。
同步使用监控器（monitor）或锁的概念，以协调对特定代码块的访问。
每个 Java 对象都有一个相关的锁。同一时间只能有一个线程持有 Java 锁。当线程进入
synchronized 代码块时，线程会阻塞并等待，直到锁可用，当它可用时，就会获得这个锁，然后执
行代码块。当控制退出受保护的代码块时，即到达了代码块末尾或者抛出了没有在 synchronized 块
中捕获的异常时，它就会释放该锁。
这样，每次只有一个线程可以执行受给定监控器保护的代码块。从其它线程的角度看，该代码块可
以看作是原子的，它要么全部执行，要么根本不执行。
简单的同步示例
使用 synchronized 块可以让您将一组相关更新作为一个集合来执行，而不必担心其它线程中断或
看到计算的中间结果。以下示例代码将打印“1 0”或“0 1”。如果没有同步，它还会打印“1 1”
（或“0 0”，随便您信不信）。
public class SyncExample {
private static lockObject = new Object();
private static class Thread1 extends Thread {
public void run() {
synchronized (lockObject) {
x = y = 0;
System.out.println(x);
}
}
}
private static class Thread2 extends Thread {
public void run() {
synchronized (lockObject) {
Java线程
Java爱好者第 20 页http://www.javafan.net
x = y = 1;
System.out.println(y);
}
}
}
public static void main(String[] args) {
new Thread1().run();
new Thread2().run();
}
}
在这两个线程中都必须使用同步，以便使这个程序正确工作。
Java 锁定
Java 锁定合并了一种互斥形式。每次只有一个线程可以持有锁。锁用于保护代码块或整个方法，必
须记住是锁的身份保护了代码块，而不是代码块本身，这一点很重要。一个锁可以保护许多代码块
或方法。
反之，仅仅因为代码块由锁保护并不表示两个线程不能同时执行该代码块。它只表示如果两个线程
正在等待相同的锁，则它们不能同时执行该代码。
在以下示例中，两个线程可以同时不受限制地执行 setLastAccess() 中的synchronized 块，因为
每个线程有一个不同的 thingie 值。因此，synchronized 代码块受到两个正在执行的线程中不同
锁的保护。
public class SyncExample {
public static class Thingie {
private Date lastAccess;
public synchronized void setLastAccess(Date date) {
this.lastAccess = date;
}
}
Java线程
Java爱好者第 21 页http://www.javafan.net
public static class MyThread extends Thread {
private Thingie thingie;
public MyThread(Thingie thingie) {
this.thingie = thingie;
}
public void run() {
thingie.setLastAccess(new Date());
}
}
public static void main() {
Thingie thingie1 = new Thingie(),
thingie2 = new Thingie();
new MyThread(thingie1).start();
new MyThread(thingie2).start();
}
}
同步的方法
创建 synchronized 块的最简单方法是将方法声明成 synchronized。这表示在进入方法主体之前，
调用者必须获得锁：
public class Point {
public synchronized void setXY(int x, int y) {
this.x = x;
this.y = y;
}
}
对于普通的synchronized 方法，这个锁是一个对象，将针对它调用方法。对于静态synchronized
方法，这个锁是与 Class 对象相关的监控器，在该对象中声明了方法。
Java线程
Java爱好者第 22 页http://www.javafan.net
仅___________仅因为 setXY() 被声明成synchronized 并不表示两个不同的线程不能同时执行 setXY()，只要
它们调用不同的 Point 实例的 setXY() 就可同时执行。对于一个Point 实例，一次只能有一个线
程执行 setXY()，或Point 的任何其它 synchronized 方法。
同步的块
synchronized 块的语法比 synchronized 方法稍微复杂一点，因为还需要显式地指定锁要保护哪个
块。Point 的以下版本等价于前一页中显示的版本：
public class Point {
public void setXY(int x, int y) {
synchronized (this) {
this.x = x;
this.y = y;
}
}
}
使用 this 引用作为锁很常见，但这并不是必需的。这表示该代码块将与这个类中的 synchronized
方法使用同一个锁。
由于同步防止了多个线程同时执行一个代码块，因此性能上就有问题，即使是在单处理器系统上。
最好在尽可能最小的需要保护的代码块上使用同步。
访问局部（基于堆栈的）变量从来不需要受到保护，因为它们只能被自己所属的线程访问。
大多数类并没有同步
因为同步会带来小小的性能损失，大多数通用类，如java.util 中的 Collection 类，不在内部使
用同步。这表示在没有附加同步的情况下，不能在多个线程中使用诸如 HashMap 这样的类。
Java线程
Java爱好者第 23 页http://www.javafan.net
通过每次访问共享集合中的方法时使用同步，可以在多线程应用程序中使用 Collection 类。对于
任何给定的集合，每次必须用同一个锁进行同步。通常可以选择集合对象本身作为锁。
下一页中的示例类 SimpleCache 显示了如何使用 HashMap 以线程安全的方式提供高速缓存。但是，
通常适当的同步并不只是意味着同步每个方法。
Collections 类提供了一组便利的用于List、Map 和 Set 接口的封装器。您可以用
Collections.synchronizedMap 封装 Map，它将确保所有对该映射的访问都被正确同步。
如果类的文档没有说明它是线程安全的，那么您必须假设它不是。
示例：简单的线程安全的高速缓存
如以下代码样本所示，SimpleCache.java 使用 HashMap 为对象装入器提供了一个简单的高速缓存。
load() 方法知道怎样按对象的键装入对象。在一次装入对象之后，该对象就被存储到高速缓存中，
这样以后的访问就会从高速缓存中检索它，而不是每次都全部地装入它。对共享高速缓存的每个访
问都受到 synchronized 块保护。由于它被正确同步，所以多个线程可以同时调用getObject 和
clearCache 方法，而没有数据损坏的风险。
public class SimpleCache {
private final Map cache = new HashMap();
public Object load(String objectName) {
// load the object somehow
}
public void clearCache() {
synchronized (cache) {
cache.clear();
}
}
public Object getObject(String objectName) {
synchronized (cache) {
Object o = cache.get(objectName);
Java线程
Java爱好者第 24 页http://www.javafan.net
if (o == null) {
o = load(objectName);
cache.put(objectName, o);
}
}
return o;
}
}
小结
由于线程执行的计时是不确定的，我们需要小心，以控制线程对共享数据的访问。否则，多个并发
线程会互相干扰对方的更改，从而损坏数据，或者其它线程也许不能及时看到对共享数据的更改。
通过使用同步来保护对共享变量的访问，我们可以确保线程以可预料的方式与程序变量进行交互。
每个 Java 对象都可以充当锁，synchronized 块可以确保一次只有一个线程执行由给定锁保护的
synchronized 代码。
Java线程
Java爱好者第 25 页http://www.javafan.net
第六章同步详细信息
互斥
在共享对数据的访问中，我们讨论了 synchronized 块的特征，并在实现典型互斥锁（即，互斥或
临界段）时说明了它们，其中每次只有一个线程可以执行受给定锁保护的代码块。
互斥是同步所做工作的重要部分，但同步还有其它几种特征，这些特征对于在多处理器系统上取得
正确结果非常重要。
可见性
除了互斥，同步（如 volatile）强制某些可见性约束。当对象获取锁时，它首先使自己的高速缓存
无效，这样就可以保证直接从主内存中装入变量。
同样，在对象释放锁之前，它会刷新其高速缓存，强制使已做的任何更改都出现在主内存中。
这样，会保证在同一个锁上同步的两个线程看到在synchronized 块内修改的变量的相同值。
什么时候必须同步？
要跨线程维护正确的可见性，只要在几个线程之间共享非 final 变量，就必须使用 synchronized
（或 volatile）以确保一个线程可以看见另一个线程做的更改。
可见性同步的基本规则是在以下情况中必须同步：
读取上一次可能是由另一个线程写入的变量
写入下一次可能由另一个线程读取的变量
用于一致性的同步
除了用于可见性的同步，从应用程序角度看，您还必须用同步来确保一致性得到了维护。当修改多
个相关值时，您想要其它线程原子地看到这组更改— 要么看到全部更改，要么什么也看不到。这
Java线程
Java爱好者第 26 页http://www.javafan.net
适用于相关数据项（如粒子的位置和速率）和元数据项（如链表中包含的数据值和列表自身中的数
据项的链）。
考虑以下示例，它实现了一个简单（但不是线程安全的）的整数堆栈：
public class UnsafeStack {
public int top = 0;
public int[] values = new int[1000];
public void push(int n) {
values[top++] = n;
}
public int pop() {
return values[--top];
}
}
如果多个线程试图同时使用这个类，会发生什么？这可能是个灾难。因为没有同步，多个线程可以
同时执行 push() 和pop()。如果一个线程调用 push()，而另一个线程正好在递增了 top 并要把
它用作 values 的下标之间调用 push()，会发生什么？结果，这两个线程会把它们的新值存储到相
同的位置！当多个线程依赖于数据值之间的已知关系，但没有确保只有一个线程可以在给定时间操
作那些值时，可能会发生许多形式的数据损坏，而这只是其中之一。
对于这种情况，补救办法很简单：同步push() 和pop() 这两者，您将防止线程执行相互干扰。
请注意，使用 volatile 还不够— 需要使用 synchronized 来确保 top 和 values 之间的关系保
持一致。
递增共享计数器
通常，如果正在保护一个基本变量（如一个整数），有时只使用volatile 就可以侥幸过关。但是，
如果变量的新值派生自以前的值，就必须使用同步。为什么？考虑这个类：
Java线程
Java爱好者第 27 页http://www.javafan.net
public class Counter {
private int counter = 0;
public int get() { return counter; }
public void set(int n) { counter = n; }
public void increment() {
set(get() + 1);
}
}
当我们要递增计数器时，会发生什么？请看 increment() 的代码。它很清楚，但不是线程安全的。
如果两个线程试图同时执行 increment()，会发生什么？计数器也许会增加 1，也许增加 2。令人
惊奇的是，把counter 标记成volatile 没有帮助，使 get() 和 set() 都变成 synchronized 也
没有帮助。
设想计数器是零，而两个线程同时执行递增操作代码。这两个线程会调用Counter.get()，并且看
到计数器是零。现在两个线程都对它加一，然后调用 Counter.set()。如果我们的计时不太凑巧，
那么这两个线程都看不到对方的更新，即使 counter 是 volatile，或者get() 和 set() 是
synchronized。现在，即使计数器递增了两次，得到的值也许只是一，而不是二。
要使递增操作正确运行，不仅get() 和 set() 必须是 synchronized，而且 increment() 也必需
是 synchronized！否则，调用 increment() 的线程可能会中断另一个调用 increment() 的线程。
如果您不走运，最终结果将会是计数器只增加了一次，不是两次。同步 increment() 防止了这种情
况的发生，因为整个递增操作是原子的。
当循环遍历Vector 的元素时，同样如此。即使同步了 Vector 的方法，但在循环遍历时，Vector 的
内容仍然会更改。如果要确保Vector 的内容在循环遍历时不更改，必须同步整个代码块。
不变性和final 字段
许多 Java 类，包括String、Integer 和 BigDecimal，都是不可改变的：一旦构造之后，它们的
状态就永远不会更改。如果某个类的所有字段都被声明成 final，那么这个类就是不可改变的。（实
Java线程
Java爱好者第 28 页http://www.javafan.net
际上，许多不可改变的类都有非 final 字段，用于高速缓存以前计算的方法结果，如
String.hashCode()，但调用者看不到这些字段。）
不可改变的类使并发编程变得非常简单。因为不能更改它们的字段，所以就不需要担心把状态的更
改从一个线程传递到另一个线程。在正确构造了对象之后，可以把它看作是常量。
同样，final 字段对于线程也更友好。因为 final 字段在初始化之后，它们的值就不能更改，所以
当在线程之间共享 final 字段时，不需要担心同步访问。
什么时候不需要同步
在某些情况中，您不必用同步来将数据从一个线程传递到另一个，因为 JVM 已经隐含地为您执行同
步。这些情况包括：
由静态初始化器（在静态字段上或 static{} 块中的初始化器）初始化数据时
访问 final 字段时
在创建线程之前创建对象时
线程可以看见它将要处理的对象时
死锁
只要您拥有多个进程，而且它们要争用对多个锁的独占访问，那么就有可能发生死锁。如果有一组
进程或线程，其中每个都在等待一个只有其它进程或线程才可以执行的操作，那么就称它们被死锁
了。
最常见的死锁形式是当线程 1 持有对象 A 上的锁，而且正在等待与 B 上的锁，而线程 2 持有对
象 B 上的锁，却正在等待对象 A 上的锁。这两个线程永远都不会获得第二个锁，或者释放第一个
锁。它们只会永远等待下去。
要避免死锁，应该确保在获取多个锁时，在所有的线程中都以相同的顺序获取锁。
Java线程
Java爱好者第 29 页http://www.javafan.net
性能考虑事项
关于同步的性能代价有许多说法— 其中有许多是错的。同步，尤其是争用的同步，确实有性能问
题，但这些问题并没有象人们普遍怀疑的那么大。
许多人都使用别出心裁但不起作用的技巧以试图避免必须使用同步，但最终都陷入了麻烦。一个典
型的示例是双重检查锁定模式（请参阅参考资料，其中有几篇文章讲述了这种模式有什么问题）。
这种看似无害的结构据说可以避免公共代码路径上的同步，但却令人费解地失败了，而且所有试图
修正它的尝试也失败了。
在编写并发代码时，除非看到性能问题的确凿证据，否则不要过多考虑性能。瓶颈往往出现在我们
最不会怀疑的地方。投机性地优化一个也许最终根本不会成为性能问题的代码路径— 以程序正确
性为代价— 是一桩赔本的生意。
同步准则
当编写 synchronized 块时，有几个简单的准则可以遵循，这些准则在避免死锁和性能危险的风险
方面大有帮助：
使代码块保持简短。Synchronized 块应该简短— 在保证相关数据操作的完整性的同时，
尽量简短。把不随线程变化的预处理和后处理移出synchronized 块。
不要阻塞。不要在synchronized 块或方法中调用可能引起阻塞的方法，如
InputStream.read()。
在持有锁的时候，不要对其它对象调用方法。这听起来可能有些极端，但它消除了最常见的
死锁源头。
Java线程
Java爱好者第 30 页http://www.javafan.net
第七章其它线程API详细信息
wait()、notify() 和notifyAll() 方法
除了使用轮询（它可能消耗大量 CPU 资源，而且具有计时不精确的特征），Object 类还包括一些
方法，可以让线程相互通知事件的发生。
Object 类定义了wait()、notify()和notifyAll()方法。要执行这些方法，必须拥有相关对象的锁。
Wait() 会让调用线程休眠，直到用 Thread.interrupt() 中断它、过了指定的时间、或者另一个线
程用 notify() 或 notifyAll() 唤醒它。
当对某个对象调用 notify() 时，如果有任何线程正在通过 wait() 等待该对象，那么就会唤醒其
中一个线程。当对某个对象调用 notifyAll() 时，会唤醒所有正在等待该对象的线程。
这些方法是更复杂的锁定、排队和并发性代码的构件。但是，notify() 和 notifyAll() 的使用很
复杂。尤其是，使用 notify() 来代替notifyAll() 是有风险的。除非您确实知道正在做什么，否
则就使用 notifyAll()。
与其使用 wait() 和notify() 来编写您自己的调度程序、线程池、队列和锁，倒不如使用
util.concurrent 包（请参阅参考资料），这是一个被广泛使用的开放源码工具箱，里面都是有用
的并发性实用程序。JDK 1.5 将包括 java.util.concurrent 包；它的许多类都派生自
util.concurrent。
线程优先级
Thread API 让您可以将执行优先级与每个线程关联起来。但是，这些优先级如何映射到底层操作系
统调度程序取决于实现。在某些实现中，多个— 甚至全部— 优先级可能被映射成相同的底层操
作系统优先级。
在遇到诸如死锁、资源匮乏或其它意外的调度特征问题时，许多人都想要调整线程优先级。但是，
通常这样只会把问题移到别的地方。大多数程序应该完全避免更改线程优先级。
线程组
ThreadGroup 类原本旨在用于把线程集合构造成组。但是，结果证明 ThreadGroup 并没有那样有用。
您最好只使用 Thread 中的等价方法。
ThreadGroup 确实提供了一个有用的功能部件（Thread 中目前还没有）：uncaughtException() 方
法。线程组中的某个线程由于抛出了未捕获的异常而退出时，会调用
ThreadGroup.uncaughtException() 方法。这就让您有机会关闭系统、将一条消息写到日志文件或
者重新启动失败的服务。
SwingUtilities
虽然 SwingUtilities 类不是Thread API 的一部分，但还是值得简单提一下。
正如前面提到的，Swing 应用程序有一个 UI 线程（有时叫称为事件线程），所有UI 活动都必须
在这个线程中发生。有时，另一个线程也许想要更新屏幕上某样东西的外观，或者触发Swing 对象
上的一个事件。
SwingUtilities.invokeLater() 方法可以让您将 Runnable 对象传送给它，并且在事件线程中执行
指定的 Runnable。它的同类 invokeAndWait() 会在事件线程中调用 Runnable，但invokeAndWait()
会阻塞，直到 Runnable 完成执行之后。
void showHelloThereDialog() throws Exception {
Runnable showModalDialog = new Runnable() {
public void run() {
JOptionPane.showMessageDialog(myMainFrame, "Hello There");
}
};
SwingUtilities.invokeLater(showModalDialog);
}
对于 AWT 应用程序，java.awt.EventQueue 还提供了 invokeLater() 和 invokeAndWait()。
 Copyright ©2011 lyt. All Rights Reserved.
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 Java多线程实现方式主要有三种：继承Thread类、实现Runnable接口、使用ExecutorService、Callable、Future实现有返回结果的多线程。其中前两种方式线程执行完后都没有返回值，只有最后一种是带返回值的
第三种方式如下
import java.util.concurrent.*;
import java.util.Date;
import java.util.List;
import java.util.ArrayList;

/**
* 有返回值的线程
*/
@SuppressWarnings("unchecked")
public class Test {
public static void main(String[] args) throws ExecutionException,
    InterruptedException {
   System.out.println("----程序开始运行----");
   Date date1 = new Date();

   int taskSize = 5;
   // 创建一个线程池
   ExecutorService pool = Executors.newFixedThreadPool(taskSize);
   // 创建多个有返回值的任务
   List<Future> list = new ArrayList<Future>();
   for (int i = 0; i < taskSize; i++) {
    Callable c = new MyCallable(i + " ");
    // 执行任务并获取Future对象
    Future f = pool.submit(c);
    // System.out.println(">>>" + f.get().toString());
    list.add(f);
   }
   // 关闭线程池
   pool.shutdown();

   // 获取所有并发任务的运行结果
   for (Future f : list) {
    // 从Future对象上获取任务的返回值，并输出到控制台
    System.out.println(">>>" + f.get().toString());
   }

   Date date2 = new Date();
   System.out.println("----程序结束运行----，程序运行时间【"
     + (date2.getTime() - date1.getTime()) + "毫秒】");
}
}

class MyCallable implements Callable<Object> {
private String taskNum;

MyCallable(String taskNum) {
   this.taskNum = taskNum;
}

public Object call() throws Exception {
   System.out.println(">>>" + taskNum + "任务启动");
   Date dateTmp1 = new Date();
   Thread.sleep(1000);
   Date dateTmp2 = new Date();
   long time = dateTmp2.getTime() - dateTmp1.getTime();
   System.out.println(">>>" + taskNum + "任务终止");
   return taskNum + "任务返回运行结果,当前任务时间【" + time + "毫秒】";
}
}


同步代码块嵌套容易导致死锁（互锁），不要使用

vector是线程安全的，arraylist是线程不安全的  add
stringbuffer是线程安全的，stringbuilder是线程不安全的，append stringbuilder用于系统启动时处理速度快
hashtable是线程安全的，hashmap是线程不安全的 put

有方法可以是线程不安全的集合转换成线程安全的，从而避免使用线程安全的类
Connection.synchronizedList(List)
Connection.synchronizedMap(Map)
Connection.synchronizedSet(Set)


锁的方式： syncronize(this)和syncronize(this.getClass) 是锁对象数据和锁对象类型的区别
注意：如果用成员作为锁的对象，则成员类型必须是静态的




Java多线程-线程的调度(守护线程)

守护线程与普通线程写法上基本没啥区别，调用线程对象的方法setDaemon(true)，则可以将其设置为守护线程。

守护线程使用的情况较少，但并非无用，举例来说，JVM的垃圾回收、内存管理等线程都是守护线程。还有就是在做数据库应用时候，使用的数据库连接池，连接池本身也包含着很多后台线程，监控连接个数、超时时间、状态等等。

setDaemon方法的详细说明：
public final void setDaemon(boolean on)：将该线程标记为守护线程或用户线程。当正在运行的线程都是守护线程时，Java虚拟机退出。

该方法必须在启动线程前调用。

该方法首先调用该线程的checkAccess方法，且不带任何参数。这可能抛出SecurityException（在当前线程中）。


参数： 
on - 如果为 true，则将该线程标记为守护线程。 
抛出： 
IllegalThreadStateException - 如果该线程处于活动状态。 
SecurityException - 如果当前线程无法修改该线程。 
另请参见： 
isDaemon(), checkAccess()




thread.Join把指定的线程加入到当前线程，可以将两个交替执行的线程合并为顺序执行的线程。比如在线程B中调用了线程A的Join()方法，直到线程A执行完毕后，才会继续执行线程B。

t.join();      //使调用线程 t 在此之前执行完毕。
t.join(1000);  //等待 t 线程，等待时间是1000毫秒




1、sleep()
使当前线程（即调用该方法的线程）暂停执行一段时间，让其他线程有机会继续执行，但它并不释放对象锁。也就是说如果有synchronized同步快，其他线程仍然不能访问共享数据。注意该方法要捕捉异常。
例如有两个线程同时执行(没有synchronized)一个线程优先级为MAX_PRIORITY，另一个为MIN_PRIORITY，如果没有Sleep()方法，只有高优先级的线程执行完毕后，低优先级的线程才能够执行；但是高优先级的线程sleep(500)后，低优先级就有机会执行了。
总之，sleep()可以使低优先级的线程得到执行的机会，当然也可以让同优先级、高优先级的线程有执行的机会。

2、join()
join()方法使调用该方法的线程在此之前执行完毕，也就是等待该方法的线程执行完毕后再往下继续执行。注意该方法也需要捕捉异常。
3、yield()
该方法与sleep()类似，只是不能由用户指定暂停多长时间，并且yield（）方法只能让同优先级的线程有执行的机会。
4、wait()和notify()、notifyAll()
这三个方法用于协调多个线程对共享数据的存取，所以必须在synchronized语句块内使用。synchronized关键字用于保护共享数据，阻止其他线程对共享数据的存取，但是这样程序的流程就很不灵活了，如何才能在当前线程还没退出synchronized数据块时让其他线程也有机会访问共享数据呢？此时就用这三个方法来灵活控制。
wait()方法使当前线程暂停执行并释放对象锁标示，让其他线程可以进入synchronized数据块，当前线程被放入对象等待池中。当调用notify()方法后，将从对象的等待池中移走一个任意的线程并放到锁标志等待池中，只有锁标志等待池中线程能够获取锁标志；如果锁标志等待池中没有线程，则notify()不起作用。
notifyAll()则从对象等待池中移走所有等待那个对象的线程并放到锁标志等待池中。
注意 这三个方法都是Java.lang.Object的方法。




二、run和start()
把需要处理的代码放到run()方法中，start()方法启动线程将自动调用run()方法，这个由java的内存机制规定的。并且run()方法必需是public访问权限，返回值类型为void。

三、关键字synchronized
该关键字用于保护共享数据，当然前提条件是要分清哪些数据是共享数据。每个对象都有一个锁标志，当一个线程访问到该对象，被Synchronized修饰的数据将被"上锁"，阻止其他线程访问。当前线程访问完这部分数据后释放锁标志，其他线程就可以访问了。


四、wait()和notify(),notifyAll()是Object类的方法，sleep()和yield()是Thread类的方法。
(1)、常用的wait方法有wait()和wait(long timeout);
void wait() 在其他线程调用此对象的 notify() 方法或者 notifyAll()方法前，导致当前线程等待。
void wait(long timeout)在其他线程调用此对象的notify() 方法 或者 notifyAll()方法，或者超过指定的时间量前，导致当前线程等待。
wait()后，线程会释放掉它所占有的“锁标志”，从而使线程所在对象中的其他shnchronized数据可被别的线程使用。

wait()h和notify()因为会对对象的“锁标志”进行操作，所以他们必需在Synchronized函数或者 synchronized block 中进行调用。如果在non-synchronized 函数或 non-synchronized block 中进行调用，虽然能编译通过，但在运行时会发生IllegalMonitorStateException的异常。。

(2)、Thread.sleep(long millis)必须带有一个时间参数。
sleep(long)使当前线程进入停滞状态，所以执行sleep()的线程在指定的时间内肯定不会被执行；
sleep(long)可使优先级低的线程得到执行的机会，当然也可以让同优先级的线程有执行的机会；
sleep(long)是不会释放锁标志的。

(3)、yield()没有参数
sleep 方法使当前运行中的线程睡眠一段时间，进入不可以运行状态，这段时间的长短是由程序设定的，yield方法使当前线程让出CPU占有权，但让出的时间是不可设定的。
yield()也不会释放锁标志。
实际上，yield()方法对应了如下操作；先检测当前是否有相同优先级的线程处于同可运行状态，如有，则把CPU的占有权交给次线程，否则继续运行原来的线程，所以yield()方法称为“退让”，它把运行机会让给了同等级的其他线程。

sleep 方法允许较低优先级的线程获得运行机会，但yield（）方法执行时，当前线程仍处在可运行状态，所以不可能让出较低优先级的线程此时获取CPU占有权。在一个运行系统中，如果较高优先级的线程没有调用sleep方法，也没有受到I/O阻塞，那么较低优先级线程只能等待所有较高优先级的线程运行结束，方可有机会运行。

yield()只是使当前线程重新回到可执行状态，所有执行yield()的线程有可能在进入到可执行状态后马上又被执行，所以yield()方法只能使同优先级的线程有执行的机会





Timer是一种线程设施，用于安排以后在后台线程中执行的任务。可安排任务执行一次，或者定期重复执行，可以看成一个定时器，可以调度TimerTask。TimerTask是一个抽象类，实现了Runnable接口，所以具备了多线程的能力。

 public static void main(String[] args) {  
        Timer timer = new Timer();    
  
        timer.schedule(new OneTask(1), 5000);// 5秒后启动任务  
          
        OneTask secondTask= new OneTask(2);  
        timer.schedule(secondTask, 1000, 3000);// 1秒后启动任务,以后每隔3秒执行一次线程  
          
        Date date = new Date();   
        timer.schedule(new OneTask(3),new Date(date.getTime()+1000));//以date为参数，指定某个时间点执行线程  
          
//      timer.cancel();  
//      secondTask.cancel();  
        System.out.println("end in main thread...");  
    }  




lock()和unlock()取代syncronize(){}












工作中，经常会涉及到线程。比如有些任务，经常会交与线程去异步执行。抑或服务端程序为每个请求单独建立一个线程处理任务。线程之外的，比如我们用的数据库连接。这些创建销毁或者打开关闭的操作，非常影响系统性能。所以，“池”的用处就凸显出来了。

1. 为什么要使用线程池

在3.6.1节介绍的实现方式中，对每个客户都分配一个新的工作线程。当工作线程与客户通信结束，这个线程就被销毁。这种实现方式有以下不足之处：

服务器创建和销毁工作的开销( 包括所花费的时间和系统资源 )很大。这一项不用解释，可以去查下"线程创建过程"。除了机器本身所做的工作，我们还要实例化，启动，这些都需要占用堆栈资源。

除了创建和销毁线程的开销之外，活动的线程也消耗系统资源。 这个应该是对堆栈资源的消耗，猜测数据库连接数设置一个合理的值，也有这个考虑。

如果线程数目固定，并且每个线程都有很长的声明周期，那么线程切换也是相对固定的。不同的操作系统有不同的切换周期，一般20ms左右。这里说的切换是在jvm以及底层操作系统的调度下，线程之间转让cpu的使用权。如果频繁创建和销毁线程，那么就将频繁的切换线程，因为一个线程销毁后，必然要让出使用权给已经就绪的线程，使该线程获得运行机会。在这种情况下，线程之间的切换就不在遵循系统的固定切换周期，切换线程的开销甚至比创建和销毁的开销还要大。

相对来说，使用线程池，会预创建一些线程，它们不断的从工作队列中取出任务，然后执行该任务。当工作线程执行完一个任务后，就会继续执行工作队列中的另一个任务。优点如下：

减少了创建和销毁的次数，每个工作线程都可以一直被重用，能执行多个任务。

可以根据系统的承载能力，方便的调整线程池中线程的数目，防止因为消耗过量的系统资源而导致系统崩溃。

2. 线程池的简单实现

下面是自己写的一个简单的线程池，也是从Java网络编程这本书上直接照着敲出来的



package thread;import java.util.LinkedList;/**
 * 线程池的实现，根据常规线程池的长度，最大长度，队列长度，我们可以增加数目限制实现
 * @author Han */public class MyThreadPool extends ThreadGroup{    //cpu 数量 ---Runtime.getRuntime().availableProcessors();    //是否关闭
    private boolean isClosed = false;    //队列
    private LinkedList<Runnable> workQueue;    //线程池id
    private static int threadPoolID;    private int threadID;    public MyThreadPool(int poolSize){        super("MyThreadPool."+threadPoolID);
        threadPoolID++;
        setDaemon(true);
        workQueue = new LinkedList<Runnable>();        for(int i = 0;i<poolSize;i++){            new WorkThread().start();
        }
    }    //这里可以换成ConcurrentLinkedQueue,就可以避免使用synchronized的效率问题
    public synchronized void execute(Runnable task){        if(isClosed){            throw new IllegalStateException("连接池已经关闭...");
        }else{
            workQueue.add(task);
            notify();
        }
    }    
    protected synchronized Runnable getTask() throws InterruptedException {        while(workQueue.size() == 0){            if(isClosed){                return null;
            }
            wait();
        }        return workQueue.removeFirst();
    }    
    public synchronized void close(){        if(!isClosed){
            isClosed = true;
            workQueue.clear();
            interrupt();
        }
    }    
    public void join(){        synchronized (this) {
            isClosed = true;
            notifyAll();
        }
        Thread[] threads = new Thread[activeCount()];        int count = enumerate(threads);        for(int i = 0;i<count;i++){            try {
                threads[i].join();
            } catch (Exception e) {
            }
        }
    }    
    class WorkThread extends Thread{        public WorkThread(){            super(MyThreadPool.this,"workThread"+(threadID++));
            System.out.println("create...");
        }
        @Override        public void run() {            while(!isInterrupted()){
                System.out.println("run..");
                Runnable task = null;                try {                    //这是一个阻塞方法
                    task = getTask();
                    
                } catch (Exception e) {
                    
                }                if(task != null){
                    task.run();
                }else{                    break;
                }
            }
        }
    }
}


该线程池主要定义了一个工作队列和一些预创建的线程。只要调用execute方法，就可以向线程提交任务。

后面线程在没有任务的时候，会阻塞在getTask(),直到有新任务进来被唤醒。

join和close都可以用来关闭线程池。不同的是，join会把队列中的任务执行完，而close则立刻清空队列，并且中断所有的工作线程。close()中的interrupt()相当于调用了ThreadGroup中包含子线程的各自的interrupt()，所以有线程处于wait或者sleep时，都会抛出InterruptException

测试类如下:



public class TestMyThreadPool {    public static void main(String[] args) throws InterruptedException {
        MyThreadPool pool = new MyThreadPool(3);        for(int i = 0;i<10;i++){
            pool.execute(new Runnable() {
                @Override                public void run() {                    try {
                        Thread.sleep(1000);
                    } catch (InterruptedException e) {
                    }
                    System.out.println("working...");
                }
            });
        }
        pool.join();        //pool.close();
    }
}


3. jdk类库提供的线程池

java提供了很好的线程池实现，比我们自己的实现要更加健壮以及高效，同时功能也更加强大。

类图如下：



关于这类线程池，前辈们已经有很好的讲解。任意百度下java线程池，都有写的非常详细的例子和教程，这里就不再赘述。

java自带线程池和队列详解

4. spring注入线程池

在使用spring框架的时候，如果我们用java提供的方法来创建线程池，在多线程应用中非常不方便管理，而且不符合我们使用spring的思想。(虽然spring可以通过静态方法注入)

其实,Spring本身也提供了很好的线程池的实现。这个类叫做ThreadPoolTaskExecutor。

在spring中的配置如下：



<bean id="executorService" class="org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor">
        <property name="corePoolSize" value="${threadpool.corePoolSize}" />
        <!-- 线程池维护线程的最少数量 -->
        <property name="keepAliveSeconds" value="${threadpool.keepAliveSeconds}" />
        <!-- 线程池维护线程所允许的空闲时间 -->
        <property name="maxPoolSize" value="${threadpool.maxPoolSize}" />
        <!-- 线程池维护线程的最大数量 -->
        <property name="queueCapacity" value="${threadpool.queueCapacity}" />
        <!-- 线程池所使用的缓冲队列 -->
    </bean>


5. 使用线程池的注意事项

死锁

任何多线程程序都有死锁的风险，最简单的情形是两个线程AB，A持有锁1，请求锁2，B持有锁2，请求锁1。（这种情况在mysql的排他锁也会出现，不会数据库会直接报错提示）。线程池中还有另一种死锁：假设线程池中的所有工作线程都在执行各自任务时被阻塞，它们在等待某个任务A的执行结果。而任务A却处于队列中，由于没有空闲线程，一直无法得以执行。这样线程池的所有资源将一直阻塞下去，死锁也就产生了。

系统资源不足

如果线程池中的线程数目非常多，这些线程会消耗包括内存和其他系统资源在内的大量资源，从而严重影响系统性能。

并发错误

线程池的工作队列依靠wait()和notify()方法来使工作线程及时取得任务，但这两个方法难以使用。如果代码错误，可能会丢失通知，导致工作线程一直保持空闲的状态，无视工作队列中需要处理的任务。因为最好使用一些比较成熟的线程池。

线程泄漏

使用线程池的一个严重风险是线程泄漏。对于工作线程数目固定的线程池，如果工作线程在执行任务时抛出RuntimeException或Error，并且这些异常或错误没有被捕获，那么这个工作线程就异常终止，使线程池永久丢失了一个线程。（这一点太有意思）

另一种情况是，工作线程在执行一个任务时被阻塞，如果等待用户的输入数据，但是用户一直不输入数据，导致这个线程一直被阻塞。这样的工作线程名存实亡，它实际上不执行任何任务了。如果线程池中的所有线程都处于这样的状态，那么线程池就无法加入新的任务了。

任务过载

当工作线程队列中有大量排队等待执行的任务时，这些任务本身可能会消耗太多的系统资源和引起资源缺乏。

综上所述，使用线程池时，要遵循以下原则：

如果任务A在执行过程中需要同步等待任务B的执行结果，那么任务A不适合加入到线程池的工作队列中。如果把像任务A一样的需要等待其他任务执行结果的加入到队列中，可能造成死锁

如果执行某个任务时可能会阻塞，并且是长时间的阻塞，则应该设定超时时间，避免工作线程永久的阻塞下去而导致线程泄漏。在服务器才程序中，当线程等待客户连接，或者等待客户发送的数据时，都可能造成阻塞，可以通过以下方式设置时间：

调用ServerSocket的setSotimeout方法，设定等待客户连接的超时时间。

对于每个与客户连接的socket，调用该socket的setSoTImeout方法，设定等待客户发送数据的超时时间。

了解任务的特点，分析任务是执行经常会阻塞io操作，还是执行一直不会阻塞的运算操作。前者时断时续的占用cpu，而后者具有更高的利用率。预计完成任务大概需要多长时间，是短时间任务还是长时间任务，然后根据任务的特点，对任务进行分类，然后把不同类型的任务加入到不同的线程池的工作队列中，这样就可以根据任务的特点，分配调整每个线程池

调整线程池的大小。线程池的最佳大小主要取决于系统的可用cpu的数目，以及工作队列中任务的特点。假如一个具有N个cpu的系统上只有一个工作队列，并且其中全部是运算性质(不会阻塞)的任务，那么当线程池拥有N或N+1个工作线程时，一般会获得最大的cpu使用率。

如果工作队列中包含会执行IO操作并经常阻塞的任务，则要让线程池的大小超过可用 cpu的数量，因为并不是所有的工作线程都一直在工作。选择一个典型的任务，然后估计在执行这个任务的工程中，等待时间与实际占用cpu进行运算的时间的比例WT/ST。对于一个具有N个cpu的系统，需要设置大约N*(1+WT/ST)个线程来保证cpu得到充分利用。

当然,cpu利用率不是调整线程池过程中唯一要考虑的事项，随着线程池工作数目的增长，还会碰到内存或者其他资源的限制，如套接字，打开的文件句柄或数据库连接数目等。要保证多线程消耗的系统资源在系统承受的范围之内。

避免任务过载。服务器应根据系统的承载能力，限制客户并发连接的数目。当客户的连接超过了限制值，服务器可以拒绝连接，并进行友好提示，或者限制队列长度.







 